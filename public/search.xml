<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>多线程交替打印奇偶数</title>
      <link href="/p/a5a2448d.html"/>
      <url>/p/a5a2448d.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>实现两个线程分别打印奇数和偶数，中间停顿1秒。</p><p><b> 案例：</b></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输出：</span><br><span class="line">偶数：0</span><br><span class="line">奇数：1</span><br><span class="line">偶数：2</span><br><span class="line">奇数：3</span><br><span class="line">偶数：4</span><br><span class="line">奇数：5</span><br><span class="line">偶数：6</span><br></pre></td></tr></table></figure><hr><h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Semaphore实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOddEven1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Odd().start();</span><br><span class="line">        <span class="keyword">new</span> Even().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Odd</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">2</span> != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        System.out.println(<span class="string">"奇数："</span> + num++);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Even</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        semaphore.acquire();</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        System.out.println(<span class="string">"偶数："</span> + num++);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        semaphore.release();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用锁对象实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrintOddEven2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> OddThread().start();</span><br><span class="line">        <span class="keyword">new</span> EvenThread().start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OddThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"奇数线程:"</span> + num++);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                            lock.notify();</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">EvenThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"偶数线程:"</span> + num++);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                            lock.notify();</span><br><span class="line">                            lock.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode5-最长回文子串</title>
      <link href="/p/928fb1f0.html"/>
      <url>/p/928fb1f0.html</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 s，找到 s 中最长的回文子串。</p><p>** 案例1:**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure><p>** 案例2:**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;cbbd&quot;</span><br><span class="line">输出：&quot;bb&quot;</span><br></pre></td></tr></table></figure><p>** 案例3:**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;a&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p>** 案例4:**</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s &#x3D; &quot;ac&quot;</span><br><span class="line">输出：&quot;a&quot;</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>1 &lt;= s.length &lt;= 1000</li><li>s 仅由数字和英文字母（大写和/或小写）组成</li></ul><h2 id="解法1"><a href="#解法1" class="headerlink" title="解法1"></a>解法1</h2><p>首先我们要理解什么是回文子串，即左右对称的为回文子串。我们在寻找子串的时候只能通过两个循环去寻找子串，于是我们可以先确定右边界，依次右移来获取子串。</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-02-24/%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2.png" alt="回文子串"></p><p>我们通过边界右移寻找子串比较他们的子串是否相同，如果不同则存到<code>dp[][]</code>的二维数组里面，可以下次使用，这是动态规划的思想，空间置换时间。具体解法代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果字符串大小小于1直接返回空串即可</span></span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> length = s.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前面校验过空串，这边直接取第一个字符作为初始化字符即可</span></span><br><span class="line">        String maxStr = s.substring(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[length][length];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对dp数组进行初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> right = <span class="number">1</span>; right &lt; length; right++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> left = <span class="number">0</span>; left &lt; right; left++) &#123;</span><br><span class="line">                <span class="comment">// 两端不相等的情况</span></span><br><span class="line">                <span class="keyword">if</span>(s.charAt(right) != s.charAt(left)) &#123;</span><br><span class="line">                    dp[right][left] = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 两端相等的情况</span></span><br><span class="line">                    <span class="keyword">if</span>(left + <span class="number">1</span> &gt;= right -<span class="number">1</span>) &#123;</span><br><span class="line">                        dp[right][left] = <span class="keyword">true</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[right][left] = dp[right - <span class="number">1</span>][left + <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(dp[right][left] &amp;&amp; right - left + <span class="number">1</span> &gt; maxStr.length()) &#123;</span><br><span class="line">                        maxStr = s.substring(left, right + <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解法2"><a href="#解法2" class="headerlink" title="解法2"></a>解法2</h2><p><a href="http://www.cxyxiaowu.com/2869.html" target="_blank" rel="noopener">Manacher算法</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        String str = addBoundaries(s, <span class="string">'#'</span>);</span><br><span class="line">        <span class="keyword">int</span> sLen = <span class="number">2</span> * len + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sLen; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> curLen = centerSpread(str, i);</span><br><span class="line">            <span class="keyword">if</span> (curLen &gt; maxLen) &#123;</span><br><span class="line">                maxLen = curLen;</span><br><span class="line">                start = (i - maxLen) / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">centerSpread</span><span class="params">(String s, <span class="keyword">int</span> center)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// left = right 的时候，此时回文中心是一个空隙，回文串的长度是奇数</span></span><br><span class="line">        <span class="comment">// right = left + 1 的时候，此时回文中心是任意一个字符，回文串的长度是偶数</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">int</span> i = center - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> j = center + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; len &amp;&amp; s.charAt(i) == s.charAt(j)) &#123;</span><br><span class="line">            i--;</span><br><span class="line">            j++;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建预处理字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s      原始字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> divide 分隔字符</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 使用分隔字符处理以后得到的字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">addBoundaries</span><span class="params">(String s, <span class="keyword">char</span> divide)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s.indexOf(divide) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"参数错误，您传递的分割字符，在输入字符串中存在！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder stringBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            stringBuilder.append(divide);</span><br><span class="line">            stringBuilder.append(s.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        stringBuilder.append(divide);</span><br><span class="line">        <span class="keyword">return</span> stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多线程基础</title>
      <link href="/p/53471b9a.html"/>
      <url>/p/53471b9a.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在准备面试，所以重新复习下多线程基础方面的知识，后续还会跟进JUC包下常用的类等。多线程基础方面知识也好久没看了，这边学习了<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255943750561472" target="_blank" rel="noopener">廖雪峰老师的课</a>,在这做下笔记，下文大多都是引用廖雪峰老师的笔记，记录一些平时比较模糊的地方。</p><h2 id="多线程基础"><a href="#多线程基础" class="headerlink" title="多线程基础"></a>多线程基础</h2><p>特别注意：直接调用Thread实例的<code>run()</code>方法是无效的。<br>可以对线程设置优先级<code>Thread.setPriority(int n) //1~10, 默认值5</code>。优先级高的线程被操作系统调度的优先级较高，操作系统对高优先级线程<strong>可能</strong>调度更频繁，但我们绝不能通过设置优先级来确保高优先级的线程一定会先执行。</p><hr><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><p>在Java程序中，一个线程对象只能调用一次<code>start()</code>方法来启动新线程，并在新线程中执行<code>run()</code>方法。一旦<code>run()</code>方法执行完毕，线程就结束了。因此Java线程的状态有下面几种</p><ol><li>New：新创建的线程，尚未执行。</li><li>Runnable：运行中的线程，正在执行<code>run()</code>方法的Java代码。</li><li>Block：运行中的线程，因为某些操作被阻塞而挂起。</li><li>Waiting：运行中的线程，因为某些操作在等待中。</li><li>Timed Waiting：运行中的线程，因为执行<code>sleep()</code>方法正在计时等待。</li><li>Terminated：线程已终止，因为<code>run()</code></li></ol><p>当线程启动后，他可以在<code>Runnable</code>、<code>Block</code>、<code>Waiting</code>和<code>Timed Waiting</code>这几个状态之间切换，直到最后变成<code>Terminated</code>状态线程终止。</p><p>线程终止的原因有：</p><ol><li>线程正常终止：<code>run()</code>方法执行到<code>return</code>语句返回；</li><li>线程以外终止：<code>run()</code>方法因为未捕获的异常导致线程终止；</li><li>对某个线程的<code>Thread</code>实例调用<code>stop()</code>方法强制终止（强烈不推荐使用）。</li></ol><p>一个线程还可以等待另一个线程知道运行结束。例如<code>main</code>线程在启动<code>a</code>线程后，可以通过<code>a.join()</code>等待<code>a</code>线程结束后再继续运行。</p><p>如果<code>a</code>线程已经结束，对实例<code>a</code>调用<code>a.join()</code>会立刻返回。此外，<code>join(long)</code>的重载方法也可以指定一个等待时间，超过等待时间后就不再继续等待。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JoinTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread a = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"thead-a"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"start"</span>);</span><br><span class="line">        a.start();</span><br><span class="line">        a.join();</span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">hello</span><br><span class="line">end</span><br></pre></td></tr></table></figure><hr><h2 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h2><p>中断一个线程非常简单，只需要在其他线程中对目标线程调用<code>interrupt()</code>方法，目标线程需要反复检测自身状态是否是<code>interrupted</code>状态，如果是，就立刻结束运行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t = <span class="keyword">new</span> MyThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>); <span class="comment">// 暂停1毫秒</span></span><br><span class="line">        t.interrupt(); <span class="comment">// 中断t线程</span></span><br><span class="line">        t.join(); <span class="comment">// 等待t线程结束</span></span><br><span class="line">        System.out.println(<span class="string">"end"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!isInterrupted()) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">" hello!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 hello!</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>上述代码中，<code>main</code>线程通过调用<code>t.interrupt()</code>方法中断<code>t</code>线程，但是要注意，<code>interrupt()</code>方法仅仅向<code>t</code>线程发出了“中断请求”，至于t线程是否能立刻响应，要看具体代码。而<code>t</code>线程的<code>while</code>循环会检测<code>isInterrupted()</code>，所以上述代码能正确响应<code>interrupt()</code>请求，使得自身立刻结束运行<code>run()</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        HelloThread t = <span class="keyword">new</span> HelloThread();</span><br><span class="line">        t.start();</span><br><span class="line">        Thread.sleep(<span class="number">1</span>);</span><br><span class="line">        t.running = <span class="keyword">false</span>; <span class="comment">// 标志位置为false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> running = <span class="keyword">true</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (running) &#123;</span><br><span class="line">            n ++;</span><br><span class="line">            System.out.println(n + <span class="string">" hello!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"end!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 hello!</span><br><span class="line">2 hello!</span><br><span class="line">3 hello!</span><br><span class="line">end!</span><br></pre></td></tr></table></figure><p>中断线程的第二种方法就是，通过标记位来进行中断。<br>注意到<code>HelloThread</code>的标志位<code>boolean running</code>是一个线程间共享的变量。线程间共享变量需要使用volatile关键字标记，确保每个线程都能读取到更新后的变量值。</p><p>为什么要对线程间共享的变量用关键字volatile声明？这涉及到Java的内存模型。在Java虚拟机中，变量的值保存在主内存中，但是，当线程访问变量时，它会先获取一个副本，并保存在自己的工作内存中。如果线程修改了变量的值，虚拟机会在某个时刻把修改后的值回写到主内存，但是，这个时间是不确定的！</p><p><code>volatile</code>关键字的主要就是通知JVM：</p><ol><li>每次访问变量时，总是获取主内存的最新值。</li><li>每次修改变量后，立刻回写到主内存中。</li></ol><p><code>volatile</code>关键字解决的是可见性问题：当一个线程修改了某个共享变量的值，其他线程能够立刻看到修改后的值。</p><p>如果我们去掉<code>volatile</code>关键字，运行上述程序，发现效果和带<code>volatile</code>差不多，这是因为在<code>x86</code>的架构下，JVM回写主内存的速度非常快，但是，换成<code>ARM</code>的架构，就会有显著的延迟。</p><hr><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>Java程序入口是<code>main</code>线程，<code>main</code>线程又能启动其他线程，只有当所有线程都运行结束的时候，<code>JVM</code>才会退出，如果一个线程没有退出，<code>JVM</code>进程就不会退出，所以，必须保证所有线程都能及时结束。</p><p>当一个死循环的线程被创建，说名这个线程不能被结束。那JVM进程就无法结束，但谁负责结束这个线程呢。<br>我们可以将这个线程设置为守护线程，因为所有非守护线程执行完毕之后，无论有没有守护线程，虚拟机都会自动退出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread a = <span class="keyword">new</span> TestThread();</span><br><span class="line">a.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">a.start();</span><br></pre></td></tr></table></figure><p>我们可以在线程<code>start()</code>前设置<code>setDaemon(true)</code>可以将该线程标志为守护线程。</p><p>特别注意：守护线程不能持有需要关闭的资源，因为JVM退出时，守护线程没有任何机会来关闭资源，很有可能导致数据丢失。</p><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>HotSpot经典垃圾收集器(2)</title>
      <link href="/p/6b0deb04.html"/>
      <url>/p/6b0deb04.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前的<a href="https://molzhao.xyz/p/5b25d7d2.html" target="_blank" rel="noopener">文章</a>我们讲到了一部分垃圾收集器，这次我们聊一下CMS和G1垃圾收集器。在聊这两个收集器之前我们需要了解一个知识：并发标记。这是CMS和G1中非常重要的原理。</p><hr><h2 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h2><h3 id="为什么引入并发标记"><a href="#为什么引入并发标记" class="headerlink" title="为什么引入并发标记"></a>为什么引入并发标记</h3><p>我们知道HotSpot的垃圾收集器都是通过可达性分析算法来标记无用的对象的，在标记的时候都会让用户线程停顿一下，我们称之为STW。</p><p>Q1:为什么要STW？<br>A1:就是防止在标记的过程中，用户线程对象创建和销毁操作，导致最后标记结果不准，垃圾回收后造成严重后果。</p><p>当堆越大的时候，我们STW的时间也就越长，这显然严重影响到了我们的性能，如何让用户线程等待的时间缩短呢？于是就引入了并发标记这个概念，也就是和用户线程并发执行。</p><h3 id="并发标记的问题与解决"><a href="#并发标记的问题与解决" class="headerlink" title="并发标记的问题与解决"></a>并发标记的问题与解决</h3><p>前面我们说到STW的作用是防止用户线程对象创建和销毁操作，导致最后标记结果不准，那并发标记就肯定存在这个问题。</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-02-08/%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E7%9A%84%E9%97%AE%E9%A2%98.png" alt="并发标记的问题"></p><p>对象消失问题：在扫描过程中<u>插入了一条或者多条从黑色对象到白色对象的新引用</u>，并且同时<u>去掉了灰色对象到白色对象的引用</u>，由于可达性分析算法，不会在回头重新扫描，由此引发对象消失问题。</p><p>解决这个问题其实就是破坏上面下划线的两个条件之一即可：</p><p><strong>标记三阶段：</strong></p><ol><li>初始标记：标记GC ROOTS能直连的对象。</li><li>并发标记：进行可达性分析算法标记。</li><li>重新标记</li></ol><p>方案一：增量更新（CMS采用的方案）<br>增量更新就是在并发标记的时候如果有新增引用的话就将引用记录下来，在重新标记阶段根据记录在重新扫描一遍。</p><p>方案二：原始快照（SATB，G1采用的方案）<br>原始快照就是在并发标记的时候如果有删除引用的话就将引用记录下来，在最终标记阶段根据记录在重新扫描一遍。</p><hr><h2 id="跨代引用问题"><a href="#跨代引用问题" class="headerlink" title="跨代引用问题"></a>跨代引用问题</h2><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-02-08/%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98.png" alt="跨代引用问题"></p><p>如上图我们发现新生代中的对象被老年代所引用，在新生代中没有直接的<code>GC ROOTS</code>指向，但是老年代中指向了该对象，这时该对象是不应该被回收的。由此引出了跨代引用的问题。</p><h3 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h3><p>这个方案是我们最容易想到的，我们知道新生代的不可达对象不一定是垃圾，所以在每次可达性分析的时候遍历下老年代是否有对象引用了新生代中的对象，由于MinorGC很频繁，每次都需要遍历老年代的代价太大，同时存在跨代引用的情况也相对来说比较少。</p><h3 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h3><p>我们需要在新生代中创建一个记忆集的数组，里面的指针记录着老年代的<code>区域</code>如果记录的这块区域里的对象引用了新生代中的对象，则将这块区域标识为1，这种记录老年代区域的记忆表也称之为<code>卡表</code>。</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-02-08/%E5%8D%A1%E8%A1%A8.png" alt="卡表"></p><p>这样在下一次GC的时候，只需要扫描卡中存在引用的老年代区域即可，从而避免了对整个老年代进行扫描。</p><p><strong>引用实时变化，卡表记录信息过时怎么办？</strong><br>我们需要进行动态维护，我们需要在修改那一刻去维护卡表，通过写屏障，也可以理解为AOP切面，只要发生引用对象的赋值操作就会产生一个环形通知（即改变前后都有通知），将维护的代码写入通知处理中即可。</p><hr><h2 id="CMS垃圾收集器"><a href="#CMS垃圾收集器" class="headerlink" title="CMS垃圾收集器"></a>CMS垃圾收集器</h2><p>CMS（Concurrent Mark Swap）从字面意思上来说为并发标记清除。<br>设计目的：追求一个最短的停顿时间可以让用户线程和GC线程在某一阶段同时执行，不需要STW。</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-02-08/CMS%E5%9B%9B%E9%98%B6%E6%AE%B5.png" alt="CMS并发四阶段"></p><p><strong>CMS并发四阶段</strong>：</p><ol><li>初始标记：标记GC ROOTS能直连的对象，这个过程很快，将这些对象压入扫描栈中。</li><li>并发标记：根据扫描栈中的对象进行递归扫描，根据栈中的对象引用遍历出一个对象图出来，再此期间对象的引用关系的赋值会被记录下来。</li><li>重新标记：这个阶段也就是解决对象消失问题的阶段，根据之前的记录下来的引用关系在重新标记。停顿为了防止最后标记结果不准确。</li><li>并发清除：对标记好的垃圾进行并发清除。</li></ol><p><strong>优点</strong><br>只需要七个字就能概括CMS垃圾收集器：<font color="red">并发收集低停顿</font></p><p><strong>缺点</strong></p><ol><li>并发相对占用CPU资源，使得程序变慢。</li><li>无法清除浮动垃圾，因为在并发标记阶段用户线程产生的垃圾，无法被清除，只能等待下一次的GC。</li><li>CMS不会等待老年代内存用完才开始GC，因为他要给用户线程留预留空间，JDK1.6的阈值为92%，但是用户线程8%也不够用，如果不够用的情况，会立即冻结用户线程，此时Serial Old收集器就会登场，代替CMS收拾残局。</li><li>标记-清除带来的内存碎片问题，解决就是在FullGC的时候进行一次整理，此时需要STW，可以设置在几次FullGC的时候来整理压缩空间。</li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用网站收集</title>
      <link href="/p/31219038.html"/>
      <url>/p/31219038.html</url>
      
        <content type="html"><![CDATA[<h2 id="系统学习网站"><a href="#系统学习网站" class="headerlink" title="系统学习网站"></a>系统学习网站</h2><p><a href="https://lingcoder.github.io/OnJava8/#/sidebar" target="_blank" rel="noopener">Java编程思想</a></p><p><a href="https://www.pdai.tech/" target="_blank" rel="noopener">Java全栈学习</a></p><p><a href="https://github.com/AobingJava/JavaFamily.git" target="_blank" rel="noopener">敖丙</a></p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p><a href="https://www.cnblogs.com/tianzhihensu/p/11972780.html" target="_blank" rel="noopener">hashmap面试题</a></p><p><a href="https://www.cnblogs.com/jian-gao/p/10795407.html" target="_blank" rel="noopener">mysql四种隔离级别</a></p><p><a href="https://developer.aliyun.com/article/625858" target="_blank" rel="noopener">Sentinel哨兵</a></p><p><a href="https://www.toutiao.com/i6922759057132700171/?tt_from=weixin&utm_campaign=client_share&wxshare_count=1&timestamp=1611881135&app=news_article&utm_source=weixin&utm_medium=toutiao_ios&use_new_style=1&req_id=202101290845350102040571960C1A37BB&group_id=6922759057132700171" target="_blank" rel="noopener">服务治理</a></p><p><a href="https://www.cnblogs.com/mengdd/archive/2013/02/20/2917966.html" target="_blank" rel="noopener">多线程</a></p><p><a href="https://www.cnblogs.com/wangsongbai/p/11382536.html" target="_blank" rel="noopener">MySQL数据库高并发优化配置</a></p><p><a href="https://www.cnblogs.com/z941030/p/9218356.html" target="_blank" rel="noopener">布隆过滤器</a></p><p><a href="https://blog.csdn.net/sqsltr/article/details/94408487" target="_blank" rel="noopener">让你少走弯路的MySQL中rank()、row_number()、dense_rank()排序</a></p>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HotSpot经典垃圾收集器(1)</title>
      <link href="/p/5b25d7d2.html"/>
      <url>/p/5b25d7d2.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前面我们讲了垃圾回收机制，那现在主流的垃圾回收器是怎么样，下面介绍几种HotSpot推出的几种经典的垃圾收集器。</p><hr><h2 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h2><p>Serial（串行），是JDK1.3之前唯一的垃圾收集器，他是单线程的，串行是因为在GC线程运行时，另外的用户线程都必须得停下。GC运行这段时间为Stop The World（简称STW），该垃圾收集器。</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-01-23/STW.png" alt="STW"></p><hr><h2 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h2><p>该垃圾收集器就是多线程版本的Serial，原来Serial的GC线程为单线程，ParNew为多线程GC，缩短了STW的时间。</p><p>这边我们需要知道ParNew只是一个新生代的垃圾收集器，采用的是复制算法，所以他是一个新生代的垃圾收集器。他可以搭配其他的老年代垃圾收集器进行使用，比如Serial Old，CMS等</p><p><strong><em>Q1:ParNew是否一定比Serial好？</em></strong><br>不一定。如果是单核CPU，Serial单线程的效率更高，因为只有一个核同一时刻只能跑一个线程，多线程带来的损耗主要是频繁切换CPU上下文，只有在CPU核多的情况下，ParNew的优势才会得到体现。</p><hr><h2 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h2><p>该垃圾收集器也是新生代的，采用的依然是复制算法，相比于ParNew，该GC有控制吞吐量和最大垃圾收集停顿时间（STW）的功能。</p><p>吞吐量 = 运行代码的时间 / (运行代码的时间+GC时间)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-xx:MaxGCPauseMills #最大垃圾收集停顿时间参数</span><br><span class="line">-xx:GCTimeRatio #控制吞吐量大小</span><br></pre></td></tr></table></figure><p>这里我们如果吧STW时间调小了，其实就是调小了新生代，这样每次收集的垃圾就会变少，GC的频次相对的也就上去了，吞吐量就下来了。我们需要找到一个合适的平衡来进行这两个参数的调优。</p><p>该垃圾收集器还有一个比较只能的地方就是他有GC自适应的调节策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-xx:UseAdaptiveSizePolicy #GC自适应的调节策略</span><br></pre></td></tr></table></figure><p>即根据系统的运行情况动态去调整新生代大小，Eden区和Survivor区的比例，以及晋升老年代的对象等细节参数，达到一个最合适的停顿时间和吞吐量。</p><hr><h2 id="Parallel-Old"><a href="#Parallel-Old" class="headerlink" title="Parallel Old"></a>Parallel Old</h2><p>该收集器是采用多线程和标记整理算法的老年代垃圾收集器。</p><p>黄金组合：<br>Parallel Scavenge + Parallel Old</p><p>在注重吞吐量以及CPU资源敏感的情况可以考虑使用该组合</p><hr><blockquote><p>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM垃圾回收机制</title>
      <link href="/p/18011a7d.html"/>
      <url>/p/18011a7d.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在B站上学习<a href="https://www.bilibili.com/video/BV13T4y1N7oE" target="_blank" rel="noopener">子烁老师的垃圾回收机制篇</a>，讲的很清晰，这里根据自己理解写下笔记加深下印象。</p><p>下面主要以垃圾回收基础知识、回收算法、分代回收策略、经典垃圾收集器四个方面展开。</p><hr><h2 id="垃圾回收基础"><a href="#垃圾回收基础" class="headerlink" title="垃圾回收基础"></a>垃圾回收基础</h2><h3 id="主要回收的垃圾是什么"><a href="#主要回收的垃圾是什么" class="headerlink" title="主要回收的垃圾是什么"></a>主要回收的垃圾是什么</h3><p>首先我们要搞清楚我们主要回收的垃圾是什么，这边我们需要了解Java虚拟机内内存是怎么分布的，这些内存分别存储了什么东西，下图是JVM的内存模型：</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-01-19/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png" alt="JVM内存模型"></p><p><font color = "red">红色框</font>：代表的是线程私有的内存，这些内存随着线程的创建而创建，销毁而销毁。<br><font color = "blue">蓝色框</font>：代表的是线程共享的内存。</p><p><strong>方法区：</strong>主要存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。方法区主要回收的是废弃的常量和无用类。</p><p><strong>堆内存：</strong>就是存放对象实例，几乎所有的对象实例都在这里分配内存。主要回收无用的对象。</p><p>了解了上述这些之后我们知道，垃圾回收的主要区域在堆中。</p><hr><h3 id="垃圾何时被回收"><a href="#垃圾何时被回收" class="headerlink" title="垃圾何时被回收"></a>垃圾何时被回收</h3><p>当一个对象不再被引用了，也就是这个对象在内存中没有人用它的时候，这时候可以被回收。</p><p>这边引入一个概念，Java中的引用分为四类：</p><ol><li>强引用：如果一个对象具有强引用，它就不会被垃圾回收器回收。即使当前内存空间不足，JVM也不会回收它，而是抛出 OutOfMemoryError 错误，使程序异常终止。如果想中断强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样一来的话，JVM在合适的时间就会回收该对象。强引用的创建最为常见一般<code>Object object = new Object();</code>就是强引用。</li><li>软引用：如果内存的空间足够，软引用就能继续被使用，而不会被垃圾回收器回收，只有在内存不足时，软引用才会被垃圾回收器回收。</li><li>弱引用：只要发生GC就会回收。</li><li>虚引用：在垃圾被回收时候可以接收一个通知</li></ol><hr><h3 id="判断垃圾是否可被回收"><a href="#判断垃圾是否可被回收" class="headerlink" title="判断垃圾是否可被回收"></a>判断垃圾是否可被回收</h3><p>判断一个垃圾是否被回收，那么我们就要确定他是否还有用。如何确定是否还有用呢，就是没有任何引用该对象，就说明这个对象是垃圾了，可以被回收。一般判断是否可以被回收，有两种算法：分别是<strong><em>引用计数法</em></strong>和<strong><em>可达性分析算法</em></strong></p><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>引用计数法是通过引用计数器来判断对象是否存在引用，当有地方引用该对象时该对象的引用计数器就会加1，当引用失效就会减1。通过判断该对象的引用计数器是否为0来确定是否可被回收。如下图：<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-01-19/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8.png" alt="引用计数器"></p><p>但是我们仔细想想引用计数器他是存在问题的，如果两个无用的对象都引用了对方，那么他们的引用计数都为1，但却是垃圾对象。用了这个算法，GC永远无法回收下图中的A、B对象。<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-01-19/%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%99%A8-%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.png" alt="引用计数-循环引用"></p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>该算法为主流GC发现垃圾对象的算法，它通过GC ROOT的对象作为搜索起始点，通过引用向下搜索，所走过的路径称为引用链。通过对象是否有到达引用链的路径来判断对象是否可被回收。<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-01-19/%E5%8F%AF%E8%BE%BE%E6%80%A7%E7%AE%97%E6%B3%95.png" alt="可达性分析算法"></p><p>如上图所示，Object1–Object4对GC Root都是可达的，说明不可被回收，Object5–Object7对GC Root节点不可达，说明其可以被回收。</p><p>在Java中可以被作为GC Root对象的主要是下面四种：</p><ol><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ol><blockquote><p>即使在可达性分析算法中不可达的对象，非回收不可，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。<br>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链。<br><strong><em>第一次标记并进行一次筛选:</em></strong><br>筛选的条件是此对象是否有必要执行finalize()方法。<br>当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为没有必要执行，对象被回收。<br><strong><em>第二次标记:</em></strong><br>如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为：F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的执行是指虚拟机会触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。<br>Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize（）中成功拯救自己—-只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。<br><a href="https://www.jianshu.com/p/8f5fa8288d9b" target="_blank" rel="noopener">原文链接</a></p></blockquote><hr><h2 id="回收算法"><a href="#回收算法" class="headerlink" title="回收算法"></a>回收算法</h2><p>由于JDK对垃圾收集器并没有制定规范，所以各个厂商都采用不同的方式来实现垃圾收集器，下面介绍四种主流的垃圾回收算法。</p><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>该算法是最基础的收集算法。算法分为标记和清除两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象(标记过程主要是上述的可达性分析算法)。后续的收集算法都是基于这种思路并对其不足加以改进而已。</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-01-19/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4.png" alt="标记-清除算法"></p><p><strong>严重问题：</strong><br>通过该算法回收的内存，会产生大量的内存碎片，由上图就很好理解，存活对象并不是在一块的，由此产生一块块分散的未使用内存空间，会导致无法申请一个<font color = "red">比较大</font>的<font color = "red">连续</font>的内存空间。</p><hr><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>该算法是为了解决<code>标记-清除</code>的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当这块内存需要进行垃圾回收时，会将此区域还存活着的对象复制到另一块上面，然后再把已经使用过的内存区域一次清理掉。这样做的好处是每次都是对整个半区进行内存回收，内存分配时也就不需要考虑内存碎片等的复杂情况，只需要移动堆顶指针，按顺序分配即可。该算法逻辑清晰，也运行高效。</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-01-19/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" alt="复制算法"></p><p><strong>严重问题：</strong><br>该算法必须把内存拆分为两半，意味着原本只需要10G的内存就能跑的程序，现在需要20G内存。需要的内存是原来的<font color = "red">两倍</font></p><hr><h3 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h3><p>由于复制收集算法在对象存活率较高时会进行比较多的复制操作，效率会变低。因此在存活率较高的老年代一般不能使用复制算法。</p><p>针对老年代的特点，提出了一种称之为<code>标记-整理算法</code>。标记过程仍与<code>标记-清除</code>过程一致，但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-01-19/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86.png" alt="标记-整理算法"></p><p><strong>严重问题：</strong><br>该算法存在<font color = "red">效率</font>的问题，内存变动更加频繁，每次都需要整理所有存活对象的引用地址。</p><hr><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>这个算法没有新创意,只是上面三种算法的一套组合拳一般是把Java堆分为<font color = "red">新生代</font>和<font color = "red">老年代</font>。</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-01-19/Heap.png" alt="Heap"></p><p>在新生代中，每次垃圾回收都有大批对象死去，只有少量存活，因此我们采用<code>复制算法</code>；而老年代中对象存活率高、没有额外空间对它进行分配担保，就必须采用<code>标记-清除</code>或者<code>标记-整理</code>算法。</p><hr><h2 id="分代回收策略"><a href="#分代回收策略" class="headerlink" title="分代回收策略"></a>分代回收策略</h2><p>当前JVM垃圾收集都采用的是<code>分代收集(Generational Collection)</code>算法，在Java堆中新生代默认是占堆的1/3，而老年代默认占堆的2/3</p><h3 id="新生代回收"><a href="#新生代回收" class="headerlink" title="新生代回收"></a>新生代回收</h3><p>所有新的对象基本都在Eden区中生成，等到Eden区被填满的时候就触发<font color = "red">Minor GC</font>，在Eden区中对象的存活率低，于是采用复制算法，将Eden区中存活对象复制到任意一个Survivor区中，再将Eden区清空，就完成了一次<font color = "red">Minor GC</font>。具体如下图：</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-01-19/Minor%20GC1.png" alt="MinorGC1"></p><p>当Eden区再次被填满的时候，需要在进行一次<font color = "red">Minor GC</font>，但是之前的Survivor区中的对象不一定都是存活的，也会有一些垃圾对象，他也会在这次<font color = "red">Minor GC</font>中被清除。依旧采用的是复制算法，将Eden区和一个Survivor区中的存活对象复制到另一个Survivor区钟，在对另外两个区进行清除。</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-01-19/Minor%20GC2.png" alt="MinorGC2"></p><p>接下来的每次<font color = "red">Minor GC</font>都和上面的流程一样，每次都需要清扫一个Eden区和一个Survivor区。</p><p><strong><em>Q1:对象什么时候从新生代进入老年代？</em></strong><br>新生代的每一次Minor GC都会使存活对象的年龄加1，也就是存活对象的复制次数。当年龄到达一个阈值的时候，该对象就会被放入老年代，这个阈值默认是15。</p><p><strong><em>Q2:进入老年代的方式有哪些？</em></strong><br>1.如果Minnor GC的存活对象比Survivor区大，那么这些对象会过早老化，直接进入老年带<br>2.经历15次Minor GC的对象<br>3.大数组，大字符串等会直接在老年代中进行创建。</p><p><strong><em>Q3:分代年龄可否设置成31？</em></strong><br>因为分代年龄在对象中占4位，4位二进制最大是15，因此不能设置成31。</p><hr><h3 id="老年代回收"><a href="#老年代回收" class="headerlink" title="老年代回收"></a>老年代回收</h3><p>由于老年代的GC频率较低，通常使用<code>标记-整理</code>算法来进行回收，老年代的回收又称为<font color = "red">Major GC</font>。</p><hr><blockquote><p>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown引入Echarts</title>
      <link href="/p/93bb270a.html"/>
      <url>/p/93bb270a.html</url>
      
        <content type="html"><![CDATA[<div id="map-wrap" style="height: 500px;width:800px;"></div><script type="text/javascript" src="/js/src/echarts.min.js"></script><script type="text/javascript">var myChart = echarts.init(document.getElementById('map-wrap'));var dataMap = {};function dataFormatter(obj) {    var pList = ['北京','天津','河北','山西','内蒙古','辽宁','吉林','黑龙江','上海','江苏','浙江','安徽','福建','江西','山东','河南','湖北','湖南','广东','广西','海南','重庆','四川','贵州','云南','西藏','陕西','甘肃','青海','宁夏','新疆'];    var temp;    for (var year = 2002; year <= 2011; year++) {        var max = 0;        var sum = 0;        temp = obj[year];        for (var i = 0, l = temp.length; i < l; i++) {            max = Math.max(max, temp[i]);            sum += temp[i];            obj[year][i] = {                name: pList[i],                value: temp[i]            };        }        obj[year + 'max'] = Math.floor(max / 100) * 100;        obj[year + 'sum'] = sum;    }    return obj;}dataMap.dataGDP = dataFormatter({    //max : 60000,    2011:[16251.93,11307.28,24515.76,11237.55,14359.88,22226.7,10568.83,12582,19195.69,49110.27,32318.85,15300.65,17560.18,11702.82,45361.85,26931.03,19632.26,19669.56,53210.28,11720.87,2522.66,10011.37,21026.68,5701.84,8893.12,605.83,12512.3,5020.37,1670.44,2102.21,6610.05],    2010:[14113.58,9224.46,20394.26,9200.86,11672,18457.27,8667.58,10368.6,17165.98,41425.48,27722.31,12359.33,14737.12,9451.26,39169.92,23092.36,15967.61,16037.96,46013.06,9569.85,2064.5,7925.58,17185.48,4602.16,7224.18,507.46,10123.48,4120.75,1350.43,1689.65,5437.47],    2009:[12153.03,7521.85,17235.48,7358.31,9740.25,15212.49,7278.75,8587,15046.45,34457.3,22990.35,10062.82,12236.53,7655.18,33896.65,19480.46,12961.1,13059.69,39482.56,7759.16,1654.21,6530.01,14151.28,3912.68,6169.75,441.36,8169.8,3387.56,1081.27,1353.31,4277.05],    2008:[11115,6719.01,16011.97,7315.4,8496.2,13668.58,6426.1,8314.37,14069.87,30981.98,21462.69,8851.66,10823.01,6971.05,30933.28,18018.53,11328.92,11555,36796.71,7021,1503.06,5793.66,12601.23,3561.56,5692.12,394.85,7314.58,3166.82,1018.62,1203.92,4183.21],    2007:[9846.81,5252.76,13607.32,6024.45,6423.18,11164.3,5284.69,7104,12494.01,26018.48,18753.73,7360.92,9248.53,5800.25,25776.91,15012.46,9333.4,9439.6,31777.01,5823.41,1254.17,4676.13,10562.39,2884.11,4772.52,341.43,5757.29,2703.98,797.35,919.11,3523.16],    2006:[8117.78,4462.74,11467.6,4878.61,4944.25,9304.52,4275.12,6211.8,10572.24,21742.05,15718.47,6112.5,7583.85,4820.53,21900.19,12362.79,7617.47,7688.67,26587.76,4746.16,1065.67,3907.23,8690.24,2338.98,3988.14,290.76,4743.61,2277.35,648.5,725.9,3045.26],    2005:[6969.52,3905.64,10012.11,4230.53,3905.03,8047.26,3620.27,5513.7,9247.66,18598.69,13417.68,5350.17,6554.69,4056.76,18366.87,10587.42,6590.19,6596.1,22557.37,3984.1,918.75,3467.72,7385.1,2005.42,3462.73,248.8,3933.72,1933.98,543.32,612.61,2604.19],    2004:[6033.21,3110.97,8477.63,3571.37,3041.07,6672,3122.01,4750.6,8072.83,15003.6,11648.7,4759.3,5763.35,3456.7,15021.84,8553.79,5633.24,5641.94,18864.62,3433.5,819.66,3034.58,6379.63,1677.8,3081.91,220.34,3175.58,1688.49,466.1,537.11,2209.09],    2003:[5007.21,2578.03,6921.29,2855.23,2388.38,6002.54,2662.08,4057.4,6694.23,12442.87,9705.02,3923.11,4983.67,2807.41,12078.15,6867.7,4757.45,4659.99,15844.64,2821.11,713.96,2555.72,5333.09,1426.34,2556.02,185.09,2587.72,1399.83,390.2,445.36,1886.35],    2002:[4315,2150.76,6018.28,2324.8,1940.94,5458.22,2348.54,3637.2,5741.03,10606.85,8003.67,3519.72,4467.55,2450.48,10275.5,6035.48,4212.82,4151.54,13502.42,2523.73,642.73,2232.86,4725.01,1243.43,2312.82,162.04,2253.39,1232.03,340.65,377.16,1612.6]});dataMap.dataPI = dataFormatter({    //max : 4000,    2011:[136.27,159.72,2905.73,641.42,1306.3,1915.57,1277.44,1701.5,124.94,3064.78,1583.04,2015.31,1612.24,1391.07,3973.85,3512.24,2569.3,2768.03,2665.2,2047.23,659.23,844.52,2983.51,726.22,1411.01,74.47,1220.9,678.75,155.08,184.14,1139.03],    2010:[124.36,145.58,2562.81,554.48,1095.28,1631.08,1050.15,1302.9,114.15,2540.1,1360.56,1729.02,1363.67,1206.98,3588.28,3258.09,2147,2325.5,2286.98,1675.06,539.83,685.38,2482.89,625.03,1108.38,68.72,988.45,599.28,134.92,159.29,1078.63],    2009:[118.29,128.85,2207.34,477.59,929.6,1414.9,980.57,1154.33,113.82,2261.86,1163.08,1495.45,1182.74,1098.66,3226.64,2769.05,1795.9,1969.69,2010.27,1458.49,462.19,606.8,2240.61,550.27,1067.6,63.88,789.64,497.05,107.4,127.25,759.74],    2008:[112.83,122.58,2034.59,313.58,907.95,1302.02,916.72,1088.94,111.8,2100.11,1095.96,1418.09,1158.17,1060.38,3002.65,2658.78,1780,1892.4,1973.05,1453.75,436.04,575.4,2216.15,539.19,1020.56,60.62,753.72,462.27,105.57,118.94,691.07],    2007:[101.26,110.19,1804.72,311.97,762.1,1133.42,783.8,915.38,101.84,1816.31,986.02,1200.18,1002.11,905.77,2509.14,2217.66,1378,1626.48,1695.57,1241.35,361.07,482.39,2032,446.38,837.35,54.89,592.63,387.55,83.41,97.89,628.72],    2006:[88.8,103.35,1461.81,276.77,634.94,939.43,672.76,750.14,93.81,1545.05,925.1,1011.03,865.98,786.14,2138.9,1916.74,1140.41,1272.2,1532.17,1032.47,323.48,386.38,1595.48,382.06,724.4,50.9,484.81,334,67.55,79.54,527.8],    2005:[88.68,112.38,1400,262.42,589.56,882.41,625.61,684.6,90.26,1461.51,892.83,966.5,827.36,727.37,1963.51,1892.01,1082.13,1100.65,1428.27,912.5,300.75,463.4,1481.14,368.94,661.69,48.04,435.77,308.06,65.34,72.07,509.99],    2004:[87.36,105.28,1370.43,276.3,522.8,798.43,568.69,605.79,83.45,1367.58,814.1,950.5,786.84,664.5,1778.45,1649.29,1020.09,1022.45,1248.59,817.88,278.76,428.05,1379.93,334.5,607.75,44.3,387.88,286.78,60.7,65.33,461.26],    2003:[84.11,89.91,1064.05,215.19,420.1,615.8,488.23,504.8,81.02,1162.45,717.85,749.4,692.94,560,1480.67,1198.7,798.35,886.47,1072.91,658.78,244.29,339.06,1128.61,298.69,494.6,40.7,302.66,237.91,48.47,55.63,412.9],    2002:[82.44,84.21,956.84,197.8,374.69,590.2,446.17,474.2,79.68,1110.44,685.2,783.66,664.78,535.98,1390,1288.36,707,847.25,1015.08,601.99,222.89,317.87,1047.95,281.1,463.44,39.75,282.21,215.51,47.31,52.95,305]});dataMap.dataSI = dataFormatter({    //max : 26600,    2011:[3752.48,5928.32,13126.86,6635.26,8037.69,12152.15,5611.48,5962.41,7927.89,25203.28,16555.58,8309.38,9069.2,6390.55,24017.11,15427.08,9815.94,9361.99,26447.38,5675.32,714.5,5543.04,11029.13,2194.33,3780.32,208.79,6935.59,2377.83,975.18,1056.15,3225.9],    2010:[3388.38,4840.23,10707.68,5234,6367.69,9976.82,4506.31,5025.15,7218.32,21753.93,14297.93,6436.62,7522.83,5122.88,21238.49,13226.38,7767.24,7343.19,23014.53,4511.68,571,4359.12,8672.18,1800.06,3223.49,163.92,5446.1,1984.97,744.63,827.91,2592.15],    2009:[2855.55,3987.84,8959.83,3993.8,5114,7906.34,3541.92,4060.72,6001.78,18566.37,11908.49,4905.22,6005.3,3919.45,18901.83,11010.5,6038.08,5687.19,19419.7,3381.54,443.43,3448.77,6711.87,1476.62,2582.53,136.63,4236.42,1527.24,575.33,662.32,1929.59],    2008:[2626.41,3709.78,8701.34,4242.36,4376.19,7158.84,3097.12,4319.75,6085.84,16993.34,11567.42,4198.93,5318.44,3554.81,17571.98,10259.99,5082.07,5028.93,18502.2,3037.74,423.55,3057.78,5823.39,1370.03,2452.75,115.56,3861.12,1470.34,557.12,609.98,2070.76],    2007:[2509.4,2892.53,7201.88,3454.49,3193.67,5544.14,2475.45,3695.58,5571.06,14471.26,10154.25,3370.96,4476.42,2975.53,14647.53,8282.83,4143.06,3977.72,16004.61,2425.29,364.26,2368.53,4648.79,1124.79,2038.39,98.48,2986.46,1279.32,419.03,455.04,1647.55],    2006:[2191.43,2457.08,6110.43,2755.66,2374.96,4566.83,1915.29,3365.31,4969.95,12282.89,8511.51,2711.18,3695.04,2419.74,12574.03,6724.61,3365.08,3187.05,13469.77,1878.56,308.62,1871.65,3775.14,967.54,1705.83,80.1,2452.44,1043.19,331.91,351.58,1459.3],    2005:[2026.51,2135.07,5271.57,2357.04,1773.21,3869.4,1580.83,2971.68,4381.2,10524.96,7164.75,2245.9,3175.92,1917.47,10478.62,5514.14,2852.12,2612.57,11356.6,1510.68,240.83,1564,3067.23,821.16,1426.42,63.52,1951.36,838.56,264.61,281.05,1164.79],    2004:[1853.58,1685.93,4301.73,1919.4,1248.27,3061.62,1329.68,2487.04,3892.12,8437.99,6250.38,1844.9,2770.49,1566.4,8478.69,4182.1,2320.6,2190.54,9280.73,1253.7,205.6,1376.91,2489.4,681.5,1281.63,52.74,1553.1,713.3,211.7,244.05,914.47],    2003:[1487.15,1337.31,3417.56,1463.38,967.49,2898.89,1098.37,2084.7,3209.02,6787.11,5096.38,1535.29,2340.82,1204.33,6485.05,3310.14,1956.02,1777.74,7592.78,984.08,175.82,1135.31,2014.8,569.37,1047.66,47.64,1221.17,572.02,171.92,194.27,719.54],    2002:[1249.99,1069.08,2911.69,1134.31,754.78,2609.85,943.49,1843.6,2622.45,5604.49,4090.48,1337.04,2036.97,941.77,5184.98,2768.75,1709.89,1523.5,6143.4,846.89,148.88,958.87,1733.38,481.96,934.88,32.72,1007.56,501.69,144.51,153.06,603.15]});dataMap.dataTI = dataFormatter({    //max : 25000,    2011:[12363.18,5219.24,8483.17,3960.87,5015.89,8158.98,3679.91,4918.09,11142.86,20842.21,14180.23,4975.96,6878.74,3921.2,17370.89,7991.72,7247.02,7539.54,24097.7,3998.33,1148.93,3623.81,7014.04,2781.29,3701.79,322.57,4355.81,1963.79,540.18,861.92,2245.12],    2010:[10600.84,4238.65,7123.77,3412.38,4209.03,6849.37,3111.12,4040.55,9833.51,17131.45,12063.82,4193.69,5850.62,3121.4,14343.14,6607.89,6053.37,6369.27,20711.55,3383.11,953.67,2881.08,6030.41,2177.07,2892.31,274.82,3688.93,1536.5,470.88,702.45,1766.69],    2009:[9179.19,3405.16,6068.31,2886.92,3696.65,5891.25,2756.26,3371.95,8930.85,13629.07,9918.78,3662.15,5048.49,2637.07,11768.18,5700.91,5127.12,5402.81,18052.59,2919.13,748.59,2474.44,5198.8,1885.79,2519.62,240.85,3143.74,1363.27,398.54,563.74,1587.72],    2008:[8375.76,2886.65,5276.04,2759.46,3212.06,5207.72,2412.26,2905.68,7872.23,11888.53,8799.31,3234.64,4346.4,2355.86,10358.64,5099.76,4466.85,4633.67,16321.46,2529.51,643.47,2160.48,4561.69,1652.34,2218.81,218.67,2699.74,1234.21,355.93,475,1421.38],    2007:[7236.15,2250.04,4600.72,2257.99,2467.41,4486.74,2025.44,2493.04,6821.11,9730.91,7613.46,2789.78,3770,1918.95,8620.24,4511.97,3812.34,3835.4,14076.83,2156.76,528.84,1825.21,3881.6,1312.94,1896.78,188.06,2178.2,1037.11,294.91,366.18,1246.89],    2006:[5837.55,1902.31,3895.36,1846.18,1934.35,3798.26,1687.07,2096.35,5508.48,7914.11,6281.86,2390.29,3022.83,1614.65,7187.26,3721.44,3111.98,3229.42,11585.82,1835.12,433.57,1649.2,3319.62,989.38,1557.91,159.76,1806.36,900.16,249.04,294.78,1058.16],    2005:[4854.33,1658.19,3340.54,1611.07,1542.26,3295.45,1413.83,1857.42,4776.2,6612.22,5360.1,2137.77,2551.41,1411.92,5924.74,3181.27,2655.94,2882.88,9772.5,1560.92,377.17,1440.32,2836.73,815.32,1374.62,137.24,1546.59,787.36,213.37,259.49,929.41],    2004:[4092.27,1319.76,2805.47,1375.67,1270,2811.95,1223.64,1657.77,4097.26,5198.03,4584.22,1963.9,2206.02,1225.8,4764.7,2722.4,2292.55,2428.95,8335.3,1361.92,335.3,1229.62,2510.3,661.8,1192.53,123.3,1234.6,688.41,193.7,227.73,833.36],    2003:[3435.95,1150.81,2439.68,1176.65,1000.79,2487.85,1075.48,1467.9,3404.19,4493.31,3890.79,1638.42,1949.91,1043.08,4112.43,2358.86,2003.08,1995.78,7178.94,1178.25,293.85,1081.35,2189.68,558.28,1013.76,96.76,1063.89,589.91,169.81,195.46,753.91],    2002:[2982.57,997.47,2149.75,992.69,811.47,2258.17,958.88,1319.4,3038.9,3891.92,3227.99,1399.02,1765.8,972.73,3700.52,1978.37,1795.93,1780.79,6343.94,1074.85,270.96,956.12,1943.68,480.37,914.5,89.56,963.62,514.83,148.83,171.14,704.5]});dataMap.dataEstate = dataFormatter({    //max : 3600,    2011:[1074.93,411.46,918.02,224.91,384.76,876.12,238.61,492.1,1019.68,2747.89,1677.13,634.92,911.16,402.51,1838.14,987,634.67,518.04,3321.31,465.68,208.71,396.28,620.62,160.3,222.31,17.44,398.03,134.25,29.05,79.01,176.22],    2010:[1006.52,377.59,697.79,192,309.25,733.37,212.32,391.89,1002.5,2600.95,1618.17,532.17,679.03,340.56,1622.15,773.23,564.41,464.21,2813.95,405.79,188.33,266.38,558.56,139.64,223.45,14.54,315.95,110.02,25.41,60.53,143.44],    2009:[1062.47,308.73,612.4,173.31,286.65,605.27,200.14,301.18,1237.56,2025.39,1316.84,497.94,656.61,305.9,1329.59,622.98,546.11,400.11,2470.63,348.98,121.76,229.09,548.14,136.15,205.14,13.28,239.92,101.37,23.05,47.56,115.23],    2008:[844.59,227.88,513.81,166.04,273.3,500.81,182.7,244.47,939.34,1626.13,1052.03,431.27,506.98,281.96,1104.95,512.42,526.88,340.07,2057.45,282.96,95.6,191.21,453.63,104.81,195.48,15.08,193.27,93.8,19.96,38.85,89.79],    2007:[821.5,183.44,467.97,134.12,191.01,410.43,153.03,225.81,958.06,1365.71,981.42,366.57,511.5,225.96,953.69,447.44,409.65,301.8,2029.77,239.45,67.19,196.06,376.84,93.19,193.59,13.24,153.98,83.52,16.98,29.49,91.28],    2006:[658.3,156.64,397.14,117.01,136.5,318.54,131.01,194.7,773.61,1017.91,794.41,281.98,435.22,184.67,786.51,348.7,294.73,254.81,1722.07,192.2,44.45,158.2,336.2,80.24,165.92,11.92,125.2,73.21,15.17,25.53,68.9],    2005:[493.73,122.67,330.87,106,98.75,256.77,112.29,163.34,715.97,799.73,688.86,231.66,331.8,171.88,664.9,298.19,217.17,215.63,1430.37,165.05,38.2,143.88,286.23,76.38,148.69,10.02,108.62,63.78,14.1,22.97,55.79],    2004:[436.11,106.14,231.08,95.1,73.81,203.1,97.93,137.74,666.3,534.17,587.83,188.28,248.44,167.2,473.27,236.44,204.8,191.5,1103.75,122.52,30.64,129.12,264.3,68.3,116.54,5.8,95.9,56.84,13,20.78,53.55],    2003:[341.88,92.31,185.19,78.73,61.05,188.49,91.99,127.2,487.82,447.47,473.16,162.63,215.84,138.02,418.21,217.58,176.8,186.49,955.66,100.93,25.14,113.69,231.72,59.86,103.79,4.35,83.9,48.09,11.41,16.85,47.84],    2002:[298.02,73.04,140.89,65.83,51.48,130.94,76.11,118.7,384.86,371.09,360.63,139.18,188.09,125.27,371.13,199.31,145.17,165.29,808.16,82.83,21.45,90.48,210.82,53.49,95.68,3.42,77.68,41.52,9.74,13.46,43.04]});dataMap.dataFinancial = dataFormatter({    //max : 3200,    2011:[2215.41,756.5,746.01,519.32,447.46,755.57,207.65,370.78,2277.4,2600.11,2730.29,503.85,862.41,357.44,1640.41,868.2,674.57,501.09,2916.13,445.37,105.24,704.66,868.15,297.27,456.23,31.7,432.11,145.05,62.56,134.18,288.77],    2010:[1863.61,572.99,615.42,448.3,346.44,639.27,190.12,304.59,1950.96,2105.92,2326.58,396.17,767.58,241.49,1361.45,697.68,561.27,463.16,2658.76,384.53,78.12,496.56,654.7,231.51,375.08,27.08,384.75,100.54,54.53,97.87,225.2],    2009:[1603.63,461.2,525.67,361.64,291.1,560.2,180.83,227.54,1804.28,1596.98,1899.33,359.6,612.2,165.1,1044.9,499.92,479.11,402.57,2283.29,336.82,65.73,389.97,524.63,194.44,351.74,23.17,336.21,88.27,45.63,75.54,198.87],    2008:[1519.19,368.1,420.74,290.91,219.09,455.07,147.24,177.43,1414.21,1298.48,1653.45,313.81,497.65,130.57,880.28,413.83,393.05,334.32,1972.4,249.01,47.33,303.01,411.14,151.55,277.66,22.42,287.16,72.49,36.54,64.8,171.97],    2007:[1302.77,288.17,347.65,218.73,148.3,386.34,126.03,155.48,1209.08,1054.25,1251.43,223.85,385.84,101.34,734.9,302.31,337.27,260.14,1705.08,190.73,34.43,247.46,359.11,122.25,168.55,11.51,231.03,61.6,27.67,51.05,149.22],    2006:[982.37,186.87,284.04,169.63,108.21,303.41,100.75,74.17,825.2,653.25,906.37,166.01,243.9,79.75,524.94,219.72,174.99,204.72,899.91,129.14,16.37,213.7,299.5,89.43,143.62,6.44,152.25,50.51,23.69,36.99,99.25],    2005:[840.2,147.4,213.47,135.07,72.52,232.85,83.63,35.03,675.12,492.4,686.32,127.05,186.12,69.55,448.36,181.74,127.32,162.37,661.81,91.93,13.16,185.18,262.26,73.67,130.5,7.57,127.58,44.73,20.36,32.25,80.34],    2004:[713.79,136.97,209.1,110.29,55.89,188.04,77.17,32.2,612.45,440.5,523.49,94.1,171,65.1,343.37,170.82,118.85,118.64,602.68,74,11.56,162.38,236.5,60.3,118.4,5.4,90.1,42.99,19,27.92,70.3],    2003:[635.56,112.79,199.87,118.48,55.89,145.38,73.15,32.2,517.97,392.11,451.54,87.45,150.09,64.31,329.71,165.11,107.31,99.35,534.28,61.59,10.68,147.04,206.24,48.01,105.48,4.74,77.87,42.31,17.98,24.8,64.92],    2002:[561.91,76.86,179.6,124.1,48.39,137.18,75.45,31.6,485.25,368.86,347.53,81.85,138.28,76.51,310.07,158.77,96.95,92.43,454.65,35.86,10.08,134.52,183.13,41.45,102.39,2.81,67.3,42.08,16.75,21.45,52.18]});option = {    baseOption: {        timeline: {            axisType: 'category',            // realtime: false,            // loop: false,            autoPlay: true,            // currentIndex: 2,            playInterval: 1000,            // controlStyle: {            //     position: 'left'            // },            data: [                '2002-01-01','2003-01-01','2004-01-01',                {                    value: '2005-01-01',                    tooltip: {                        formatter: '{b} GDP达到一个高度'                    },                    symbol: 'diamond',                    symbolSize: 16                },                '2006-01-01', '2007-01-01','2008-01-01','2009-01-01','2010-01-01',                {                    value: '2011-01-01',                    tooltip: {                        formatter: function (params) {                            return params.name + 'GDP达到又一个高度';                        }                    },                    symbol: 'diamond',                    symbolSize: 18                },            ],            label: {                formatter : function(s) {                    return (new Date(s)).getFullYear();                }            }        },        title: {            subtext: '数据来自国家统计局'        },        tooltip: {        },        legend: {            left: 'right',            data: ['第一产业', '第二产业', '第三产业', 'GDP', '金融', '房地产'],            selected: {                'GDP': false, '金融': false, '房地产': false            }        },        calculable : true,        grid: {            top: 80,            bottom: 100,            tooltip: {                trigger: 'axis',                axisPointer: {                    type: 'shadow',                    label: {                        show: true,                        formatter: function (params) {                            return params.value.replace('\n', '');                        }                    }                }            }        },        xAxis: [            {                'type':'category',                'axisLabel':{'interval':0},                'data':[                    '北京','\n天津','河北','\n山西','内蒙古','\n辽宁','吉林','\n黑龙江',                    '上海','\n江苏','浙江','\n安徽','福建','\n江西','山东','\n河南',                    '湖北','\n湖南','广东','\n广西','海南','\n重庆','四川','\n贵州',                    '云南','\n西藏','陕西','\n甘肃','青海','\n宁夏','新疆'                ],                splitLine: {show: false}            }        ],        yAxis: [            {                type: 'value',                name: 'GDP（亿元）'            }        ],        series: [            {name: 'GDP', type: 'bar'},            {name: '金融', type: 'bar'},            {name: '房地产', type: 'bar'},            {name: '第一产业', type: 'bar'},            {name: '第二产业', type: 'bar'},            {name: '第三产业', type: 'bar'},            {                name: 'GDP占比',                type: 'pie',                center: ['75%', '35%'],                radius: '28%',                z: 100            }        ]    },    options: [        {            title: {text: '2002全国宏观经济指标'},            series: [                {data: dataMap.dataGDP['2002']},                {data: dataMap.dataFinancial['2002']},                {data: dataMap.dataEstate['2002']},                {data: dataMap.dataPI['2002']},                {data: dataMap.dataSI['2002']},                {data: dataMap.dataTI['2002']},                {data: [                    {name: '第一产业', value: dataMap.dataPI['2002sum']},                    {name: '第二产业', value: dataMap.dataSI['2002sum']},                    {name: '第三产业', value: dataMap.dataTI['2002sum']}                ]}            ]        },        {            title : {text: '2003全国宏观经济指标'},            series : [                {data: dataMap.dataGDP['2003']},                {data: dataMap.dataFinancial['2003']},                {data: dataMap.dataEstate['2003']},                {data: dataMap.dataPI['2003']},                {data: dataMap.dataSI['2003']},                {data: dataMap.dataTI['2003']},                {data: [                    {name: '第一产业', value: dataMap.dataPI['2003sum']},                    {name: '第二产业', value: dataMap.dataSI['2003sum']},                    {name: '第三产业', value: dataMap.dataTI['2003sum']}                ]}            ]        },        {            title : {text: '2004全国宏观经济指标'},            series : [                {data: dataMap.dataGDP['2004']},                {data: dataMap.dataFinancial['2004']},                {data: dataMap.dataEstate['2004']},                {data: dataMap.dataPI['2004']},                {data: dataMap.dataSI['2004']},                {data: dataMap.dataTI['2004']},                {data: [                    {name: '第一产业', value: dataMap.dataPI['2004sum']},                    {name: '第二产业', value: dataMap.dataSI['2004sum']},                    {name: '第三产业', value: dataMap.dataTI['2004sum']}                ]}            ]        },        {            title : {text: '2005全国宏观经济指标'},            series : [                {data: dataMap.dataGDP['2005']},                {data: dataMap.dataFinancial['2005']},                {data: dataMap.dataEstate['2005']},                {data: dataMap.dataPI['2005']},                {data: dataMap.dataSI['2005']},                {data: dataMap.dataTI['2005']},                {data: [                    {name: '第一产业', value: dataMap.dataPI['2005sum']},                    {name: '第二产业', value: dataMap.dataSI['2005sum']},                    {name: '第三产业', value: dataMap.dataTI['2005sum']}                ]}            ]        },        {            title : {text: '2006全国宏观经济指标'},            series : [                {data: dataMap.dataGDP['2006']},                {data: dataMap.dataFinancial['2006']},                {data: dataMap.dataEstate['2006']},                {data: dataMap.dataPI['2006']},                {data: dataMap.dataSI['2006']},                {data: dataMap.dataTI['2006']},                {data: [                    {name: '第一产业', value: dataMap.dataPI['2006sum']},                    {name: '第二产业', value: dataMap.dataSI['2006sum']},                    {name: '第三产业', value: dataMap.dataTI['2006sum']}                ]}            ]        },        {            title : {text: '2007全国宏观经济指标'},            series : [                {data: dataMap.dataGDP['2007']},                {data: dataMap.dataFinancial['2007']},                {data: dataMap.dataEstate['2007']},                {data: dataMap.dataPI['2007']},                {data: dataMap.dataSI['2007']},                {data: dataMap.dataTI['2007']},                {data: [                    {name: '第一产业', value: dataMap.dataPI['2007sum']},                    {name: '第二产业', value: dataMap.dataSI['2007sum']},                    {name: '第三产业', value: dataMap.dataTI['2007sum']}                ]}            ]        },        {            title : {text: '2008全国宏观经济指标'},            series : [                {data: dataMap.dataGDP['2008']},                {data: dataMap.dataFinancial['2008']},                {data: dataMap.dataEstate['2008']},                {data: dataMap.dataPI['2008']},                {data: dataMap.dataSI['2008']},                {data: dataMap.dataTI['2008']},                {data: [                    {name: '第一产业', value: dataMap.dataPI['2008sum']},                    {name: '第二产业', value: dataMap.dataSI['2008sum']},                    {name: '第三产业', value: dataMap.dataTI['2008sum']}                ]}            ]        },        {            title : {text: '2009全国宏观经济指标'},            series : [                {data: dataMap.dataGDP['2009']},                {data: dataMap.dataFinancial['2009']},                {data: dataMap.dataEstate['2009']},                {data: dataMap.dataPI['2009']},                {data: dataMap.dataSI['2009']},                {data: dataMap.dataTI['2009']},                {data: [                    {name: '第一产业', value: dataMap.dataPI['2009sum']},                    {name: '第二产业', value: dataMap.dataSI['2009sum']},                    {name: '第三产业', value: dataMap.dataTI['2009sum']}                ]}            ]        },        {            title : {text: '2010全国宏观经济指标'},            series : [                {data: dataMap.dataGDP['2010']},                {data: dataMap.dataFinancial['2010']},                {data: dataMap.dataEstate['2010']},                {data: dataMap.dataPI['2010']},                {data: dataMap.dataSI['2010']},                {data: dataMap.dataTI['2010']},                {data: [                    {name: '第一产业', value: dataMap.dataPI['2010sum']},                    {name: '第二产业', value: dataMap.dataSI['2010sum']},                    {name: '第三产业', value: dataMap.dataTI['2010sum']}                ]}            ]        },        {            title : {text: '2011全国宏观经济指标'},            series : [                {data: dataMap.dataGDP['2011']},                {data: dataMap.dataFinancial['2011']},                {data: dataMap.dataEstate['2011']},                {data: dataMap.dataPI['2011']},                {data: dataMap.dataSI['2011']},                {data: dataMap.dataTI['2011']},                {data: [                    {name: '第一产业', value: dataMap.dataPI['2011sum']},                    {name: '第二产业', value: dataMap.dataSI['2011sum']},                    {name: '第三产业', value: dataMap.dataTI['2011sum']}                ]}            ]        }    ]};myChart.setOption(option);</script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Echarts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flink快速开始</title>
      <link href="/p/ecff9020.html"/>
      <url>/p/ecff9020.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Apache Flink是由Apache软件基金会开发的开源流处理框架，其核心是用Java和Scala编写的分布式流数据流引擎。Flink以数据并行和流水线方式执行任意流数据程序，Flink的流水线运行时系统可以执行批处理和流处理程序。此外，Flink的运行时本身也支持迭代算法的执行。<br> <a href="https://baike.baidu.com/item/flink/9078426?fr=aladdin" target="_blank" rel="noopener">原文链接</a></p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-01-11/flink-logo.png" alt="Flink-logo"></p><hr><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><h3 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h3><p>本文章主要在CentOS 7环境下安装，Flink唯一的要求是需要安装有效的Java 8.x.的用户，可以通过下面的命令查看当前JDK版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>如果是JDK8，则显示如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@zyj ~]<span class="comment"># java -version</span></span><br><span class="line">openjdk version <span class="string">"1.8.0_252"</span></span><br><span class="line">OpenJDK Runtime Environment (build 1.8.0_252-b09)</span><br><span class="line">OpenJDK 64-Bit Server VM (build 25.252-b09, mixed mode)</span><br></pre></td></tr></table></figure><h3 id="下载解压"><a href="#下载解压" class="headerlink" title="下载解压"></a>下载解压</h3><p><a href="https://flink.apache.org/downloads.html" target="_blank" rel="noopener">Flink下载地址</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -xvf flink-*.tgz</span><br></pre></td></tr></table></figure><h3 id="更换端口并启动"><a href="#更换端口并启动" class="headerlink" title="更换端口并启动"></a>更换端口并启动</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@zyj flink-1.12.0]<span class="comment"># vim conf/flink-conf.yaml</span></span><br></pre></td></tr></table></figure><p><code>rest.port</code>指定你想要设置的端口，这边设置为53742</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rest.port: 53742</span><br></pre></td></tr></table></figure><p>启动并指定刚配置好的配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@zyj flink-1.12.0]<span class="comment"># cd bin/</span></span><br><span class="line">[root@zyj bin]<span class="comment"># ./start-cluster.sh ../conf/flink-conf.yaml</span></span><br></pre></td></tr></table></figure><p>查看Flink是否运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@zyj conf]<span class="comment"># ps -ef | grep flink</span></span><br></pre></td></tr></table></figure><p>通过<code>isof</code>命令查看flink是否监听在53742端口上,其中6034为flink进程的PID，如下所示发现已在53742端口上监听</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@zyj conf]# lsof -p 6034 -nP | grep TCP</span><br><span class="line">java    6034 root   54u     IPv4          386596639       0t0       TCP *:6123 (LISTEN)</span><br><span class="line">java    6034 root   56u     IPv4          386596692       0t0       TCP *:45288 (LISTEN)</span><br><span class="line">java    6034 root   69u     IPv4          386596736       0t0       TCP *:43116 (LISTEN)</span><br><span class="line">java    6034 root   79u     IPv4          386596746       0t0       TCP *:53742 (LISTEN)</span><br><span class="line">java    6034 root   80u     IPv4          386596785       0t0       TCP 127.0.0.1:6123-&gt;127.0.0.1:52816 (ESTABLISHED)</span><br></pre></td></tr></table></figure><p>访问<code>http://localhost:53742</code>出现如下页面表示安装成功</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-01-11/flink-page.png" alt="flink-page"></p><h2 id="运行例子"><a href="#运行例子" class="headerlink" title="运行例子"></a>运行例子</h2><p>现在，我们将运行此Flink应用程序。它将从套接字读取文本，并且每5秒打印一次前<code>5秒</code>内每个不同单词的出现次数，即处理时间的翻滚窗口，只要文字漂浮在其中。</p><p>我们使用netcat来充当本地服务器，netcat可以通过<code>yum install -y netcat</code>来进行安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@zyj ~]<span class="comment"># nc -l 9000</span></span><br></pre></td></tr></table></figure><p>提交Flink任务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@zyj bin]<span class="comment"># ./flink run ../examples/streaming/SocketWindowWordCount.jar --port 9000</span></span><br></pre></td></tr></table></figure><p>检查作业是否按预期运行<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-01-11/flink-job1.png" alt="Flink-job1"></p><p>在我们刚netcat启动的服务器上输入想要的字符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@zyj ~]<span class="comment"># nc -l 9000</span></span><br><span class="line">root</span><br><span class="line">zyj zyj zyj</span><br><span class="line">root zyj</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@zyj flink-1.12.0]<span class="comment"># tail -f log/flink-*-taskexecutor-*.out</span></span><br><span class="line">zyj : 4</span><br><span class="line">root : 2</span><br></pre></td></tr></table></figure><p>停止Flink</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./bin/stop-cluster.sh</span><br></pre></td></tr></table></figure><h2 id="常用链接"><a href="#常用链接" class="headerlink" title="常用链接"></a>常用链接</h2><p><a href="https://flink.apachecn.org/docs/1.7-SNAPSHOT/#/" target="_blank" rel="noopener">Flink官方中文文档</a></p><hr><blockquote><p>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Arthas快速开始及常用命令</title>
      <link href="/p/931a270a.html"/>
      <url>/p/931a270a.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最开始接触Arthas，是在今年的三月份，那时候算是我的转正考试吧，总监让我回去看下线上诊断工具，并对团队里的人讲解一下，那时候看了<a href="https://www.bilibili.com/video/BV1Ct411Y7CT?from=search&seid=7168813823780939879" target="_blank" rel="noopener">小马哥的Arthas视频</a>，当时B站上还没有这么多教学视频，只有小马哥讲的最详细。</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-01-08/arthas-logo.png" alt="Arthas-logo"></p><p>Arthas主要是定位线上出现的问题，因为很多问题在测试环境中很难再重现。</p><blockquote><p>当你遇到以下类似问题而束手无策时，Arthas可以帮助你解决：<br>1.这个类从哪个 jar 包加载的？为什么会报各种类相关的 Exception？<br>2.我改的代码为什么没有执行到？难道是我没 commit？分支搞错了？<br>3.遇到问题无法在线上 debug，难道只能通过加日志再重新发布吗？<br>4.线上遇到某个用户的数据处理有问题，但线上同样无法 debug，线下无法重现！<br>5.是否有一个全局视角来查看系统的运行状况？<br>6.有什么办法可以监控到JVM的实时运行状态？<br>7.怎么快速定位应用的热点，生成火焰图？</p></blockquote><p>具体如何操作Arthas及其Arthas的高阶用法移步<a href="http://arthas.gitee.io" target="_blank" rel="noopener">Arthas官方手册</a></p><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p><a href="https://github.com/alibaba/arthas/releases" target="_blank" rel="noopener">Arthas下载链接</a></p><p>解压压缩文件，找到<code>arthas-boot.jar</code>文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar arthas-boot.jar</span><br></pre></td></tr></table></figure><p>如下我们可以看到在本机上运行的java程序，选择需要诊断的进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@zyj software]<span class="comment"># java -jar arthas-boot.jar </span></span><br><span class="line">[INFO] arthas-boot version: 3.1.7</span><br><span class="line">[INFO] Found existing java process, please choose one and hit RETURN.</span><br><span class="line">* [1]: 26902 arthas-boot.jar</span><br><span class="line">  [2]: 1223 com.alibaba.edas.agent.AgentDaemon</span><br><span class="line">  [3]: 26760 huanletao-server-0.0.1-SNAPSHOT.jar</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>当我们看到下面这个界面，就说明我们可以执行相关的arthas命令了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[INFO] arthas home: /root/.arthas/lib/3.4.5/arthas</span><br><span class="line">[INFO] Try to attach process 26760</span><br><span class="line">[INFO] Attach process 26760 success.</span><br><span class="line">[INFO] arthas-client connect 127.0.0.1 3658</span><br><span class="line">  ,---.  ,------. ,--------.,--.  ,--.  ,---.   ,---.                           </span><br><span class="line"> /  O  \ |  .--. <span class="string">''</span>--.  .--<span class="string">'|  '</span>--<span class="string">'  | /  O  \ '</span>   .-<span class="string">'                          </span></span><br><span class="line"><span class="string">|  .-.  ||  '</span>--<span class="string">'.'</span>   |  |   |  .--.  ||  .-.  |`.  `-.                          </span><br><span class="line">|  | |  ||  |\  \    |  |   |  |  |  ||  | |  |.-<span class="string">'    |                         </span></span><br><span class="line"><span class="string">`--'</span> `--<span class="string">'`--'</span> <span class="string">'--'</span>   `--<span class="string">'   `--'</span>  `--<span class="string">'`--'</span> `--<span class="string">'`-----'</span>                          </span><br><span class="line">                                                                                </span><br><span class="line"></span><br><span class="line">wiki      https://arthas.aliyun.com/doc                                         </span><br><span class="line">tutorials https://arthas.aliyun.com/doc/arthas-tutorials.html                   </span><br><span class="line">version   3.4.5                                                                 </span><br><span class="line">pid       26760                                                                 </span><br><span class="line">time      2021-01-08 23:37:12                                                   </span><br><span class="line"></span><br><span class="line">[arthas@26760]$</span><br></pre></td></tr></table></figure><p>执行<code>dashboard</code>命令可以看到，当前进程信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">ID NAME                GROUP     PRIORI STATE  %CPU  DELTA_ TIME   INTER DAEMON </span><br><span class="line">-1 C2 CompilerThread0  -         -1     -      0.25  0.012  0:10.6 <span class="literal">false</span> <span class="literal">true</span>   </span><br><span class="line">-1 C1 CompilerThread1  -         -1     -      0.13  0.006  0:2.41 <span class="literal">false</span> <span class="literal">true</span>   </span><br><span class="line">89 Timer-for-arthas-da system    5      RUNNAB 0.09  0.004  0:0.06 <span class="literal">false</span> <span class="literal">true</span>   </span><br><span class="line">28 TaskAcceptor-target eurekaTas 5      TIMED_ 0.07  0.003  0:0.46 <span class="literal">false</span> <span class="literal">true</span>   </span><br><span class="line">50 TaskAcceptor-localh eurekaTas 5      TIMED_ 0.07  0.003  0:0.45 <span class="literal">false</span> <span class="literal">true</span>   </span><br><span class="line">87 arthas-NettyHttpTel system    5      RUNNAB 0.04  0.002  0:0.10 <span class="literal">false</span> <span class="literal">true</span>   </span><br><span class="line">-1 VM Periodic Task Th -         -1     -      0.02  0.001  0:0.16 <span class="literal">false</span> <span class="literal">true</span>   </span><br><span class="line">-1 VM Thread           -         -1     -      0.0   0.000  0:1.45 <span class="literal">false</span> <span class="literal">true</span>   </span><br><span class="line">67 http-nio-8888-Clien main      5      RUNNAB 0.0   0.000  0:0.03 <span class="literal">false</span> <span class="literal">true</span>   </span><br><span class="line">15 ContainerBackground main      5      TIMED_ 0.0   0.000  0:0.00 <span class="literal">false</span> <span class="literal">true</span>   </span><br><span class="line">Memory           used  total max  usage GC                                      </span><br><span class="line">heap             67M   77M   444M       gc.copy.count       316                 </span><br><span class="line">eden_space       16M   21M   122M       gc.copy.time(ms)    1120                </span><br><span class="line">survivor_space   2M    2M    15M        gc.marksweepcompact 3                   </span><br><span class="line">tenured_gen      48M   53M   306M       .count                                  </span><br><span class="line">nonheap          71M   82M   -1         gc.marksweepcompact 221                 </span><br><span class="line">code_cache       5M    14M   240M 2.10% .time(ms)                               </span><br><span class="line">metaspace        58M   60M   -1                                                 </span><br><span class="line">Runtime                                                                         </span><br><span class="line">os.name                                 Linux                                   </span><br><span class="line">os.version                              3.10.0-1062.4.3.el7.x86_64              </span><br><span class="line">java.version</span><br></pre></td></tr></table></figure><p>具体高阶命令可以查看官方文档</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p>这个图是官方钉钉群某个大佬总结出来的，基本所有命令都在上面了，讲的很详细，如有侵权请联系删</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2021/2021-01-08/arthas.png" alt="常用命令"></p><hr><h2 id="重要issue链接"><a href="#重要issue链接" class="headerlink" title="重要issue链接"></a>重要issue链接</h2><p>由于Arthas拿不到非静态对象，于是最后这篇文章在web开发诊断中及其重要</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可以用tt命令的-i参数来指定index，并且用-w参数来执行ognl表达式来获取spring context</span></span><br><span class="line">$ tt -i 1000 -w <span class="string">'target.getApplicationContext()'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取到spring context之后，就可以获取到任意的bean了，比如获取到helloWorldService，并调用getHelloMessage()函数</span></span><br><span class="line">$ tt -i 1000 -w <span class="string">'target.getApplicationContext().getBean("helloWorldService").getHelloMessage()'</span></span><br></pre></td></tr></table></figure><p><a href="https://github.com/alibaba/arthas/issues/71" target="_blank" rel="noopener">Arthas的一些特殊用法</a></p><p><a href="https://github.com/alibaba/arthas/issues/482" target="_blank" rel="noopener">Alibaba Arthas实践–获取到SpringContext然后为所欲为</a></p><hr><blockquote><p>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线上诊断 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统分区与扩容</title>
      <link href="/p/2aaa04f0.html"/>
      <url>/p/2aaa04f0.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Windows的扩容操作，可以借助如Diskgenius的图形化界面进行操作，也可以使用Windows自带的磁盘管理器进行操作，一般我们发现磁盘空间不足的时候，最简单可以加硬盘，如果不想加硬盘，就可以选择一个比较空的磁盘给他压缩卷，再点击你想要扩容的磁盘进行扩展卷即可。但如果是Linux没有GUI该如何操作。</p><h2 id="查看分区情况"><a href="#查看分区情况" class="headerlink" title="查看分区情况"></a>查看分区情况</h2><h3 id="查看未挂载之前的磁盘使用情况"><a href="#查看未挂载之前的磁盘使用情况" class="headerlink" title="查看未挂载之前的磁盘使用情况"></a>查看未挂载之前的磁盘使用情况</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span>-machine ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root   97G   94G  3.1G  97% /</span><br><span class="line">devtmpfs                 7.7G     0  7.7G   0% /dev</span><br><span class="line">tmpfs                    7.7G     0  7.7G   0% /dev/shm</span><br><span class="line">tmpfs                    7.7G  8.9M  7.7G   1% /run</span><br><span class="line">tmpfs                    7.7G     0  7.7G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1               1014M  148M  867M  15% /boot</span><br><span class="line">tmpfs                    1.6G     0  1.6G   0% /run/user/0</span><br></pre></td></tr></table></figure><p>如上所示：<code>/dev/mapper/centos-root</code> 使用率是高达97%十分需要扩容</p><h3 id="查看分区"><a href="#查看分区" class="headerlink" title="查看分区"></a>查看分区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span>-machine consolelogs]<span class="comment"># fdisk -l</span></span><br><span class="line"></span><br><span class="line">Disk /dev/sda: 322.1 GB, 322122547200 bytes, 629145600 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x00079997</span><br><span class="line"></span><br><span class="line">Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048     2099199     1048576   83  Linux</span><br><span class="line">/dev/sda2         2099200   209715199   103808000   8e  Linux LVM</span><br><span class="line"></span><br><span class="line">Disk /dev/mapper/centos-root: 104.1 GB, 104148762624 bytes, 203415552 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure><p>发现总容量远大于已分配的空间<br>所以将<code>/dev/vda</code>下的空间划分给<code>/dev/mapper/centos-root</code> ，即<code>/</code>目录</p><hr><h2 id="增加分区的操作"><a href="#增加分区的操作" class="headerlink" title="增加分区的操作"></a>增加分区的操作</h2><h3 id="查看分区表"><a href="#查看分区表" class="headerlink" title="查看分区表"></a>查看分区表</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span>-machine consolelogs]<span class="comment"># fdisk /dev/sda</span></span><br><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line"></span><br><span class="line">Changes will remain <span class="keyword">in</span> memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write <span class="built_in">command</span>.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (2 primary, 0 extended, 2 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">Partition number (3,4, default 3): t</span><br><span class="line">Partition number (3,4, default 3): 3</span><br><span class="line">First sector (209715200-629145599, default 209715200): </span><br><span class="line">Using default value 209715200</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (209715200-629145599, default 629145599): </span><br><span class="line">Using default value 629145599</span><br><span class="line">Partition 3 of <span class="built_in">type</span> Linux and of size 200 GiB is <span class="built_in">set</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): t</span><br><span class="line">Partition number (1-3, default 3): 3</span><br><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): L</span><br><span class="line"></span><br><span class="line"> 0  Empty           24  NEC DOS         81  Minix / old Lin bf  Solaris        </span><br><span class="line"> 1  FAT12           27  Hidden NTFS Win 82  Linux swap / So c1  DRDOS/sec (FAT-</span><br><span class="line"> 2  XENIX root      39  Plan 9          83  Linux           c4  DRDOS/sec (FAT-</span><br><span class="line"> 3  XENIX usr       3c  PartitionMagic  84  OS/2 hidden C:  c6  DRDOS/sec (FAT-</span><br><span class="line"> 4  FAT16 &lt;32M      40  Venix 80286     85  Linux extended  c7  Syrinx         </span><br><span class="line"> 5  Extended        41  PPC PReP Boot   86  NTFS volume <span class="built_in">set</span> da  Non-FS data    </span><br><span class="line"> 6  FAT16           42  SFS             87  NTFS volume <span class="built_in">set</span> db  CP/M / CTOS / .</span><br><span class="line"> 7  HPFS/NTFS/exFAT 4d  QNX4.x          88  Linux plaintext de  Dell Utility   </span><br><span class="line"> 8  AIX             4e  QNX4.x 2nd part 8e  Linux LVM       df  BootIt         </span><br><span class="line"> 9  AIX bootable    4f  QNX4.x 3rd part 93  Amoeba          e1  DOS access     </span><br><span class="line"> a  OS/2 Boot Manag 50  OnTrack DM      94  Amoeba BBT      e3  DOS R/O        </span><br><span class="line"> b  W95 FAT32       51  OnTrack DM6 Aux 9f  BSD/OS          e4  SpeedStor      </span><br><span class="line"> c  W95 FAT32 (LBA) 52  CP/M            a0  IBM Thinkpad hi eb  BeOS fs        </span><br><span class="line"> e  W95 FAT16 (LBA) 53  OnTrack DM6 Aux a5  FreeBSD         ee  GPT            </span><br><span class="line"> f  W95 Extd (LBA) 54  OnTrackDM6      a6  OpenBSD         ef  EFI (FAT-12/16/</span><br><span class="line">10  OPUS            55  EZ-Drive        a7  NeXTSTEP        f0  Linux/PA-RISC b</span><br><span class="line">11  Hidden FAT12    56  Golden Bow      a8  Darwin UFS      f1  SpeedStor      </span><br><span class="line">12  Compaq diagnost 5c  Priam Edisk     a9  NetBSD          f4  SpeedStor      </span><br><span class="line">14  Hidden FAT16 &lt;3 61  SpeedStor       ab  Darwin boot     f2  DOS secondary  </span><br><span class="line">16  Hidden FAT16    63  GNU HURD or Sys af  HFS / HFS+      fb  VMware VMFS    </span><br><span class="line">17  Hidden HPFS/NTF 64  Novell Netware  b7  BSDI fs         <span class="built_in">fc</span>  VMware VMKCORE </span><br><span class="line">18  AST SmartSleep  65  Novell Netware  b8  BSDI swap       fd  Linux raid auto</span><br><span class="line">1b  Hidden W95 FAT3 70  DiskSecure Mult bb  Boot Wizard hid fe  LANstep        </span><br><span class="line">1c  Hidden W95 FAT3 75  PC/IX           be  Solaris boot    ff  BBT            </span><br><span class="line">1e  Hidden W95 FAT1 80  Old Minix      </span><br><span class="line">Hex code (<span class="built_in">type</span> L to list all codes): 8e</span><br><span class="line">Changed <span class="built_in">type</span> of partition <span class="string">'Linux'</span> to <span class="string">'Linux LVM'</span></span><br><span class="line"></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line"></span><br><span class="line">WARNING: Re-reading the partition table failed with error 16: Device or resource busy.</span><br><span class="line">The kernel still uses the old table. The new table will be used at</span><br><span class="line">the next reboot or after you run partprobe(8) or kpartx(8)</span><br><span class="line">Syncing disks.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#以上命令的解释</span><br><span class="line"></span><br><span class="line">n #新建分区</span><br><span class="line">p #主分区</span><br><span class="line">3 #第3个分区</span><br><span class="line">t #指定分区格式</span><br><span class="line">8e      #分区格式为LVM</span><br><span class="line">w #保存</span><br></pre></td></tr></table></figure><h3 id="重启"><a href="#重启" class="headerlink" title="重启"></a>重启</h3><p>重启下centos,SSH连接会断开,待centos重启完成后，再次SSH登陆。这时再次查看<code>fdisk -l</code>，就能看到我们增加的分区了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span>-machine consolelogs]<span class="comment"># reboot</span></span><br><span class="line"></span><br><span class="line">[root@<span class="built_in">test</span>-machine ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root   97G   94G  3.1G  97% /</span><br><span class="line">devtmpfs                 7.7G     0  7.7G   0% /dev</span><br><span class="line">tmpfs                    7.7G     0  7.7G   0% /dev/shm</span><br><span class="line">tmpfs                    7.7G  8.9M  7.7G   1% /run</span><br><span class="line">tmpfs                    7.7G     0  7.7G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1               1014M  148M  867M  15% /boot</span><br><span class="line">tmpfs                    1.6G     0  1.6G   0% /run/user/0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@<span class="built_in">test</span>-machine ~]<span class="comment"># fdisk -l</span></span><br><span class="line">Disk /dev/sda: 322.1 GB, 322122547200 bytes, 629145600 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line">Disk identifier: 0x00079997</span><br><span class="line">Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048     2099199     1048576   83  Linux</span><br><span class="line">/dev/sda2         2099200   209715199   103808000   8e  Linux LVM</span><br><span class="line">/dev/sda3       209715200   629145599   209715200   8e  Linux LVM</span><br><span class="line"></span><br><span class="line">Disk /dev/mapper/centos-root: 104.1 GB, 104148762624 bytes, 203415552 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Disk /dev/mapper/centos-swap: 2147 MB, 2147483648 bytes, 4194304 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br></pre></td></tr></table></figure><p>我们新建的分区<br><code>/dev/sda3 209715200 629145599 209715200 8e Linux LVM</code></p><h3 id="创建物理卷和分区"><a href="#创建物理卷和分区" class="headerlink" title="创建物理卷和分区"></a>创建物理卷和分区</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span>-machine ~]<span class="comment"># pvcreate /dev/sda3</span></span><br><span class="line">Physical volume <span class="string">"/dev/sda3"</span> successfully created.</span><br><span class="line"></span><br><span class="line">[root@<span class="built_in">test</span>-machine ~]<span class="comment"># vgextend centos /dev/sda3</span></span><br><span class="line">Volume group <span class="string">"centos"</span> successfully extended</span><br></pre></td></tr></table></figure><h3 id="查看可扩容空间"><a href="#查看可扩容空间" class="headerlink" title="查看可扩容空间"></a>查看可扩容空间</h3><p>查看物理卷情况，知道了可以增加的硬盘空间容量总量</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span>-machine ~]<span class="comment"># vgdisplay</span></span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               centos</span><br><span class="line">  System ID             </span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        2</span><br><span class="line">  Metadata Sequence No  4</span><br><span class="line">  VG Access             <span class="built_in">read</span>/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                2</span><br><span class="line">  Open LV               2</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                2</span><br><span class="line">  Act PV                2</span><br><span class="line">  VG Size               298.99 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              76542</span><br><span class="line">  Alloc PE / Size       25343 / &lt;99.00 GiB</span><br><span class="line">  Free  PE / Size       51199 / &lt;200.00 GiB</span><br><span class="line">  VG UUID               3I7OTi-r0Gi-Vfz5-E02j-AxRU-IS6d-yNAW1D</span><br></pre></td></tr></table></figure><h3 id="按照实际大小酌情增加，比如现在需增加200GB"><a href="#按照实际大小酌情增加，比如现在需增加200GB" class="headerlink" title="按照实际大小酌情增加，比如现在需增加200GB"></a>按照实际大小酌情增加，比如现在需增加200GB</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span>-machine ~]<span class="comment"># lvresize -L +200G /dev/mapper/centos-root</span></span><br><span class="line">Insufficient free space: 76800 extents needed, but only 51199 available</span><br></pre></td></tr></table></figure><h3 id="动态扩容分区的大小"><a href="#动态扩容分区的大小" class="headerlink" title="动态扩容分区的大小"></a>动态扩容分区的大小</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span>-machine ~]<span class="comment"># resize2fs /dev/mapper/centos-root</span></span><br><span class="line">resize2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">resize2fs: Bad magic number <span class="keyword">in</span> super-block <span class="keyword">while</span> trying to open /dev/mapper/centos-root</span><br><span class="line">Couldn<span class="string">'t find valid filesystem superblock.</span></span><br></pre></td></tr></table></figure><p>报错的话，执行命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span>-machine ~]<span class="comment"># xfs_growfs /dev/mapper/centos-root</span></span><br><span class="line">meta-data=/dev/mapper/centos-root isize=512    agcount=4, agsize=6356736 blks</span><br><span class="line">         =                       sectsz=512   attr=2, projid32bit=1</span><br><span class="line">         =                       crc=1        finobt=0 spinodes=0</span><br><span class="line">data     =                       bsize=4096   blocks=25426944, imaxpct=25</span><br><span class="line">         =                       sunit=0      swidth=0 blks</span><br><span class="line">naming   =version 2              bsize=4096   ascii-ci=0 ftype=1</span><br><span class="line"><span class="built_in">log</span>      =internal               bsize=4096   blocks=12415, version=2</span><br><span class="line">         =                       sectsz=512   sunit=0 blks, lazy-count=1</span><br><span class="line">realtime =none                   extsz=4096   blocks=0, rtextents=0</span><br><span class="line">data blocks changed from 25426944 to 77593600</span><br></pre></td></tr></table></figure><h3 id="查看最终的结果"><a href="#查看最终的结果" class="headerlink" title="查看最终的结果"></a>查看最终的结果</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@<span class="built_in">test</span>-machine ~]<span class="comment"># df -h</span></span><br><span class="line">Filesystem               Size  Used Avail Use% Mounted on</span><br><span class="line">/dev/mapper/centos-root  296G   94G  203G  32% /</span><br><span class="line">devtmpfs                 7.7G     0  7.7G   0% /dev</span><br><span class="line">tmpfs                    7.7G     0  7.7G   0% /dev/shm</span><br><span class="line">tmpfs                    7.7G  8.9M  7.7G   1% /run</span><br><span class="line">tmpfs                    7.7G     0  7.7G   0% /sys/fs/cgroup</span><br><span class="line">/dev/sda1               1014M  148M  867M  15% /boot</span><br><span class="line">tmpfs                    1.6G     0  1.6G   0% /run/user/0</span><br></pre></td></tr></table></figure><p><code>/dev/mapper/centos-root 296G 94G 203G 32% /</code>发现我们从先前的97G变成了296G，扩容成功。</p><hr><blockquote><p>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组合模式的见解与案例</title>
      <link href="/p/155fd47b.html"/>
      <url>/p/155fd47b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>组合模式（Composite Pattern），又叫部分整体模式，感觉就是把一组类似对象当作一个对象来进行操作，依据树形结构来组合对象，用来表示部分和整体这种结构，他是将类和对象以一定形式组成在一起的，所以属于结构型模式。</p><p>主要解决的问题：它在我们树型结构的问题中，模糊了简单元素和复杂元素的概念，客户程序可以像处理简单元素一样来处理复杂元素，从而使得客户程序与复杂元素的内部结构解耦，主要是与树枝和叶子同时实现一个接口来实现的。</p><p>举个简单的例子，如下图的文件夹结构，我们对于这个结构肯定会非常熟悉，对于这样的结构我们称之为树形结构。如下图中<code>.java</code>文件我们可以理解为叶子节点，而<code>简单缓存队列批量保存</code>可以当作容器，<code>cache-frame</code>也可以当作容器，他们都可以被双击点开，而容器可以在下面加入新的叶子节点或新的子容器，我们不需要判别是否是容器还是叶子结点，都可以通过双击来遍历这个结构。这就是组合模式的设计动机：<code>组合模式定义了如何将容器对象和叶子对象进行递归组合，使得客户在使用的过程中无须进行区分，可以对他们进行一致的处理。</code></p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020/2020-12-27/%E6%96%87%E4%BB%B6%E5%A4%B9%E7%BB%93%E6%9E%84.png" alt="文件夹结构"></p><hr><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。</p><p>组合模式对单个对象(叶子对象)和组合对象(组合对象)具有一致性，它将对象组织到树结构中，可以用来描述整体与部分的关系。同时它也模糊了简单元素(叶子对象)和复杂元素(容器对象)的概念，使得客户能够像处理简单元素一样来处理复杂元素，从而使客户程序能够与复杂元素的内部结构解耦。</p><p><strong>最关键就是叶子对象和组合对象实现相同的接口。这就是组合模式能够将叶子节点和对象节点进行一致处理的原因。</strong></p><hr><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><strong>优点：</strong></p><ol><li>高层模块调用简单</li><li>节点可以自由增加</li></ol><p><strong>缺点：</strong></p><ol><li>在使用组合模式时，其叶子和树枝的声明都是实现类，而不是接口，违反了依赖倒置原则。</li></ol><hr><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>主要由如下角色：</p><ol><li>组合接口（Component）：组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件。</li><li>容器对象（Composite）：容器对象，定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等。</li><li>叶子对象（Leaf）：没有子节点</li></ol><p><strong>类图：</strong></p><p>该类图请配合下面的案例查看</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020/2020-12-27/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="组合模式类图"></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>最近是第七次人口普查，我们就以人口普查作为案例，我们知道人口普查是一项重要的工作，需要人人都进行配合，才能完成最后的结果，所以一般都是从地方开始统计，在上报到省份直至中央进行统计，如以浙江省为例，需要下面的地级市先开始各自进行统计，如嘉兴市又需要下面的五县两区进行统计，统计好了嘉兴进行汇总报告给浙江省。就是这么一级级下来，而他们都具有一个的共同功能就是统计人口。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 角色Component：组合中的对象声明接口，在适当的情况下，实现所有类共有接口的默认行为。声明一个接口用于访问和管理Component子部件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICounter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">count</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容器：容器对象，定义有枝节点行为，用来存储子部件，在Component接口中实现与子部件有关操作，如增加(add)和删除(remove)等</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">ICounter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ICounter&gt; container = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(ICounter counter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> container.add(counter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(ICounter counter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> container.remove(counter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ICounter&gt; <span class="title">getChild</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> container;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> container.stream().mapToInt(ICounter::count).sum();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 叶子节点: 叶子节点。叶子节点没有子节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> <span class="keyword">implements</span> <span class="title">ICounter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer sum;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">City</span><span class="params">(Integer sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sum = sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSum</span><span class="params">(Integer sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sum = sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> xyz.molzhao.City;</span><br><span class="line"><span class="keyword">import</span> xyz.molzhao.Composite;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.assertEquals;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该案例实现一个统计的功能，主要统计整个中国的人口普查情况，需要各地方市统计好了，上报到各个省份，然后在上报给中央主要实现这样一个功能</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCompositeTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Composite china = <span class="keyword">new</span> Composite();</span><br><span class="line">        <span class="comment">// 新建浙江省容器</span></span><br><span class="line">        Composite zheJiang = <span class="keyword">new</span> Composite();</span><br><span class="line">        <span class="comment">// 嘉兴市统计完为1W人</span></span><br><span class="line">        City jiaxing = <span class="keyword">new</span> City(<span class="number">10000</span>);</span><br><span class="line">        City hangzhou = <span class="keyword">new</span> City(<span class="number">20000</span>);</span><br><span class="line">        zheJiang.add(jiaxing);</span><br><span class="line">        zheJiang.add(hangzhou);</span><br><span class="line">        china.add(zheJiang);</span><br><span class="line"></span><br><span class="line">        City shanghai = <span class="keyword">new</span> City(<span class="number">30000</span>);</span><br><span class="line">        china.add(shanghai);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        这边组成了</span></span><br><span class="line"><span class="comment">        -中国</span></span><br><span class="line"><span class="comment">        ---浙江</span></span><br><span class="line"><span class="comment">        -----嘉兴</span></span><br><span class="line"><span class="comment">        -----杭州</span></span><br><span class="line"><span class="comment">        ---上海</span></span><br><span class="line"><span class="comment">        这样的一个数据结构</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        assertEquals(<span class="number">60000</span>, china.count());</span><br><span class="line">        assertEquals(<span class="number">30000</span>, shanghai.count());</span><br><span class="line">        assertEquals(<span class="number">30000</span>, zheJiang.count());</span><br><span class="line">        assertEquals(<span class="number">10000</span>, jiaxing.count());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 最后结果</span><br><span class="line">中国总人数为：60000</span><br><span class="line">上海总人数为：30000</span><br><span class="line">浙江总人数为：30000</span><br><span class="line">嘉兴总人数为：10000</span><br></pre></td></tr></table></figure><h3 id="案例地址"><a href="#案例地址" class="headerlink" title="案例地址"></a>案例地址</h3><p>欢迎大家访问我的Github地址，如果喜欢的话，希望能给个Star，<a href="https://github.com/Normcorer/Composite-Pattern.git" target="_blank" rel="noopener">点击此处获取本案例源码</a></p><hr><blockquote><p>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码质量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ping命令如何测网速</title>
      <link href="/p/fa8bb93b.html"/>
      <url>/p/fa8bb93b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近工作上遇到一件奇怪的事情，先说一下事情的原委：</p><p>环境：CPU(英特尔十代高压具体什么型号忘记了)，内存16G，千兆网卡，千兆TENDA交换机，千兆TP-LINK交换机</p><p>项目还是之前的高并发项目，消息队列用的是RocketMQ，部署在本地服务器上，（由于服务器刚搬到公司，TP-LINK交换机是临时随便买的）在进行性能测试的时候开启了20个线程边生产边消费大概TPS在1W3左右，于是去网上找了类似配置的测试报告，大多在3W+，于是开始对RocketMQ进行调优，各种方式都试过了，TPS还是不如人意，后来想到是否是网络的原因，于是我Ping我同事的主机大概算出来在48MB/s,然后我Ping本地服务器12MB/s,这就奇怪了，最后发现是TP-LINK交换机的问题。</p><p>我把项目JAR包形式，运行在本地服务器上测试，单生产的TPS达到了5W+,因为走的是内网所以非常快。</p><p>非常不幸，这篇文章本来已经写完了，但是由于和阿里云的服务器断开连接了，没能及时发布保存，然后我通过cmd+c命令复制，后来又手贱复制的别的东西，替换掉了内存中剪切内容，百度了一下Mac没有自带记录剪贴的功能，十分郁闷。凭记忆又重新写了一遍。</p><hr><h2 id="Ping命令简单测试网速"><a href="#Ping命令简单测试网速" class="headerlink" title="Ping命令简单测试网速"></a>Ping命令简单测试网速</h2><h3 id="Mac-OS"><a href="#Mac-OS" class="headerlink" title="Mac OS"></a>Mac OS</h3><p>因为这篇文章是在家里写的所以只能拿Mac OS来演示了，Mac OS的命令和Linux基本相同因此这边只介绍一个。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#发送1200byte到指定IP或者域名</span><br><span class="line">ping -s 1200 www.baidu.com</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#发送4次,1200byte到指定IP或者域名</span><br><span class="line">ping -c 4 -s 1200 www.baidu.com</span><br></pre></td></tr></table></figure><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-12-24/Mac-Ping.png" alt="Mac-Ping"></p><p>观察上面结果，我们来粗略的算一下ping的网速</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1200(byte)&#x2F;1024(kb)&#x2F;22.091ms*1000 &#x3D; 53.04KB&#x2F;s</span><br></pre></td></tr></table></figure><p>由于ping是发送指定大小的数据包，到指定服务器然后服务器进行响应，这个和下载的速度不是一个概念，这边可以粗略的看清楚现在的网速是否正常.</p><p>一般普通宽带我们ping常用的网址，延迟在50ms以内都为正常的</p><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#发送1200byte到指定IP或者域名</span><br><span class="line">ping -l 1200 www.baidu.com</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#发送4次，1200byte到指定IP或者域名</span><br><span class="line">ping -n 4 -l 1200 www.baidu.com</span><br></pre></td></tr></table></figure><hr><blockquote><p>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>迭代器模式的见解与案例</title>
      <link href="/p/7b516276.html"/>
      <url>/p/7b516276.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>迭代器模式其实在我们平时开发中，经常会用到，但是我们并不会自己去写一个迭代器，通常是调用java自带的迭代器，只有在自己想要设计一种新的数据结构的时候，可能会创建对应的迭代器，即便如此，我们也要了解迭代器是怎么实现的，它解决了什么问题，好奇心驱使我去学习了一下。</p><p><strong>解决的问题：</strong><br>为了解决在平时开发中，经常要访问一个聚合对象中的各个元素，如“数据结构”中的链表遍历，通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”的问题。</p><hr><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。迭代器模式是一种对象行为型模式</p><hr><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><strong>迭代器模式主要包含以下角色：</strong></p><ol><li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li><li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li><li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。</li><li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li></ol><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-12-13/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F.png" alt="迭代器模式结构图"></p><hr><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><strong>优点：</strong></p><ol><li>访问一个聚合对象的内容而无须暴露它的内部表示。</li><li>遍历任务交由迭代器完成，这简化了聚合类。</li><li>它支持以不同方式遍历一个聚合，甚至可以自定义迭代器的子类以支持新的遍历。</li><li>增加新的聚合类和迭代器类都很方便，无须修改原有代码。</li><li>封装性良好，为遍历不同的聚合结构提供一个统一的接口。</li></ol><p><strong>缺点：</strong></p><ol><li>增加了类的个数，一定程度上增加了程序的复杂度</li></ol><hr><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象聚合接口，新增聚合类实现该接口：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao.standard;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> xyz.molzhao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xyz.molzhao.Aggregate;</span><br><span class="line"><span class="keyword">import</span> xyz.molzhao.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体聚合实现类：实现抽象聚合类，返回一个具体迭代器的实例。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; aggregate = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        aggregate.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        aggregate.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(aggregate);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象迭代器接口：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> xyz.molzhao.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体迭代器实现类：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(List&lt;Object&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> hasNext() ? list.get(++index) : <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">first</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; list.size() - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> xyz.molzhao.impl.ConcreteAggregate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.Assert.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorPatternTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        Aggregate aggregate = <span class="keyword">new</span> ConcreteAggregate();</span><br><span class="line">        aggregate.add(<span class="string">"item1"</span>);</span><br><span class="line">        aggregate.add(<span class="string">"item2"</span>);</span><br><span class="line">        aggregate.add(<span class="string">"item3"</span>);</span><br><span class="line">        aggregate.add(<span class="string">"item4"</span>);</span><br><span class="line">        aggregate.add(<span class="string">"item5"</span>);</span><br><span class="line">        Iterator iterator = aggregate.getIterator();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act</span></span><br><span class="line">        <span class="keyword">boolean</span> result = iterator.hasNext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert</span></span><br><span class="line">        assertTrue(result);</span><br><span class="line">        assertEquals(<span class="string">"item1"</span>, iterator.next());</span><br><span class="line">        assertEquals(<span class="string">"item2"</span>, iterator.next());</span><br><span class="line">        assertEquals(<span class="string">"item3"</span>, iterator.next());</span><br><span class="line">        assertEquals(<span class="string">"item4"</span>, iterator.next());</span><br><span class="line">        assertEquals(<span class="string">"item5"</span>, iterator.next());</span><br><span class="line">        assertFalse(iterator.hasNext());</span><br><span class="line">        assertNull(iterator.next());</span><br><span class="line">        assertEquals(<span class="string">"item1"</span>, iterator.first());</span><br><span class="line">        assertTrue(iterator.hasNext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testIterator_ergodic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        Aggregate aggregate = <span class="keyword">new</span> ConcreteAggregate();</span><br><span class="line">        aggregate.add(<span class="string">"item1"</span>);</span><br><span class="line">        aggregate.add(<span class="string">"item2"</span>);</span><br><span class="line">        aggregate.add(<span class="string">"item3"</span>);</span><br><span class="line">        aggregate.add(<span class="string">"item4"</span>);</span><br><span class="line">        aggregate.add(<span class="string">"item5"</span>);</span><br><span class="line">        Iterator iterator = aggregate.getIterator();</span><br><span class="line"></span><br><span class="line">        StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act</span></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            result.append(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert</span></span><br><span class="line">        assertEquals(<span class="string">"item1item2item3item4item5"</span>, result.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="案例地址"><a href="#案例地址" class="headerlink" title="案例地址"></a>案例地址</h3><p>欢迎大家访问我的Github地址，如果喜欢的话，希望能给个Star，<a href="https://github.com/Normcorer/Iterator-Pattern.git" target="_blank" rel="noopener">点击此处获取本案例源码</a></p><hr><blockquote><p>该文章参考的原文链接 <a href="http://c.biancheng.net/view/1395.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1395.html</a><br>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码质量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令模式的见解与案例</title>
      <link href="/p/d3e8e26b.html"/>
      <url>/p/d3e8e26b.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在平时开发中<strong>方法的请求者</strong>和<strong>方法的实现者</strong>直接很容易产生耦合。</p><p>在现实生活中也有很多案例，比如windows的cmd面板，mac的terminal，操作电视的遥控器，只要给定相应的命令，或者按某个案件就能完成操作。就相当于命令模式。</p><p>如电视遥控器，就将换台请求和换台处理完全解耦了。电视机遥控器（命令发送者）通过按钮（具体命令）来遥控电视机（命令接收者）。</p><hr><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</p><hr><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><strong>命令模式包含以下主要角色：</strong></p><ol><li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li><li>具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li><li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li><li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li></ol><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-30/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="命令模式结构图"></p><hr><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><strong>优点：</strong></p><ol><li>通过引入中间件（抽象接口）降低系统的耦合度。</li><li>扩展性良好，增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，且满足“开闭原则”。</li><li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li><li>方便实现 Undo和Redo操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li><li>可以在现有命令的基础上，增加额外功能。比如日志记录，结合装饰器模式会更加灵活。</li></ol><p><strong>缺点：</strong></p><ol><li>可能产生大量具体的命令类。因为每一个具体操作都需要设计一个具体命令类，这会增加系统的复杂性。</li><li>命令模式的结果其实就是接收方的执行结果，但是为了以命令的形式进行架构、解耦请求与实现，引入了额外类型结构（引入了请求方与抽象命令接口），增加了理解上的困难。不过这也是设计模式的通病，抽象必然会额外增加类的数量，代码抽离肯定比代码聚合更加难理解。</li></ol><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="通用案例"><a href="#通用案例" class="headerlink" title="通用案例"></a>通用案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao.standard;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法execute()　</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao.standard;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体命令类（Concrete Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandA</span> <span class="keyword">implements</span> <span class="title">ICommand</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ReceiverA receiverA;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommandA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiverA = <span class="keyword">new</span> ReceiverA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CommandA命令被执行..."</span>);</span><br><span class="line">        receiverA.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao.standard;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现者/接收者（Receiver）角色：执行命令的相关操作，是具体命令对象业务的真正实现者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ReceiverA执行操作...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao.standard;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ICommand command;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(ICommand command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(ICommand command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao.standard;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCommand</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> Invoker(<span class="keyword">new</span> CommandA());</span><br><span class="line">        invoker.call();</span><br><span class="line">        invoker.setCommand(<span class="keyword">new</span> CommandB());</span><br><span class="line">        invoker.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#结果</span></span><br><span class="line">CommandA命令被执行...</span><br><span class="line">ReceiverA执行操作....</span><br><span class="line">CommandB命令被执行...</span><br><span class="line">ReceiverB执行操作...</span><br></pre></td></tr></table></figure><h3 id="TODO-扩展-备忘录"><a href="#TODO-扩展-备忘录" class="headerlink" title="TODO 扩展-备忘录"></a>TODO 扩展-备忘录</h3><h3 id="TODO-扩展-宏命令"><a href="#TODO-扩展-宏命令" class="headerlink" title="TODO 扩展-宏命令"></a>TODO 扩展-宏命令</h3><hr><h2 id="案例地址"><a href="#案例地址" class="headerlink" title="案例地址"></a>案例地址</h2><p>欢迎大家访问我的Github地址，如果喜欢的话，希望能给个Star，<a href="https://github.com/Normcorer/Command-Pattern.git" target="_blank" rel="noopener">点击此处获取本案例源码</a></p><hr><blockquote><p>该文章引用的原文链接 <a href="http://c.biancheng.net/view/1380.html" target="_blank" rel="noopener">http://c.biancheng.net/view/1380.html</a><br>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码质量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RocketMq在CentOS7下部署集群</title>
      <link href="/p/12096768.html"/>
      <url>/p/12096768.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在运用中流程一般 是在程序中使用代码编辑生产者,将所需要的消息发送到rocketmq中，然后另一个程序编辑消费者从rocketmq里面获取消息。rocketmq集群，需要nameServer和Broker集群。</p><p>准备两台服务器，两台机器都是master，如果要搞一主N备，修改相应的配置文件</p><p>1.ip:192.168.31.144 rocketmq-nameserver1  rocketmq-master1</p><p>2.ip:192.168.31.165 rocketmq-nameserver2  rocketmq-master2</p><hr><h2 id="安装JDK环境"><a href="#安装JDK环境" class="headerlink" title="安装JDK环境"></a>安装JDK环境</h2><p><a href="https://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">点击此处下载JDK</a></p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource1.png" alt="reouces1"></p><p>1.上传该文件到：<code>/usr/local</code></p><p>2.解压 <code>tar -zxvf jdk-7u80-linux-x64.tar.gz</code></p><p>3.修改配置文件</p><p>4.<code>vi /etc/profile</code></p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource2.png" alt="reouces2"></p><p>在末尾添加配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/jdk1.7.0_80</span><br><span class="line"><span class="built_in">export</span> CLASSPATH=.:<span class="variable">$JAVA_HOME</span>/lib/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure><p>刷新配置文件：</p><p><code>source /etc/profile</code>（该命令可以让 当前的配置文件立刻生效。不需要在重启服务器）</p><p>5.测试jdk安装是否成功： java -version</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br><span class="line">java version <span class="string">"1.8.0_131"</span></span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_131-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)</span><br></pre></td></tr></table></figure><p>如上所示：表示成功。</p><hr><h2 id="配置RocketMQ集群"><a href="#配置RocketMQ集群" class="headerlink" title="配置RocketMQ集群"></a>配置RocketMQ集群</h2><p>1.<a href="http://rocketmq.apache.org/dowloading/releases/" target="_blank" rel="noopener">点击此处下载mq</a></p><p>2.上传下载包到 <code>/usr/local</code></p><p>3.解压文件 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 上传alibaba-rocketmq-3.2.6.tar.gz文件至/usr/local</span></span><br><span class="line"><span class="comment"># tar -zxvf alibaba-rocketmq-3.2.6.tar.gz -C /usr/local</span></span><br><span class="line"><span class="comment"># mv alibaba-rocketmq alibaba-rocketmq-3.2.6</span></span><br><span class="line"><span class="comment"># ln -s alibaba-rocketmq-3.2.6 rocketmq</span></span><br></pre></td></tr></table></figure><p>4.创建存储路径：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/<span class="built_in">local</span>/rocketmq/store</span><br><span class="line"><span class="comment"># mkdir /usr/local/rocketmq/store/commitlog</span></span><br><span class="line"><span class="comment"># mkdir /usr/local/rocketmq/store/consumequeue</span></span><br><span class="line"><span class="comment"># mkdir /usr/local/rocketmq/store/index</span></span><br></pre></td></tr></table></figure><p>5.修改rocketmq的核心配置文件：</p><p><strong>broker-a.properties文件配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment">#broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line">brokerName=broker<span class="_">-a</span></span><br><span class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">brokerId=0</span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=10911</span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line">storePathRootDir=/usr/<span class="built_in">local</span>/rocketmq/store</span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/usr/<span class="built_in">local</span>/rocketmq/store/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/<span class="built_in">local</span>/rocketmq/store/index</span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/<span class="built_in">local</span>/rocketmq/store/checkpoint</span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line">abortFile=/usr/<span class="built_in">local</span>/rocketmq/store/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure><p><strong>broker-b.properties文件配置</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#所属集群名字</span></span><br><span class="line">brokerClusterName=rocketmq-cluster</span><br><span class="line"><span class="comment">#broker名字，注意此处不同的配置文件填写的不一样</span></span><br><span class="line">brokerName=broker-b</span><br><span class="line"><span class="comment">#0 表示 Master，&gt;0 表示 Slave</span></span><br><span class="line">brokerId=0</span><br><span class="line"><span class="comment">#nameServer地址，分号分割</span></span><br><span class="line">namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</span><br><span class="line"><span class="comment">#在发送消息时，自动创建服务器不存在的topic，默认创建的队列数</span></span><br><span class="line">defaultTopicQueueNums=4</span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建Topic，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateTopicEnable=<span class="literal">true</span></span><br><span class="line"><span class="comment">#是否允许 Broker 自动创建订阅组，建议线下开启，线上关闭</span></span><br><span class="line">autoCreateSubscriptionGroup=<span class="literal">true</span></span><br><span class="line"><span class="comment">#Broker 对外服务的监听端口</span></span><br><span class="line">listenPort=10911</span><br><span class="line"><span class="comment">#删除文件时间点，默认凌晨 4点</span></span><br><span class="line">deleteWhen=04</span><br><span class="line"><span class="comment">#文件保留时间，默认 48 小时</span></span><br><span class="line">fileReservedTime=120</span><br><span class="line"><span class="comment">#commitLog每个文件的大小默认1G</span></span><br><span class="line">mapedFileSizeCommitLog=1073741824</span><br><span class="line"><span class="comment">#ConsumeQueue每个文件默认存30W条，根据业务情况调整</span></span><br><span class="line">mapedFileSizeConsumeQueue=300000</span><br><span class="line"><span class="comment">#destroyMapedFileIntervalForcibly=120000</span></span><br><span class="line"><span class="comment">#redeleteHangedFileInterval=120000</span></span><br><span class="line"><span class="comment">#检测物理文件磁盘空间</span></span><br><span class="line">diskMaxUsedSpaceRatio=88</span><br><span class="line"><span class="comment">#存储路径</span></span><br><span class="line">storePathRootDir=/usr/<span class="built_in">local</span>/rocketmq/store</span><br><span class="line"><span class="comment">#commitLog 存储路径</span></span><br><span class="line">storePathCommitLog=/usr/<span class="built_in">local</span>/rocketmq/store/commitlog</span><br><span class="line"><span class="comment">#消费队列存储路径存储路径</span></span><br><span class="line">storePathConsumeQueue=/usr/<span class="built_in">local</span>/rocketmq/store/consumequeue</span><br><span class="line"><span class="comment">#消息索引存储路径</span></span><br><span class="line">storePathIndex=/usr/<span class="built_in">local</span>/rocketmq/store/index</span><br><span class="line"><span class="comment">#checkpoint 文件存储路径</span></span><br><span class="line">storeCheckpoint=/usr/<span class="built_in">local</span>/rocketmq/store/checkpoint</span><br><span class="line"><span class="comment">#abort 文件存储路径</span></span><br><span class="line">abortFile=/usr/<span class="built_in">local</span>/rocketmq/store/abort</span><br><span class="line"><span class="comment">#限制的消息大小</span></span><br><span class="line">maxMessageSize=65536</span><br><span class="line"><span class="comment">#flushCommitLogLeastPages=4</span></span><br><span class="line"><span class="comment">#flushConsumeQueueLeastPages=2</span></span><br><span class="line"><span class="comment">#flushCommitLogThoroughInterval=10000</span></span><br><span class="line"><span class="comment">#flushConsumeQueueThoroughInterval=60000</span></span><br><span class="line"><span class="comment">#Broker 的角色</span></span><br><span class="line"><span class="comment">#- ASYNC_MASTER 异步复制Master</span></span><br><span class="line"><span class="comment">#- SYNC_MASTER 同步双写Master</span></span><br><span class="line"><span class="comment">#- SLAVE</span></span><br><span class="line">brokerRole=ASYNC_MASTER</span><br><span class="line"><span class="comment">#刷盘方式</span></span><br><span class="line"><span class="comment">#- ASYNC_FLUSH 异步刷盘</span></span><br><span class="line"><span class="comment">#- SYNC_FLUSH 同步刷盘</span></span><br><span class="line">flushDiskType=ASYNC_FLUSH</span><br><span class="line"><span class="comment">#checkTransactionMessageEnable=false</span></span><br><span class="line"><span class="comment">#发消息线程池数量</span></span><br><span class="line"><span class="comment">#sendMessageThreadPoolNums=128</span></span><br><span class="line"><span class="comment">#拉消息线程池数量</span></span><br><span class="line"><span class="comment">#pullMessageThreadPoolNums=128</span></span><br></pre></td></tr></table></figure><p>6.在本地host文件中 添加域名解析</p><p>配置文件中：<code>namesrvAddr=rocketmq-nameserver1:9876;rocketmq-nameserver2:9876</code> 此地址需要域名解析:</p><p>1.打开 <code>hosts</code> 文件 <code>vi /etc/hosts</code></p><p>2.添加对应的域名解析：<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource3.png" alt="reouces3"></p><p>至于划横线的地方，有的机器如果不添加 则可能在启动NameServer的时候会报错 提示没有主机名关联的地址。</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource4.png" alt="reouces4"></p><p>可以通过<code>hostname</code>命令，查看主机名字</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource5.png" alt="reouces5"></p><p>修改完配置以后 则需要刷新网卡：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><p>如果是虚拟机克隆出来的服务器,刷新网卡的时候 如果报错，则可以查看：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-xxx 文件（每台机器名字可能不一样）</span><br></pre></td></tr></table></figure><p>修改HWADDR的mac地址</p><p>mac地址可以两种方式查看：<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource6.png" alt="reouces6"></p><p>或者</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource7.png" alt="reouces7"></p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource8.png" alt="reouces8"></p><p>有的机器没有HWADDR 这个配置名字，如果没有则添加上去。修改完配置以后 重新刷新网卡 <code>service network restart</code>，如果刷新还报错。可以尝试重新启动。</p><p>可以通过ping的方式 检测 hosts文件是否配置成功：</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource9.png" alt="reouces9"></p><p>以上上传和解压，修改本地hosts文件，刷新网卡，关闭防火墙等操作两台服务器都应该进行相应的操作，所有的操作完成了，则接下来就是启动rocketmq</p><hr><h2 id="关于NameServer和brok的启动"><a href="#关于NameServer和brok的启动" class="headerlink" title="关于NameServer和brok的启动"></a>关于NameServer和brok的启动</h2><p>1.进入  <code>cd /usr/local/rocketmq/bin</code> </p><p>2.<code>nohup sh mqnamesrv &amp;</code> 后台启动nameServer 然后通过jps命令查看当前是否正常启动。</p><p>ps：第一次操作的时候，总是会在这里出错，启动的时候 提示：</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource10.png" alt="reouces10"></p><p>网上查了一大堆原因，也不知道是怎么回事，可以换 <code>sh mqnamesrv</code> 这种方式启动，如果有报错 则会打印报错日志，如果启动的时候如图所示：</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource11.png" alt="reouces11"></p><p>表示正常启动成功，当然这是前端启动方式，ctrl+c 就自然退出了，需要切换成后台启动形式：</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource12.png" alt="reouces12"></p><p>所以启动这里，你可以先后台启动,然后通过 <code>jps</code> 查看 是否启动成功，如果没有启动成功则前台方式启动，看看打印的错误日志。例如：</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource13.png" alt="reouces13"></p><p>成功启动以后 则能看到：</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource14.png" alt="reouces14"></p><p>如果启动的时候因为内存分配原因 导致无法启动成功，则需要修改配置文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /usr/<span class="built_in">local</span>/rocketmq/bin/runbroker.sh</span><br></pre></td></tr></table></figure><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource15.png" alt="reouces15"></p><p>2.启动brokerServer</p><p>1.<code>cd /usr/local/rocketmq/bin</code></p><p>2.<code>nohup sh mqbroker -c /usr/local/rocketmq/conf/2m-noslave/broker-a.properties &gt;/dev/null 2&gt;&amp;1 &amp;</code> （如果是另一台机器，则启动时候需要用到是 broker -b.properties文件）如图：</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource16.png" alt="reouces16"></p><p>两台机器都完成了上面的步骤，可以搭建一个rocketmq的后端管理系统</p><p>1.下载 tomcat（可以将tomcat放在两台服务器中的任何一台都可以了 tomcat 不需要集群）</p><p>2.下载rocketmq的后端管理平台所需要的war包</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource17.png" alt="reouces17"></p><p>3.将war包放到<code>tomcat/webapps</code>目录（启动或者重启tomcat的时候自动解压war包了）</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource18.png" alt="reouces18"></p><p>4.修改位于：<code>/usr/local/apache-tomcat-7.0.65/webapps/rocketmq-web-console/WEB-INF/classes</code>下的<code>config.properties</code>文件将集群的ip地址配置进去。</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource19.png" alt="reouces19"></p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource20.png" alt="reouces20"></p><p>5.启动tomcat 输入请求地址栏：</p><p><a href="http://192.168.31.197:8080/rocketmq-web-console/cluster/list.do" target="_blank" rel="noopener">http://192.168.31.197:8080/rocketmq-web-console/cluster/list.do</a></p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-17/resource21.png" alt="reouces21"></p><hr><blockquote><p>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 互联网架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
            <tag> RocketMq </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle常见死锁发生的原因及解决方法</title>
      <link href="/p/86b3e3e1.html"/>
      <url>/p/86b3e3e1.html</url>
      
        <content type="html"><![CDATA[<h2 id="删除和更新之间引起的死锁"><a href="#删除和更新之间引起的死锁" class="headerlink" title="删除和更新之间引起的死锁"></a>删除和更新之间引起的死锁</h2><p>造成死锁的原因就是多个线程或进程对同一个资源的争抢或相互依赖。这里列举一个对同一个资源的争抢造成死锁的实例。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> testLock</span><br><span class="line">(</span><br><span class="line">    <span class="keyword">ID</span> <span class="built_in">NUMBER</span>, </span><br><span class="line">    <span class="keyword">test</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>)</span><br><span class="line">) </span><br><span class="line"><span class="keyword">COMMIT</span>  </span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testLock <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'test1'</span>); </span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testLock <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">'test2'</span>); </span><br><span class="line"><span class="keyword">COMMIT</span>; </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> testLock</span><br></pre></td></tr></table></figure><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-11/resource1.png" alt="resource1"></p><p><strong>死锁现象重现</strong></p><p>1.执行下面sql</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 加行级锁 并对内容进行修改，不要提交</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> testLock <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>;</span><br></pre></td></tr></table></figure><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-11/resource2.png" alt="resource2"></p><p>查询死锁</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.username,l.object_id, l.session_id,s.serial<span class="comment">#, s.lockwait,s.status,s.machine,s.program from v$session s,v$locked_object l where s.sid = l.session_id;</span></span><br></pre></td></tr></table></figure><blockquote><p>字段说明：</p><p>Username：死锁语句所用的数据库用户；</p><p>SID: session identifier， session 标示符，</p><p> session 是通信双方从开始通信到通信结束期间的一个上下文。</p><p>SERIAL#: sid 会重用，但是同一个sid被重用时，serial#会增加，不会重复。</p><p>Lockwait：可以通过这个字段查询出当前正在等待的锁的相关信息。</p><p>Status：用来判断session状态。Active：正执行SQL语句。</p><p>Inactive：等待操作。Killed：被标注为删除。</p><p>Machine： 死锁语句所在的机器。</p><p>Program： 产生死锁的语句主要来自哪个应用程序。</p></blockquote><p>此时有一行在命令在等待操作Inactive<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-11/resource3.png" alt="resource3"></p><p>查看引起死锁的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sql_text <span class="keyword">from</span> v$<span class="keyword">sql</span> <span class="keyword">where</span> hash_value <span class="keyword">in</span>   (<span class="keyword">select</span> sql_hash_value <span class="keyword">from</span> v$<span class="keyword">session</span> <span class="keyword">where</span> <span class="keyword">sid</span> <span class="keyword">in</span>  (<span class="keyword">select</span> session_id <span class="keyword">from</span> v$locked_object));</span><br></pre></td></tr></table></figure><p>此时没有引起死锁的语句。</p><p>2.另开一个command窗口，执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> testLock <span class="keyword">WHERE</span> <span class="keyword">ID</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>此时发生死锁（注意此时要另开一个窗口，不然会提示：POST THE CHANGE RECORD TO THE DATABASE. 点yes 后强制commit）：</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-11/resource4.png" alt="resource4"></p><p>死锁查看：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> s.username,l.object_id, l.session_id,s.serial<span class="comment">#, s.lockwait,s.status,s.machine,s.program from v$session s,v$locked_object l where s.sid = l.session_id;</span></span><br></pre></td></tr></table></figure><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-11-11/resource5.png" alt="resource5"></p><p>查看引起死锁的语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sql_text <span class="keyword">from</span> v$<span class="keyword">sql</span> <span class="keyword">where</span> hash_value <span class="keyword">in</span>   (<span class="keyword">select</span> sql_hash_value <span class="keyword">from</span> v$<span class="keyword">session</span> <span class="keyword">where</span> <span class="keyword">sid</span> <span class="keyword">in</span>  (<span class="keyword">select</span> session_id <span class="keyword">from</span> v$locked_object));</span><br></pre></td></tr></table></figure><p>查出以下语句死锁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span>   <span class="keyword">from</span>  testLock  <span class="keyword">where</span>   <span class="keyword">ID</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>死锁的处理：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">kill</span> <span class="keyword">session</span> <span class="string">'session_id,serial#'</span>; </span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">kill</span> <span class="keyword">session</span> <span class="string">'301,16405'</span>;</span><br></pre></td></tr></table></figure><p>再查看一下死锁，会发现已经没有stauts为active的记录了，发生死锁的语句已经被终止。</p><h2 id="在外键上没有加索引引起的死锁"><a href="#在外键上没有加索引引起的死锁" class="headerlink" title="在外键上没有加索引引起的死锁"></a>在外键上没有加索引引起的死锁</h2><p>客户的10.2.0.4 RAC for AIX环境频繁出现ORA-60死锁问题，导致应用程序无法顺利执行。 </p><p>经过一系列的诊断，发现最终问题是由于外键上没有建立索引所致，由于程序在主子表上删除数据，缺少索引导致行级锁升级为表级锁，最终导致大量的锁等待和死锁。<br>下面通过一个例子简单模拟一下问题：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; create table t_p (id number primary key, name varchar2(30)); </span><br><span class="line">Table created. </span><br><span class="line">SQL&gt; create table t_f (fid number, f_name varchar2(30), foreign key (fid) references t_p); </span><br><span class="line">Table created. </span><br><span class="line">SQL&gt; insert into t_p values (1, 'a'); </span><br><span class="line">1 row created. </span><br><span class="line">SQL&gt; insert into t_f values (1, 'a'); </span><br><span class="line">1 row created. </span><br><span class="line">SQL&gt; insert into t_p values (2, 'b'); </span><br><span class="line">1 row created. </span><br><span class="line">SQL&gt; insert into t_f values (2, 'c'); </span><br><span class="line">1 row created. </span><br><span class="line">SQL&gt; commit; </span><br><span class="line"><span class="keyword">Commit</span> complete. </span><br><span class="line"><span class="keyword">SQL</span>&gt; <span class="keyword">delete</span> t_f <span class="keyword">where</span> fid = <span class="number">2</span>; </span><br><span class="line">1 row deleted.</span><br></pre></td></tr></table></figure><p>这时在会话2同样对子表进行删除：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL2&gt; delete t_f where fid = 1; </span><br><span class="line">1 row deleted.</span><br></pre></td></tr></table></figure><p>回到会话1执行主表的删除：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; delete t_p where id = 2;</span><br></pre></td></tr></table></figure><p>会话被锁，回到会话2执行主表的删除：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQL2&gt; delete t_p where id = 1;</span><br></pre></td></tr></table></figure><p>会话同样被锁，这时会话1的语句被回滚，出现ORA-60死锁错误： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> t_p <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span> </span><br><span class="line">* </span><br><span class="line"><span class="keyword">ERROR</span> <span class="keyword">at</span> line <span class="number">1</span>: </span><br><span class="line">ORA<span class="number">-00060</span>: deadlock detected <span class="keyword">while</span> waiting <span class="keyword">for</span> <span class="keyword">resource</span> </span><br><span class="line"><span class="keyword">SQL</span>&gt; <span class="keyword">rollback</span>; </span><br><span class="line"><span class="keyword">Rollback</span> complete. </span><br><span class="line">将会话<span class="number">1</span>操作回滚，会话<span class="number">2</span>同样回滚并建立外键列上的索引： </span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> deleted. </span><br><span class="line">SQL2&gt; <span class="keyword">rollback</span>; </span><br><span class="line"><span class="keyword">Rollback</span> complete. </span><br><span class="line">SQL2&gt; <span class="keyword">create</span> <span class="keyword">index</span> ind_t_f_fid <span class="keyword">on</span> t_f(fid); </span><br><span class="line">Index created.</span><br></pre></td></tr></table></figure><p>重复上面的步骤会话1删除子表记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; delete t_f where fid = 2; </span><br><span class="line">1 row deleted.</span><br></pre></td></tr></table></figure><p>会话2删除子表记录： </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL2&gt; delete t_f where fid = 1; </span><br><span class="line">1 row deleted.</span><br></pre></td></tr></table></figure><p>会话1删除主表记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; delete t_p where id = 2; </span><br><span class="line">1 row deleted.</span><br></pre></td></tr></table></figure><p>会话2删除主表记录：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; delete t_p where id = 1; </span><br><span class="line">1 row deleted.</span><br></pre></td></tr></table></figure><p>所有的删除操作都可以成功执行，关于两种情况下锁信息的不同这里就不深入分析了，重点就是在外键列上建立索引。<br>虽然有一些文章提到过，如果满足某些情况，可以不在外键列上建立的索引，但是我的观点一向是，既然创建了外键，就不要在乎再多一个索引，因为一个索引所增加的代价，与缺失这个索引所带来的问题相比，是微不足道的。</p><hr><blockquote><p>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>聚簇索引和非聚簇索引</title>
      <link href="/p/f71a6538.html"/>
      <url>/p/f71a6538.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>聚簇索引和非聚簇索引，一向是面试常问的问题，自己也从来没搞懂过，最近在网上看到一篇文章写的很好，于是学习一下，下面主要针对Mysql数据库存储引擎来阐述。</p><hr><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>聚蔟索引与非聚蔟索引唯一的区别：就是索引和数据是否放一起。<br>MyISAM：索引和数据分两文件放，于是MyISAM的索引是非聚簇索引。<br>InnoDB：索引和数据放在一个文件中，InnoDB的索引是聚簇索引。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>单例模式的五种写法</title>
      <link href="/p/d86a7bf8.html"/>
      <url>/p/d86a7bf8.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>单例模式（Singleton Pattern）是我们最常用的一种设计模式，也是最简单的设计模式，作为后端程序员来说是必须要会的，今天我准备整理一下五种单例模式的写法。</p><hr><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>1.单例模式属于创建型模式，主要解决一个全局使用的类被频繁创建和销毁。<br>2.单例模式确保某个类只有一个实例，在计算机系统中，线程池，缓存，日志对象等常被设计成单例模式，这些应用或多或少会具有资源管理器的功能。</p><hr><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p><strong>优点：</strong><br>1.在内存中只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。<br>2.避免对资源的多重占用（比如写文件操作）。</p><p><strong>缺点：</strong><br>1.没有接口，无法继承，和单一职责原则冲突，一个类应该只关心内部的逻辑，而不关心外面怎么来实例化。</p><hr><h2 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h2><h3 id="懒汉式（线程不安全）"><a href="#懒汉式（线程不安全）" class="headerlink" title="懒汉式（线程不安全）"></a>懒汉式（线程不安全）</h3><p>所谓懒汉：<code>即懒加载：用到才初始化</code>，这种方式是最基本的实现方式，这种实现最大的问题就就是不支持多线程。在多线程的环境下可能会生成多个实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao.lhan;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉式单例的实现没有考虑线程安全问题，它是线程不安全的，并发环境下很可能出现多个Singleton实例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LHanSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LHanSingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LHanSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LHanSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LHanSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式（同步锁）"><a href="#懒汉式（同步锁）" class="headerlink" title="懒汉式（同步锁）"></a>懒汉式（同步锁）</h3><p>这种方式具备了<code>懒加载</code>，能够在多线程中很好的工作，但是效率很低，因为99%的情况下不需要同步，影响效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao.lhan;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉线程安全方式1：同步</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LHanSyncSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LHanSyncSingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LHanSyncSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LHanSyncSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LHanSyncSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉式（双重校验）"><a href="#懒汉式（双重校验）" class="headerlink" title="懒汉式（双重校验）"></a>懒汉式（双重校验）</h3><p>这种方式具备了<code>懒加载</code>，相对于上一种同步锁的方式来说，做了两次null检查，确保了只有第一次调用单例的时候才会做同步，这样也是线程安全的，同时避免了每次都同步的性能损耗。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao.lhan;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉线程安全方式2：双重检查锁定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LHanDoubleSyncSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LHanDoubleSyncSingleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LHanDoubleSyncSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LHanDoubleSyncSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LHanDoubleSyncSingleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LHanDoubleSyncSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态内部类方式"><a href="#静态内部类方式" class="headerlink" title="静态内部类方式"></a>静态内部类方式</h3><p>相对于以上两种方式，利用了classloader的机制来保证初始化instance时只有一个线程，所以也是线程安全的，同时没有性能损耗，这种方式为最佳。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao.innerclass;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类：这种比懒汉的线程安全两种方式好一点，既实现类线程安全，又避免了同步带来的性能影响</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InnerClassSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> InnerClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InnerClass.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> InnerClassSingleton instance = <span class="keyword">new</span> InnerClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>饿汉式在类创建时同时已经创建好一个静态的对象供系统使用，以后不再改变，所以天生是线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao.ehan;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉式单例类，在类初始化时，已经自行实例化</span></span><br><span class="line"><span class="comment"> * 饿汉式在类创建的同时就已经创建好一个静态的对象，以后不再改变，所有天生是线程安全的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EHanSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EHanSingleton instance = <span class="keyword">new</span> EHanSingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EHanSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EHanSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><strong>单例模式主要分为懒汉和饿汉式两种：</strong><br>1.饿汉就是类一旦加载，就把单例初始化完成，不管之后会不会使用这个实例，都会占据一定的内存，但是相应的在第一次调用时速度很快。<br>2.懒汉式只有在调用<code>getInstance()</code>的时候，才会去初始化这个单例。</p><p><strong>线程安全：</strong><br>1.饿汉式天生线程安全。<br>2.懒汉式本身不是线程安全的，为了实现线程安全有几种写法，分别是以上几种。</p><p><strong>资源加载和性能：</strong><br>1.饿汉占资源但是调用速度快，懒汉不占资源，第一次初始化调用慢。<br>2.懒汉同步性能问题：同步 &gt; 双重校验 &gt; 静态内部类。</p><hr><h2 id="案例地址"><a href="#案例地址" class="headerlink" title="案例地址"></a>案例地址</h2><p>博主编写5种单例模式和完整的单元测试，如有需要尽情clone，喜欢的话，希望能给个Star，<a href="https://github.com/Normcorer/Singleton.git" target="_blank" rel="noopener">点击此处获取本案例源码</a>。</p><hr><blockquote><p>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码质量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式和状态模式的区别</title>
      <link href="/p/5ff695a4.html"/>
      <url>/p/5ff695a4.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在学完策略模式和状态模式之后，发现两者的关系类图基本一样，这不惊让人产生疑问，既然两个设计模式命名不同，肯定是有他们的不同之处。下面记录我对这两种设计模式的理解。</p><hr><h2 id="类图结构"><a href="#类图结构" class="headerlink" title="类图结构"></a>类图结构</h2><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>该类图是根据我前面<a href="http://www.molzhao.xyz/p/13848b8b.html" target="_blank" rel="noopener">策略模式的文章</a>编写的，可以下载源码方便理解。</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-09-13/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F.jpeg" alt="策略模式"></p><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><p>状态模式理解可以看我<a href="http://www.molzhao.xyz/p/cae41fc2.html" target="_blank" rel="noopener">状态模式实现简单英雄联盟抽皮肤案例</a><br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-09-13/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.jpg" alt="状态模式"></p><hr><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p><strong>策略模式：</strong>其思想是针对一组算法，将每一种算法都封装到具有共同接口的独立的类中，从而是它们可以相互替换。策略模式的最大特点是使得算法可以在不影响客户端的情况下发生变化，从而改变不同的功能。</p><p>策略模式的Strategy类为Context定义了一系列的可供重用的算法或行为。在实践过程中，只要在分析过程中需要用到在不同时间应用不同的业务规则，就可以考虑策略模式处理这种变化的可能性。（这边要注意如果每个策略都是new出来的，在高并发的环境下使用会消耗很多内存。需要针对不同业务环境不同使用。）</p><p><strong>状态模式：</strong>允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。</p><p>状态模式主要解决的是当控制一个对象<code>状态转换</code>的条件<code>表达式</code>过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。当一个对象的行为取决于它的状态，并且它必须在<code>运行时刻</code>根据状态改变它的行为时，就可以考虑使用状态模式了。</p><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(stateful)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</p><blockquote><p>策略模式的客户端必须对所有策略类相当了解，明确当前场景下各种策略的利弊，来判断当前场景应该使用哪一种策略。策略类对客户端时暴露的。<br>状态模式依赖于其状态的变化其内部的行为发生变化，将动作委托到代表当前状态的对象，对外表现为类发生了变化。</p></blockquote><hr><blockquote><p>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码质量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode146-LRU缓存机制</title>
      <link href="/p/df7bbfb4.html"/>
      <url>/p/df7bbfb4.html</url>
      
        <content type="html"><![CDATA[<h2 id="146-LRU缓存机制"><a href="#146-LRU缓存机制" class="headerlink" title="146.LRU缓存机制"></a>146.LRU缓存机制</h2><p>Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.</p><p>get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.<br>put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</p><p>The cache is initialized with a positive capacity.</p><p>Follow up:<br>Could you do both operations in O(1) time complexity?</p><p>Example:</p><blockquote><p>LRUCache cache = new LRUCache( 2 /* capacity */ );<br><br>cache.put(1, 1);<br>cache.put(2, 2);<br>cache.get(1);       // returns  1<br>cache.put(3, 3);    // evicts key 2<br>cache.get(2);       // returns -1 (not found)<br>cache.put(4, 4);    // evicts key 1<br>cache.get(1);       // returns -1 (not found)<br>cache.get(3);       // returns 3<br>cache.get(4);       // returns 4<br><br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/lru-cache" target="_blank" rel="noopener">https://leetcode-cn.com/problems/lru-cache</a></p></blockquote><hr><h3 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h3><p>它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><ol><li>获取数据 get(key) - 如果关键字 (key) 存在于缓存中，则获取关键字的值（总是正数），否则返回 -1。</li><li>写入数据 put(key, value) - 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字/值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ol><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>自己写的比较low的方法，主要运用到了java中<code>LinkedHashMap</code>来实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao.cache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedHashMap&lt;Integer, Integer&gt; cacheMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LRUCache</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</span><br><span class="line">            Integer result = cacheMap.get(key);</span><br><span class="line">            cacheMap.remove(key);</span><br><span class="line">            cacheMap.put(key, result);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cacheMap.containsKey(key)) &#123;</span><br><span class="line">            cacheMap.remove(key);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cacheMap.size() == size) &#123;</span><br><span class="line">            Integer firstKey = cacheMap.keySet().stream().findFirst().get();</span><br><span class="line">            cacheMap.remove(firstKey);</span><br><span class="line">        &#125;</span><br><span class="line">        cacheMap.put(key, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> xyz.molzhao.cache.LRUCache;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LRUCacheTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLRUCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LRUCache cache = <span class="keyword">new</span> LRUCache(<span class="number">2</span>);</span><br><span class="line">        cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="number">1</span>));</span><br><span class="line">        cache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="number">2</span>));</span><br><span class="line">        cache.put(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">        System.out.println(cache.get(<span class="number">1</span>));</span><br><span class="line">        System.out.println(cache.get(<span class="number">3</span>));</span><br><span class="line">        System.out.println(cache.get(<span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><table><thead><tr><th>提交结果</th><th>运行时间</th><th>内存消耗</th><th>语言</th></tr></thead><tbody><tr><td>通过</td><td>26 ms</td><td>48 MB</td><td>JAVA</td></tr></tbody></table><hr><blockquote><p>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计类算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KafkaConsumer多线程实例</title>
      <link href="/p/72a88712.html"/>
      <url>/p/72a88712.html</url>
      
        <content type="html"><![CDATA[<h2 id="Kafka-Consumer多线程实例"><a href="#Kafka-Consumer多线程实例" class="headerlink" title="Kafka Consumer多线程实例"></a>Kafka Consumer多线程实例</h2><p>  Kafka 0.9版本开始推出了Java版本的consumer，优化了coordinator的设计以及摆脱了对zookeeper的依赖。社区最近也在探讨正式用这套consumer API替换Scala版本的consumer的计划。鉴于目前这方面的资料并不是很多，本文将尝试给出一个利用KafkaConsumer编写的多线程消费者实例，希望对大家有所帮助。</p><p>这套API最重要的入口就KafkaConsumer(o.a.k.clients.consumer.KafkaConsumer)，普通的单线程使用方法官网API已有介绍，这里不再赘述了。因此，我们直奔主题——讨论一下如何创建多线程的方式来使用KafkaConsumer。KafkaConsumer和KafkaProducer不同，后者是线程安全的，因此我们鼓励用户在多个线程中共享一个KafkaProducer实例，这样通常都要比每个线程维护一个KafkaProducer实例效率要高。但对于KafkaConsumer而言，它不是线程安全的。</p><hr><h2 id="实现多线程时通常由两种实现方法"><a href="#实现多线程时通常由两种实现方法" class="headerlink" title="实现多线程时通常由两种实现方法"></a>实现多线程时通常由两种实现方法</h2><p>1.每个线程维护一个KafkaConsumer</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-08-31/%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BB%B4%E6%8A%A4%E4%B8%80%E4%B8%AAConsumer.png" alt="每个线程维护一个KafkaConsumer"></p><p>2.维护一个或多个KafkaConsumer，同时维护多个事件处理线程(worker thread)</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-08-31/%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BB%B4%E6%8A%A4%E5%A4%9A%E4%B8%AA%E6%88%96%E4%B8%80%E4%B8%AAConsumer.png" alt="维护一个或多个KafkaConsumer"><br>当然，这种方法还可以有多个变种：比如每个worker线程有自己的处理队列。consumer根据某种规则或逻辑将消息放入不同的队列。不过总体思想还是相同的，故这里不做过多展开讨论了。</p><p>3.两种方式的优缺点</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>方法1(每个线程维护一个KafkaConsumer)</td><td>方便实现速度较快，因为不需要任何线程间交互。<br>易于维护分区内的消息顺序。</td><td>更多的TCP连接开销(每个线程都要维护若干个TCP连接)。<br>consumer数受限于topic分区数，扩展性差。<br>频繁请求导致吞吐量下降。<br>线程自己处理消费到的消息可能会导致超时，从而造成rebalance。</td></tr><tr><td>方法2 (单个(或多个)consumer，多个worker线程)</td><td>可独立扩展consumer数和worker数，伸缩性好</td><td>实现麻烦。<br>通常难于维护分区内的消息顺序。<br>处理链路变长，导致难以保证提交位移的语义正确性。</td></tr></tbody></table><p>下面我们分别实现这两种方法。需要指出的是，下面的代码都是最基本的实现，并没有考虑很多编程细节，比如如何处理错误等。</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p><strong><em>ConsumerRunnable类</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个线程维护私有的KafkaConsumer实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KafkaConsumer&lt;String, String&gt; consumer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumerRunnable</span><span class="params">(String brokerList, String groupId, String topic)</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, brokerList);</span><br><span class="line">        props.put(<span class="string">"group.id"</span>, groupId);</span><br><span class="line">        props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);        <span class="comment">//本例使用自动提交位移</span></span><br><span class="line">        props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>);</span><br><span class="line">        props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</span><br><span class="line">        props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        <span class="keyword">this</span>.consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(topic));   <span class="comment">// 本例使用分区副本自动分配策略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">200</span>);   <span class="comment">// 本例使用200ms作为获取超时时间</span></span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                <span class="comment">// 这里面写处理消息的逻辑，本例中只是简单地打印消息</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" consumed "</span> + record.partition() +</span><br><span class="line">                        <span class="string">"th message with offset: "</span> + record.offset());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>ConsumerGroup类</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.kafka.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ConsumerRunnable&gt; consumers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumerGroup</span><span class="params">(<span class="keyword">int</span> consumerNum, String groupId, String topic, String brokerList)</span> </span>&#123;</span><br><span class="line">        consumers = <span class="keyword">new</span> ArrayList&lt;&gt;(consumerNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumerNum; ++i) &#123;</span><br><span class="line">            ConsumerRunnable consumerThread = <span class="keyword">new</span> ConsumerRunnable(brokerList, groupId, topic);</span><br><span class="line">            consumers.add(consumerThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRunnable task : consumers) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>ConsumerMain类</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String brokerList = <span class="string">"localhost:9092"</span>;</span><br><span class="line">        String groupId = <span class="string">"testGroup1"</span>;</span><br><span class="line">        String topic = <span class="string">"test-topic"</span>;</span><br><span class="line">        <span class="keyword">int</span> consumerNum = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        ConsumerGroup consumerGroup = <span class="keyword">new</span> ConsumerGroup(consumerNum, groupId, topic, brokerList);</span><br><span class="line">        consumerGroup.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p><strong><em>Worker类</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConsumerRecord&lt;String, String&gt; consumerRecord;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(ConsumerRecord record)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.consumerRecord = record;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里写你的消息处理逻辑，本例中只是简单地打印消息</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" consumed "</span> + consumerRecord.partition()</span><br><span class="line">            + <span class="string">"th message with offset: "</span> + consumerRecord.offset());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>ConsumerHandler类</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本例中使用一个consumer将消息放入后端队列，你当然可以使用前一种方法中的多实例按照某张规则同时把消息放入后端队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KafkaConsumer&lt;String, String&gt; consumer;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService executors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumerHandler</span><span class="params">(String brokerList, String groupId, String topic)</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, brokerList);</span><br><span class="line">        props.put(<span class="string">"group.id"</span>, groupId);</span><br><span class="line">        props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);</span><br><span class="line">        props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>);</span><br><span class="line">        props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</span><br><span class="line">        props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(topic));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">int</span> workerNum)</span> </span>&#123;</span><br><span class="line">        executors = <span class="keyword">new</span> ThreadPoolExecutor(workerNum, workerNum, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1000</span>), <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> ConsumerRecord record : records) &#123;</span><br><span class="line">                executors.submit(<span class="keyword">new</span> Worker(record));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            consumer.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (executors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executors.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!executors.awaitTermination(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Timeout.... Ignore for this case"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Other thread interrupted this shutdown, ignore for this case."</span>);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>Main类</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String brokerList = <span class="string">"localhost:9092,localhost:9093,localhost:9094"</span>;</span><br><span class="line">        String groupId = <span class="string">"group2"</span>;</span><br><span class="line">        String topic = <span class="string">"test-topic"</span>;</span><br><span class="line">        <span class="keyword">int</span> workerNum = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        ConsumerHandler consumers = <span class="keyword">new</span> ConsumerHandler(brokerList, groupId, topic);</span><br><span class="line">        consumers.execute(workerNum);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">        consumers.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，这两种方法或是模型都有各自的优缺点，在具体使用时需要根据自己实际的业务特点来选取对应的方法。就我个人而言，我比较推崇第二种方法以及背后的思想，即不要将很重的处理逻辑放入消费者的代码中，很多Kafka consumer使用者碰到的各种rebalance超时、coordinator重新选举、心跳无法维持等问题都来源于此。</p><hr><blockquote><p>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 互联网架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS问题结合AtomicInteger分析</title>
      <link href="/p/969d9481.html"/>
      <url>/p/969d9481.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>公司业务渐渐要写多线程模块了，因为自己对多线程这块并不是非常了解，所以在bilibili上学习<a href="https://www.bilibili.com/video/BV1xK4y1C7aT?p=2" target="_blank" rel="noopener">马士兵老师的高并发课程</a>,以下也是听完第一节课后做的笔记。</p><hr><h2 id="CAS问题引入"><a href="#CAS问题引入" class="headerlink" title="CAS问题引入"></a>CAS问题引入</h2><p>在多线程环境下当我们使用AtmoicInteger中<code>getAndIncrement()</code>方法的当时候发现我们不需要加锁。他的源码其实时应用了CAS操作，这是一种无锁，也有人称自旋锁，也是乐观锁。</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-08-25/cas.png" alt="CAS"></p><h3 id="CAS图解"><a href="#CAS图解" class="headerlink" title="CAS图解"></a>CAS图解</h3><p>1.当一个线程进来拿到了当前值E(比如当前E是0，并将其存为N)。<br>2.开始计算，计算结果V(计算后当结果V为1)<br>3.计算完成后，比较N和E当值是否相等，如果相等就直接把E(0)值更新为V(1)。<br>如果不相等，就说明，E被其他线程改动过，如果改动之后为1，也就是当前E被改为1了，则重复上述动作，拿到当前值E(为1)，计算结果为V(2),继续比较N(1)和E….</p><h3 id="CAS存在的ABA问题"><a href="#CAS存在的ABA问题" class="headerlink" title="CAS存在的ABA问题"></a>CAS存在的ABA问题</h3><p>CAS存在ABA的问题，即一个线程A进来拿到当前值E(0),但是在修改过程中，同时两个线程进来对E进行了-1和+1的操作，由此当线程A要去比较原始值E的时候发现和当时读到的值是相同的，实际上这个E已经被两个线程修改过了，只不过修改过后的结果和最开始的E是一样的。由此引发了ABA的问题。</p><p>ABA问题的解决，通过加版本号，每次修改值E都需要改变其版本号，当比较原始值是否相同的时候同时也要比较版本号是否相同。版本号可以是多种形式(boolean、时间戳等)。</p><hr><h2 id="CAS问题AtomicInteger源码跟踪"><a href="#CAS问题AtomicInteger源码跟踪" class="headerlink" title="CAS问题AtomicInteger源码跟踪"></a>CAS问题AtomicInteger源码跟踪</h2><p>在AtomicInteger中内部是由一个int域来保存值的，其由volatile关键字修饰，用于保证可见性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>其实不只是Atomic类中使用了<code>compareAndSwap</code>方法,像<code>synchronized</code>,<code>volatile</code>底层也是这么实现的，这个等之后在看，现在我们来看看AtmoicInteger的<code>getAndIncrement()</code>的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果跟到JDK底层我们会发现他是<code>Unsafe</code>类中的一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再往下面跟，我们发现一个native修饰的方法,这就意味着这已经不是java代码实现了，是C++或C实现的，再继续跟就要跟到<code>HotSpot</code>也就是JVM的源码中去了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure><p>我们继续跟踪到Hotspot中到<code>unsafe.cpp</code>,中的实现源码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>然后继续跟踪<code>Atomic::cmpxchg(x, addr, e)</code>到<code>atomic_linux_x86.inline.hpp</code>,由于这边是linux系统所以由linux自己的实现，不同的操作系统实现不同。其中的汇编源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline jint  Atomic::cmpxchg (jint  exchange_value, volatile jint*  dest, jint  compare_value) &#123;</span><br><span class="line">    int mp &#x3D; os::is_MP();</span><br><span class="line">    __asm__ volatile (LOCK_IF_MP(%4) &quot;cmpxchgl %1,(%3)&quot;</span><br><span class="line">                    : &quot;&#x3D;a&quot; (exchange_value)</span><br><span class="line">                    : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)</span><br><span class="line">                    : &quot;cc&quot;, &quot;memory&quot;);</span><br><span class="line">    return exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>asm</strong>是汇编语言，直接和硬件打交道，我们发现<code>cmpxchg</code>语句硬件直接支持。</p><p><code>LOCK_IF_MP(%4)</code>其中的MP指的是Machine Processprs如果一个CPU是需要用<code>cmpxchg</code>就可以了,但如果多个CPU还要加前面的LOCK指令。</p><p>最终的实现：是<code>lock cmpxchg</code>指令</p><p>硬件：lock指令在执行后面指令的时候锁定一个北桥信号（不采用锁总线的方式）。</p><p><a href="https://blog.csdn.net/prstaxy/article/details/51802220?utm_source=blogxgwz7" target="_blank" rel="noopener">具体实现分析原文链接</a></p><h3 id="CAS是否真的是原子性"><a href="#CAS是否真的是原子性" class="headerlink" title="CAS是否真的是原子性"></a>CAS是否真的是原子性</h3><p>问题：如果在比较的时候，已经比较好了之后，但还没修改值之前，被其他线程修改了，那么其他线程的值会被当前值覆盖。</p><p>如果底层单单是一个<code>cmpxchg</code>指令，有多个CPU，他是不具有原子性的。但是在多个CPU的情况下，<code>LOCK</code>指令起到了关键性的作用，即一个CPU对一个值进行修改的时候，不允许其他CPU修改这个值。也是因为这个lock给cmpxchg提供了原子性。</p><hr><blockquote><p>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式实现简单英雄联盟抽皮肤案例</title>
      <link href="/p/cae41fc2.html"/>
      <url>/p/cae41fc2.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在重构这本书中，我接触到了状态模式，重构中把State/Strategy两个模式放在一起说，当时我也不太理解，因为光看类图，这两个模式真的差别不大。之后我会在写一篇博客主要讲诉这两个设计模式的区别。<br>在这篇博客中我学习了一遍状态模式，为了方便理解，写了一个简单的英雄联盟抽皮肤的小案例。案例代码我会放在Github上，在本文最后会附上地址。</p><hr><h2 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h2><p><strong>定义：</strong><br>对有<code>状态</code>的对象，把复杂的判断逻辑提取到不同的状态对象中，允许状态对象在其内部状态改变时改变其行为。主要是解决的这个对象的复杂状态的切换。</p><p><strong>优点：</strong></p><blockquote><p>1.状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。<br>2.减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。<br>3.有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>1.状态模式的使用必然会增加系统的类与对象的个数。<br>2.状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</p></blockquote><p>状态模式主要允许一个对象在其内部状态发生改变时同时改变他的行为，看起来似乎修改了它的类。我这里就不总结他的定义与特点了，下面文章总结已经很清楚了。<br><a href="http://c.biancheng.net/view/1388.html" target="_blank" rel="noopener">状态模式定义与特点原文链接</a></p><hr><h2 id="状态模式的结构"><a href="#状态模式的结构" class="headerlink" title="状态模式的结构"></a>状态模式的结构</h2><p>状态模式包含以下主要角色：</p><ol><li>环境（Context）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li><li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，根据业务需求可以写多个方法来改变当前的对象的状态。</li><li>具体状态（Concrete State）角色：实现抽象状态所对应的行为。</li></ol><p>如下是状态模式的结构：<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-08-16/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.jpg" alt="状态模式结构"></p><hr><h2 id="简单英雄联盟抽皮肤案例"><a href="#简单英雄联盟抽皮肤案例" class="headerlink" title="简单英雄联盟抽皮肤案例"></a>简单英雄联盟抽皮肤案例</h2><h3 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a>案例介绍</h3><p>以简单英雄联盟抽皮肤为例，当一个用户的操作有（充值、退款、抽奖、获得皮肤）四个状态，根据用户不同的操作状态，会有不同的行为。<br>1.在未充值状态，用户只能选择充值这个动作，另外动作均不可以选择。<br>2.在已充值这个状态，用户可以继续充值，或者选择退款，当退款额度大于用户余额的时候会提示用户，当用户把余额退完会回到未充值状态。当用户账户有余额的时候可以操作抽奖动作。<br>3.在抽奖的时候，如果扣费成功，则会生成皮肤，如果扣费失败，则会提醒用户余额不足，并且根据余额多少回到未充值或者已充值状态。<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-08-16/%E7%AE%80%E5%8D%95%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F%E6%8A%BD%E7%9A%AE%E8%82%A4%E6%B5%81%E7%A8%8B.png" alt="简单英雄联盟抽奖流程图"><br>可以看的出来每个状态的切换都伴随这很多<code>IF-ELSE</code>，如果不采用设计模式，我们在扩展功能的时候会非常麻烦。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="环境角色（Context）"><a href="#环境角色（Context）" class="headerlink" title="环境角色（Context）"></a>环境角色（Context）</h4><p>这对应的是状态模式的环境角色（Context），他维护着用户的当前状态<code>currentState</code>，定义了客户的行为方法，还提供了一个设置当前状态的方法<code>setCurrentState(UserState currentState)</code>，来方便后面状态切换时候的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zyj.domain.UserAccount;</span><br><span class="line"><span class="keyword">import</span> com.zyj.enumeration.RechargeAmountEnum;</span><br><span class="line"><span class="keyword">import</span> com.zyj.state.UserState;</span><br><span class="line"><span class="keyword">import</span> com.zyj.state.ChargedState;</span><br><span class="line"><span class="keyword">import</span> com.zyj.state.LotteryState;</span><br><span class="line"><span class="keyword">import</span> com.zyj.state.NoChargeState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkinLotteryContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前状态</span></span><br><span class="line">    UserState currentState;</span><br><span class="line">    <span class="comment">// 未充值状态</span></span><br><span class="line">    UserState noChargeState;</span><br><span class="line">    <span class="comment">// 已充值状态</span></span><br><span class="line">    UserState chargedState;</span><br><span class="line">    <span class="comment">// 抽奖中状态</span></span><br><span class="line">    UserState lotteryState;</span><br><span class="line"></span><br><span class="line">    UserAccount userAccount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SkinLotteryContext</span><span class="params">(UserAccount userAccount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取客户账户</span></span><br><span class="line">        <span class="keyword">this</span>.userAccount = userAccount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化当前状态，将当前状态设置为未充值状态</span></span><br><span class="line">        <span class="keyword">this</span>.currentState = <span class="keyword">new</span> NoChargeState(<span class="keyword">this</span>);</span><br><span class="line">        noChargeState = <span class="keyword">new</span> NoChargeState(<span class="keyword">this</span>);</span><br><span class="line">        chargedState = <span class="keyword">new</span> ChargedState(<span class="keyword">this</span>);</span><br><span class="line">        lotteryState = <span class="keyword">new</span> LotteryState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handler处理者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toCharge</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span> </span>&#123;</span><br><span class="line">        currentState.toCharge(rechargeAmountEnum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refund</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span> </span>&#123;</span><br><span class="line">        currentState.refund(rechargeAmountEnum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lottery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState.lottery();</span><br><span class="line">        <span class="comment">// 抽奖结束，自动生成皮肤</span></span><br><span class="line">        generateSkin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateSkin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState.generateSkin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState.getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(UserState currentState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState = currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">UserState <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">UserState <span class="title">getNoChargeState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> noChargeState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">UserState <span class="title">getChargedState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> chargedState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">UserState <span class="title">getLotteryState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lotteryState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象角色（State）"><a href="#抽象角色（State）" class="headerlink" title="抽象角色（State）"></a>抽象角色（State）</h4><p>这对应的是状态模式的抽象角色，他主要写了对象在不同状态下对应的行为，比如说用户的充值行为<code>toCharge()</code>,用户的退费行为<code>refund()</code>等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zyj.enumeration.RechargeAmountEnum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UserState</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是用户的操作动作。</span></span><br><span class="line"><span class="comment">     * 其实状态模式就是多条件判断的替代方案。</span></span><br><span class="line"><span class="comment">     * 在每个状态下，用户都有可能会执行下面的动作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 默认抽奖一次为5个金币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SkinLotteryContext skinLotteryContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserState</span><span class="params">(SkinLotteryContext skinLotteryContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.skinLotteryContext = skinLotteryContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 充值动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">toCharge</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span></span>;</span><br><span class="line">    <span class="comment">// 退款动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refund</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span></span>;</span><br><span class="line">    <span class="comment">// 抽奖动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lottery</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 生成皮肤动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">generateSkin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取当前状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getState</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体状态（Concrete-State）"><a href="#具体状态（Concrete-State）" class="headerlink" title="具体状态（Concrete State）"></a>具体状态（Concrete State）</h4><h5 id="未充值状态"><a href="#未充值状态" class="headerlink" title="未充值状态"></a>未充值状态</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zyj.enumeration.RechargeAmountEnum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未充值状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoChargeState</span> <span class="keyword">extends</span> <span class="title">UserState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoChargeState</span><span class="params">(SkinLotteryContext skinLotteryContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(skinLotteryContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toCharge</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为客户充值</span></span><br><span class="line">        skinLotteryContext.userAccount.charge(rechargeAmountEnum);</span><br><span class="line">        <span class="comment">// 打印余额</span></span><br><span class="line">        System.out.println(<span class="string">"您当前的余额为："</span> + skinLotteryContext.userAccount.getAmount());</span><br><span class="line">        <span class="comment">// 已经充值，转成已充值状态</span></span><br><span class="line">        skinLotteryContext.setCurrentState(skinLotteryContext.getChargedState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refund</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对不起，您当前处于未充值状态"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lottery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对不起，未充值不能进行抽奖"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateSkin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对不起，未充值不能生成皮肤"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前状态是：未充值状态"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="已充值状态"><a href="#已充值状态" class="headerlink" title="已充值状态"></a>已充值状态</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zyj.constant.LotteryConstant;</span><br><span class="line"><span class="keyword">import</span> com.zyj.enumeration.RechargeAmountEnum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已充值状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChargedState</span> <span class="keyword">extends</span> <span class="title">UserState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChargedState</span><span class="params">(SkinLotteryContext skinLotteryContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(skinLotteryContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toCharge</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为客户充值</span></span><br><span class="line">        skinLotteryContext.userAccount.charge(rechargeAmountEnum);</span><br><span class="line">        <span class="comment">// 打印余额</span></span><br><span class="line">        System.out.println(<span class="string">"您当前的余额为："</span> + skinLotteryContext.userAccount.getAmount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refund</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 客户退钱动作逻辑，在JavaBean中实现，判断余额是否充足</span></span><br><span class="line">        skinLotteryContext.userAccount.refund(rechargeAmountEnum);</span><br><span class="line">        <span class="comment">// 如果退费后当前余额为0，则返回未充值状态</span></span><br><span class="line">        <span class="keyword">if</span> (skinLotteryContext.userAccount.isEmpty()) &#123;</span><br><span class="line">            skinLotteryContext.setCurrentState(skinLotteryContext.getNoChargeState());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lottery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断用户余额是否足够一次抽奖</span></span><br><span class="line">        <span class="keyword">if</span> (skinLotteryContext.userAccount.isEnough()) &#123;</span><br><span class="line">            <span class="comment">// 减去本次抽奖的费用</span></span><br><span class="line">            skinLotteryContext.userAccount.setAmount(skinLotteryContext.userAccount.getAmount().subtract(LotteryConstant.DEFAULT_COST));</span><br><span class="line">            <span class="comment">// 设置当前状态为抽奖中的状态</span></span><br><span class="line">            skinLotteryContext.setCurrentState(skinLotteryContext.getLotteryState());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"当前账户余额不足，不能进行这次抽奖，当前余额："</span> + skinLotteryContext.userAccount.getAmount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateSkin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请在抽奖过后在进行操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前状态是：已充值状态"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="抽奖状态"><a href="#抽奖状态" class="headerlink" title="抽奖状态"></a>抽奖状态</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.RandomUtil;</span><br><span class="line"><span class="keyword">import</span> com.zyj.enumeration.RechargeAmountEnum;</span><br><span class="line"><span class="keyword">import</span> com.zyj.enumeration.SkinEnum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽奖中状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LotteryState</span> <span class="keyword">extends</span> <span class="title">UserState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LotteryState</span><span class="params">(SkinLotteryContext skinLotteryContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(skinLotteryContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toCharge</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"抽奖中，不支持充值"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refund</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"抽奖中，不支持退款"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lottery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在抽奖中，请稍等之后再点击抽奖"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateSkin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"恭喜获得皮肤："</span> + SkinEnum.getDescriptionByValue(RandomUtil.randomInt(<span class="number">0</span>, <span class="number">10</span>)) + <span class="string">", 当前余额："</span> + skinLotteryContext.userAccount.getAmount());</span><br><span class="line">        <span class="comment">//判断抽完这次之后，用户是否还有余额，如果没有返回未充值状态</span></span><br><span class="line">        <span class="keyword">if</span> (skinLotteryContext.userAccount.isEmpty()) &#123;</span><br><span class="line">            skinLotteryContext.setCurrentState(skinLotteryContext.getNoChargeState());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            skinLotteryContext.setCurrentState(skinLotteryContext.getChargedState());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前状态是：抽奖中状态"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zyj.domain.UserAccount;</span><br><span class="line"><span class="keyword">import</span> com.zyj.enumeration.RechargeAmountEnum;</span><br><span class="line"><span class="keyword">import</span> com.zyj.state.SkinLotteryContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkinLotteryClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SkinLotteryContext skinLotteryContext = <span class="keyword">new</span> SkinLotteryContext(UserAccount.generateAccount(<span class="string">"用户1"</span>));</span><br><span class="line">        skinLotteryContext.getStatus();</span><br><span class="line">        skinLotteryContext.toCharge(RechargeAmountEnum.THIRTY);</span><br><span class="line">        skinLotteryContext.getStatus();</span><br><span class="line">        <span class="comment">// 第一次退费</span></span><br><span class="line">        skinLotteryContext.refund(RechargeAmountEnum.TEN);</span><br><span class="line">        skinLotteryContext.getStatus();</span><br><span class="line">        <span class="comment">// 第二次退费</span></span><br><span class="line">        skinLotteryContext.refund(RechargeAmountEnum.TEN);</span><br><span class="line">        skinLotteryContext.getStatus();</span><br><span class="line">        <span class="comment">// 第一次抽奖</span></span><br><span class="line">        skinLotteryContext.lottery();</span><br><span class="line">        skinLotteryContext.getStatus();</span><br><span class="line">        <span class="comment">// 第二次抽奖</span></span><br><span class="line">        skinLotteryContext.lottery();</span><br><span class="line">        skinLotteryContext.getStatus();</span><br><span class="line">        <span class="comment">// 第三次抽奖</span></span><br><span class="line">        skinLotteryContext.lottery();</span><br><span class="line">        skinLotteryContext.getStatus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">当前状态是：未充值状态</span><br><span class="line">您当前的余额为：30</span><br><span class="line">当前状态是：已充值状态</span><br><span class="line">退款成功，当前客户余额：20</span><br><span class="line">当前状态是：已充值状态</span><br><span class="line">退款成功，当前客户余额：10</span><br><span class="line">当前状态是：已充值状态</span><br><span class="line">恭喜获得皮肤：脉冲火-锐雯, 当前余额：5</span><br><span class="line">当前状态是：已充值状态</span><br><span class="line">恭喜获得皮肤：霸天异形-卡兹克, 当前余额：0</span><br><span class="line">当前状态是：未充值状态</span><br><span class="line">对不起，未充值不能进行抽奖</span><br><span class="line">对不起，未充值不能生成皮肤</span><br><span class="line">当前状态是：未充值状态</span><br></pre></td></tr></table></figure><p>至于我是怎么生成皮肤的，我添加了皮肤的枚举类作为皮肤池，通过随机数随机抽取皮肤池中的皮肤实现，这样我们每增加一个皮肤只需要新增一个枚举就好了，符合开闭原则。<br>下面是我的皮肤枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SkinEnum &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参照国外LOL皮肤翻译</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FRELJORD_ASHE(<span class="number">0</span> ,<span class="string">"弗雷尔卓德-艾希"</span>),</span><br><span class="line">    MEDIEVAL_TWITCH(<span class="number">1</span> ,<span class="string">"中世纪-图奇"</span>),</span><br><span class="line">    ASSASSIN_MASTER_YI(<span class="number">2</span>, <span class="string">"刺客-易大师"</span>),</span><br><span class="line">    RECON_TEEMO(<span class="number">3</span>, <span class="string">"侦察兵-提莫"</span>),</span><br><span class="line">    FORSAKEN_JAYCE(<span class="number">4</span>, <span class="string">"被遗弃者-杰斯"</span>),</span><br><span class="line">    ROYAL_SHACO(<span class="number">5</span>, <span class="string">"皇族-萨科"</span>),</span><br><span class="line">    JAIL_BREAK_GRAVES(<span class="number">6</span>, <span class="string">"越狱-格雷福斯"</span>),</span><br><span class="line">    MIDNIGHT_AHRI(<span class="number">7</span>, <span class="string">"午夜-阿狸"</span>),</span><br><span class="line">    PULSEFIRE_RIVEN(<span class="number">8</span>, <span class="string">"脉冲火-锐雯"</span>),</span><br><span class="line">    MECHA_KHA_ZIX(<span class="number">9</span>, <span class="string">"霸天异形-卡兹克"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    SkinEnum(Integer value, String description) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDescriptionByValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(values())</span><br><span class="line">                .filter(x -&gt; x.getValue().equals(value)).findFirst().map(SkinEnum::getDescription).orElse(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SkinEnum&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(values()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="案例地址"><a href="#案例地址" class="headerlink" title="案例地址"></a>案例地址</h2><p>欢迎大家访问我的Github地址，如果喜欢的话，希望能给个Star，<a href="https://github.com/Normcorer/State-Pattern.git" target="_blank" rel="noopener">点击此处获取本案例源码</a>。</p><hr><blockquote><p>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码质量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模版方法模式见解与案例</title>
      <link href="/p/dbee4e79.html"/>
      <url>/p/dbee4e79.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近一直在看《重构–改善既有的代码设计》这本书，书中第三章的第一小节，在讲解Duplicated Code（重复代码）的时候，阐述了一种引起重复代码的情况。</p><blockquote><p>重复代码的另一种常见情况就是“两个互为兄弟的子类内含有相同的表达式”。要避免这种情况需要对两个类使用Extract Method(110)，然后使用Pull Up Method(332)，将他推入超类内。如果代码只是类似，并非完全相同，那么就得应用Extract Method(110)，将其相似和差异的部分割开，单独作为一个函数。然后你可以发现可能可以运用Form Template Method(345)，获得一个Template Method设计模式。</p></blockquote><p>因为对模版方法模式理解不是很深，所以看了一些文章总结一下。</p><h2 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h2><p><strong>定义：</strong><br>一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。本质就是固定算法骨架，让一些步骤延迟加载到子类中。</p><p><strong>优点：</strong><br>1.它将一些公有不变的部分进行封装到超类中进行实现，可变的部分可由子类继承实现，便于扩展。<br>2.提取了公有方法到超类，便于复用。<br>3.部分方法由子类实现，可以通过扩展到方式增加相应的功能，符合开闭原则。</p><p><strong>缺点：</strong><br>1.每个实现都需要定义一个子类，会导致类爆炸，系统更加庞大<br>2.超类中的抽象方法由子类实现，这是一种反向的控制结构，降低了代码的可读性。</p><hr><h2 id="角色与结构"><a href="#角色与结构" class="headerlink" title="角色与结构"></a>角色与结构</h2><h3 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h3><p>1.抽象类：负责给一个算法的骨架，它由一个模版方法和若干个基本方法组成。<br>① 模版方法：定义算法骨架，按某种顺序调用其中的方法。<br>② 基本方法：是整个算法一个步骤，包含了(抽象方法，具体方法，钩子方法)。</p><blockquote><p>抽象方法：在抽象类中申明，由具体子类实现。<br>  具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。<br>  钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p></blockquote><p>2.具体子类：实现抽象类中所定义的抽象方法和钩子方法，他们是一个顶级逻辑和一个组成步骤。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-08-12/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="模版方法模式类图"></p><hr><h2 id="学生考试案例"><a href="#学生考试案例" class="headerlink" title="学生考试案例"></a>学生考试案例</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Examination</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GetTheTestPaper();</span><br><span class="line">        answer();</span><br><span class="line">        FinishTheTestPaper();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetTheTestPaper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拿到试卷"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">answer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinishTheTestPaper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"完成试卷"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体类"><a href="#具体类" class="headerlink" title="具体类"></a>具体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentA</span> <span class="keyword">extends</span> <span class="title">Examination</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">answer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学生A的回答是：ABDC"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentB</span> <span class="keyword">extends</span> <span class="title">Examination</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">answer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学生B的回答是：ADCA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zyj.template.Examination;</span><br><span class="line"><span class="keyword">import</span> com.zyj.template.StudentA;</span><br><span class="line"><span class="keyword">import</span> com.zyj.template.StudentB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Examination studentA = <span class="keyword">new</span> StudentA();</span><br><span class="line">        Examination studentB = <span class="keyword">new</span> StudentB();</span><br><span class="line"></span><br><span class="line">        studentA.exam();</span><br><span class="line">        studentB.exam();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">拿到试卷</span><br><span class="line">学生A的回答是：ABDC</span><br><span class="line">完成试卷</span><br><span class="line">拿到试卷</span><br><span class="line">学生B的回答是：ADCA</span><br><span class="line">完成试卷</span><br></pre></td></tr></table></figure><p>这里的例子可能举的并不是很好，模版方法模式算是一个比较容易理解的设计模式，该设计模式主要用于定义模版，比如我们写论文的时候，第一步肯定要写开题报告，有一系列的流程，我们可以抽取公有的流程把他定义在模版抽象类中。然后把一些使用者不同的，让使用者自己去实现就好。</p><hr><h2 id="案例地址"><a href="#案例地址" class="headerlink" title="案例地址"></a>案例地址</h2><p>欢迎大家访问我的Github地址，如果喜欢的话，希望能给个Star，<a href="https://github.com/Normcorer/Template-Method.git" target="_blank" rel="noopener">点击此处获取本案例源码</a>。</p><hr><blockquote><p>如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码质量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单Mockito捕获mock对象方法的入参</title>
      <link href="/p/389ae027.html"/>
      <url>/p/389ae027.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实际项目中写单元测试的过程中，我们会发现需要测试的类有很多依赖，这些依赖又会有依赖，导致想要完成单元测试是一件很难的事情，为了解决这些问题，我们引入了Mock的概念，简单的说就是模拟这些资源或者依赖。<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-08-04/1148190-20171012164125840-513174531.png" alt="Mockito"></p><h2 id="Mock捕获参数的情景"><a href="#Mock捕获参数的情景" class="headerlink" title="Mock捕获参数的情景"></a>Mock捕获参数的情景</h2><p>我们在被mock的方法调用参数明确的情况下，可以无需捕获参数，但是有些情况下，比如方法没有返回值，根据不同的情景，方法需要传入不同的参数，比如说监控的错误日志，针对不同的错误，我们传入的错误日志的参数也是不同，诸多这些例子有很多。</p><h2 id="捕获一次mock方法的调用参数"><a href="#捕获一次mock方法的调用参数" class="headerlink" title="捕获一次mock方法的调用参数"></a>捕获一次mock方法的调用参数</h2><p>下面是一个简单的例子，只捕获一次调用参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    helloWorldController.hello(<span class="keyword">new</span> NullPointerException());</span><br><span class="line"></span><br><span class="line">    ArgumentCaptor&lt;User&gt; argumentCaptor = ArgumentCaptor.forClass(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    verify(helloWorldService, times(<span class="number">1</span>)).save(argumentCaptor.capture());</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="string">"zyj"</span>, argumentCaptor.getValue().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    IHelloWorldService helloWorldService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((cause <span class="keyword">instanceof</span> NullPointerException)) &#123;</span><br><span class="line">            helloWorldService.save(<span class="keyword">new</span> User(<span class="string">"zyj"</span>, <span class="number">18</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            helloWorldService.save(<span class="keyword">new</span> User(<span class="string">"zyj1"</span>, <span class="number">19</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们根据传入的不同异常，可以获取当前传入<code>save()</code>方法的参数，从而实现校验过程。<br>比如我传入NPE异常<code>argumentCaptor.getValue().getName()</code>就应该是zyj，传入<code>Exception</code>,那<code>argumentCaptor.getValue().getName()</code>的结果就是zyj1</p><h2 id="捕获多次mock方法的调用参数"><a href="#捕获多次mock方法的调用参数" class="headerlink" title="捕获多次mock方法的调用参数"></a>捕获多次mock方法的调用参数</h2><p>如果mock方法被调用多次，该如何知道每次调用时的参数呢？<code>argumentCaptor.getValue()</code> 只会返回最后一次调用的参数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    helloWorldController.hello(<span class="keyword">new</span> NullPointerException());</span><br><span class="line">    helloWorldController.hello(<span class="keyword">new</span> Exception());</span><br><span class="line"></span><br><span class="line">    ArgumentCaptor&lt;User&gt; argumentCaptor = ArgumentCaptor.forClass(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    verify(helloWorldService, times(<span class="number">2</span>)).save(argumentCaptor.capture());</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="string">"zyj1"</span>, argumentCaptor.getValue().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们手动模拟调用两次<code>hellowoldController.hello()</code>的方法，得到的结果却是最后一次的调用的返回结果，说明了<code>argumentCaptor.getValue()</code> 方法只保存最后一次调用结果。</p><p>如果我们需要获得所有的调用参数值，那该怎么做呢，Mockito给我们提供了<code>argumentCaptor.getAllValues()</code>方法，它返回的是一个<code>List&lt;T&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    helloWorldController.hello(<span class="keyword">new</span> NullPointerException());</span><br><span class="line">    helloWorldController.hello(<span class="keyword">new</span> Exception());</span><br><span class="line"></span><br><span class="line">    ArgumentCaptor&lt;User&gt; argumentCaptor = ArgumentCaptor.forClass(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    verify(helloWorldService, times(<span class="number">2</span>)).save(argumentCaptor.capture());</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; allValues = argumentCaptor.getAllValues();</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">2</span>, allValues.size());</span><br><span class="line">    assertTrue(allValues.stream().allMatch(user -&gt;</span><br><span class="line">            Arrays.asList(<span class="string">"zyj"</span>, <span class="string">"zyj1"</span>).contains(user.getName()))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>argumentCaptor.getAllValues()</code>得到的集合，如果mock方法是异步无序调用的，则可以使用Java8的新特性Stream的allMatch(),或者anyMatch()去匹配断言。如果是按顺序则直接断言即可。</p><h2 id="案例Demo"><a href="#案例Demo" class="headerlink" title="案例Demo"></a>案例Demo</h2><p><a href="https://github.com/Normcorer/MockitoDemo.git" target="_blank" rel="noopener">案例Git地址</a><br><a href="https://yanbin.blog/mockito-capture-method-paramters/#more-7737" target="_blank" rel="noopener">参考资料</a></p>]]></content>
      
      
      <categories>
          
          <category> 单元测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mockito </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式实现简单校验案例</title>
      <link href="/p/13848b8b.html"/>
      <url>/p/13848b8b.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;策略模式(Strategy Pattern)定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的用户。<br>&nbsp;&nbsp;&nbsp;&nbsp;本文展示了用策略模式实现了简单的登录校验，我会在本文最后附上本次的测试代码，有需要的小伙伴可以运行代码中的单元测试来进行理解。<br>&nbsp;&nbsp;&nbsp;&nbsp;为了校验登录的流程，我们往往需要判断用户名是否存在、密码是否正确、验证码是否正确等一系列操作，这就意味着我们的代码会有很多if-else没有扩展性，也没有复用性，如果我们想要增加一个邮箱的校验就需要，重新改if-else的代码，这意味着很容易影响到之前正确的功能。</p><h2 id="策略模式结构"><a href="#策略模式结构" class="headerlink" title="策略模式结构"></a>策略模式结构</h2><ul><li>策略（Strategy）：策略是一个接口，该接口定义算法标识。</li><li>具体策略（ConcreteStrategy）：具体策略是实现策略接口的类。具体策略实现策略接口所定义的抽象方法，即给出算法标识的具体算法。</li><li>上下文（Context）：上下文是依赖于策略接口的类，即上下文包含有策略声明的变量。上下文中提供了一个方法，该方法委托策略变量调用具体策略所实现的策略接口中的方法。</li></ul><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-07-20/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="策略模式类图"></p><h2 id="适合策略模式的情景"><a href="#适合策略模式的情景" class="headerlink" title="适合策略模式的情景"></a>适合策略模式的情景</h2><ul><li>一个类定义了多种行为，并且这些行为在这个类的方法中以多个条件语句的形式出现，那么可以使用策略模式在类中使用大量的条件语句。</li><li>程序不希望暴露复杂的、与算法有关的数据结构，可以使用策略模式来封装算法。</li></ul><h2 id="简单登录检验案例"><a href="#简单登录检验案例" class="headerlink" title="简单登录检验案例"></a>简单登录检验案例</h2><p>由于是简单实现，所以一些校验我直接写死了，需要的话可以通过查询数据库来进行替换写死的代码。</p><h3 id="策略接口"><a href="#策略接口" class="headerlink" title="策略接口"></a>策略接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVerify</span> </span>&#123;</span><br><span class="line">    <span class="function">Result <span class="title">exec</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体策略"><a href="#具体策略" class="headerlink" title="具体策略"></a>具体策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> domain.Result;</span><br><span class="line"><span class="keyword">import</span> enumeration.ResultEnum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 密码校验策略：这边简易校验一下密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordVerify</span> <span class="keyword">implements</span> <span class="title">IVerify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String access = <span class="string">"123456"</span>;</span><br><span class="line">    <span class="keyword">private</span> String passWord;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PasswordVerify</span><span class="params">(String passWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> passWord.equals(access) ? Result.sucess() : <span class="keyword">new</span> Result(ResultEnum.PASSWORD_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="策略上下文"><a href="#策略上下文" class="headerlink" title="策略上下文"></a>策略上下文</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IVerify&gt; verifyList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        verifyList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 链式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">addStrategy</span><span class="params">(IVerify verify)</span> </span>&#123;</span><br><span class="line">        verifyList.add(verify);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        verifyList.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> verifyList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> verifyList.stream().map(IVerify::exec).filter(x -&gt; x.getCode() &gt;= <span class="number">400</span>).findFirst().orElse(Result.sucess());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】这边我对策略的上下文进行了一些自定义，一般网上的策略都是单个校验，我这边通过<code>LinkedList&lt;&gt;()</code>存储策略，同时也保证了校验策略的顺序，通过java8新特性流式计算<code>stream().filter().findFirst()</code>方法来进行获取第一个检验失败的情况并返回相应的结果。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Case1: 密码不正确</span></span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.addStrategy(<span class="keyword">new</span> PasswordVerify(<span class="string">"zyj"</span>))</span><br><span class="line">                .addStrategy(<span class="keyword">new</span> ValidateVerify(<span class="string">"123456"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act</span></span><br><span class="line">        Result exec = context.exec();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert</span></span><br><span class="line">        assertEquals(ResultEnum.PASSWORD_ERROR.getValue(), exec.getCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case2：验证码不正确</span></span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        context.removeAll();</span><br><span class="line">        context.addStrategy(<span class="keyword">new</span> PasswordVerify(<span class="string">"123456"</span>))</span><br><span class="line">                .addStrategy(<span class="keyword">new</span> ValidateVerify(<span class="string">"zyj"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act</span></span><br><span class="line">        exec = context.exec();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert</span></span><br><span class="line">        assertEquals(ResultEnum.VALIDATE_ERROR.getValue(), exec.getCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case3：全部不正确,取第一个不正确的</span></span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        context.removeAll();</span><br><span class="line">        context.addStrategy(<span class="keyword">new</span> PasswordVerify(<span class="string">"zyj"</span>))</span><br><span class="line">                .addStrategy(<span class="keyword">new</span> ValidateVerify(<span class="string">"zyj"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act</span></span><br><span class="line">        exec = context.exec();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert</span></span><br><span class="line">        assertEquals(ResultEnum.PASSWORD_ERROR.getValue(), exec.getCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case4：全部正确</span></span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        context.removeAll();</span><br><span class="line">        context.addStrategy(<span class="keyword">new</span> PasswordVerify(<span class="string">"123456"</span>))</span><br><span class="line">                .addStrategy(<span class="keyword">new</span> ValidateVerify(<span class="string">"123456"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act</span></span><br><span class="line">        exec = context.exec();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert</span></span><br><span class="line">        assertEquals(ResultEnum.SUCCESS.getValue(), exec.getCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="高并发下策略模式的问题"><a href="#高并发下策略模式的问题" class="headerlink" title="高并发下策略模式的问题"></a>高并发下策略模式的问题</h2><p>这是我在生产环境下遇到的问题，首先说明一下，我们的项目是高并发环境，差不多每秒至少三四千的qps，随着业务发展这个量还会上去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.addStrategy(<span class="keyword">new</span> PasswordVerify(<span class="string">"123456"</span>))</span><br><span class="line">.addStrategy(<span class="keyword">new</span> ValidateVerify(<span class="string">"zyj"</span>));</span><br></pre></td></tr></table></figure><p>策略模式这么使用，我们会发现随着策略的增多，我们在不停的new对象，这个过程是十分影响性能，也增大了JVM的内存压力。<br>最后我们通过将策略变量set进一个类中，并在外层创建一个list保存结果（保证线程安全，让每个线程的结果都在栈中）。<br>避免过多创建对象的方法有很多，需要根据不同环境。不同使用。</p><h2 id="案例Demo"><a href="#案例Demo" class="headerlink" title="案例Demo"></a>案例Demo</h2><p><strong><a href="https://github.com/Normcorer/StrategyValidate.git" target="_blank" rel="noopener">策略模式简单登录校验案例</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码质量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库批量新增及更新效率测试</title>
      <link href="/p/255903b5.html"/>
      <url>/p/255903b5.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于最近公司业务需求，我们需要重新开发一套系统，其中需求就是需要高TPS，高性能数据库读写能力，由此我测试了Mysql，JDBC、MyBatis并且集成Kafka来做一个性能测试。由于在框架测试上的代码不能公开，这里我自己重新快速写了个Demo，具体代码和完整的测试文档我也会上传至我的Github上。</p><h2 id="JDBC效率测试"><a href="#JDBC效率测试" class="headerlink" title="JDBC效率测试"></a>JDBC效率测试</h2><h3 id="单条新增及更新"><a href="#单条新增及更新" class="headerlink" title="单条新增及更新"></a>单条新增及更新</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(driverClass);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入sql语句</span></span><br><span class="line">        StringBuilder sql = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sql.append(<span class="string">" insert into batch_test"</span> +</span><br><span class="line">                <span class="string">"(id, test_name, create_time, update_time)values(?,?,?,?)"</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> (Connection conn = DriverManager.getConnection(jdbcUrl, username, password);</span><br><span class="line">             PreparedStatement ps = conn.prepareStatement(sql.toString())) &#123;</span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">                ps.setInt(<span class="number">1</span>, i);</span><br><span class="line">                ps.setString(<span class="number">2</span>, <span class="string">"name"</span> + i);</span><br><span class="line">                ps.setDate(<span class="number">3</span>, <span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">                ps.setDate(<span class="number">4</span>, <span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">                count = count + ps.executeUpdate();</span><br><span class="line">            &#125;</span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        Long end = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 耗时</span></span><br><span class="line">        System.out.println(<span class="string">"总计插入"</span> + count + <span class="string">"条，共计耗时"</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>最后结果</strong><br>注意代码中的conn.setAutoCommit(false)，下面分别时开启自动提交和关闭自动提交的结果：</p><ul><li>开启自动提交最后结果：总计插入50000条，共计耗时61秒</li><li>关闭自动提交最后结果：总计插入50000条，共计耗时19秒</li></ul><p>同样测试单条更新的结果，由于更新和新增只是单纯的sql语句不一样，这里代码就不贴了，如有需求可以去Git上下载完整代码</p><ul><li>开启自动提交最后结果：总计单条循环更新50000条，共计耗时96秒</li><li>关闭自动提交最后结果：总计单条循环更新50000条，共计耗时26秒</li></ul><h3 id="批量新增及更新"><a href="#批量新增及更新" class="headerlink" title="批量新增及更新"></a>批量新增及更新</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(driverClass);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入sql语句</span></span><br><span class="line">        StringBuilder sql = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sql.append(<span class="string">"update batch_test set test_name = ?, create_time = ?, update_time = ? where id = ?"</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> (Connection conn = DriverManager.getConnection(jdbcUrl, username, password);</span><br><span class="line">             PreparedStatement ps = conn.prepareStatement(sql.toString())) &#123;</span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">                ps.setString(<span class="number">1</span>, <span class="string">"name"</span> + (i));</span><br><span class="line">                ps.setDate(<span class="number">2</span>, <span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">                ps.setDate(<span class="number">3</span>, <span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">                ps.setInt(<span class="number">4</span>, i);</span><br><span class="line">                ps.addBatch();</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">5000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    ps.executeBatch();</span><br><span class="line">                    conn.commit();</span><br><span class="line">                    ps.clearBatch();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ps.executeBatch();</span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        Long end = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 耗时</span></span><br><span class="line">        System.out.println(<span class="string">"总计单条循环更新"</span> + count + <span class="string">"条，共计耗时"</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>想要让批量更新的效率提高，网上也有很多答案，我这里整理了一下，大多是在jdbcUrl上做操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;allowMultiQueries&#x3D;true&amp;rewriteBatchedStatements&#x3D;true</span><br></pre></td></tr></table></figure><p>经过我一番测试&amp;rewriteBatchedStatements=true这行参数加了是真的起了效果，如下是对这个参数的介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MySQL的JDBC连接的url中要加rewriteBatchedStatements参数，并保证5.1.13以上版本的驱动，才能实现高性能的批量插入。</span><br><span class="line">MySQL的JDBC驱动在默认情况下会无视executeBatch()语句，把我们期望批量执行的一组sql语句拆散，一条一条地发给MySQL数据库，批量插入实际上是单条插入，直接造成较低的性能。</span><br><span class="line">只有把rewriteBatchedStatements参数置为true, 驱动才会帮你批量执行SQL</span><br><span class="line">另外这个选项对INSERT&#x2F;UPDATE&#x2F;DELETE都有效</span><br></pre></td></tr></table></figure><p>&amp;allowMultiQueries=true这个参数加与不加对JDBC批量更新基本无影响，他只是支持可以一次发送多条sql语句，如果不加这个参数当我们发送多条并以<code>；</code>隔开会报错，如下是官方的解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">allowMultiQueries</span><br><span class="line">Allow the use of &#39;;&#39; to delimit multiple queries during one statement (true&#x2F;false), defaults to &#39;false&#39;, and does not affect the addBatch() and executeBatch() methods, which instead rely on rewriteBatchStatements.</span><br><span class="line">Default: false</span><br><span class="line">Since version: 3.1.1</span><br></pre></td></tr></table></figure><p><strong>最后结果</strong></p><ul><li>JdbcUrl不加任何配置，总计批量循环更新50000条，共计耗时27秒</li><li>Jdbcurl加&amp;rewriteBatchedStatements=true，总计批量循环更新50000条，共计耗时3秒</li><li>jdbcurl加&amp;allowMultiQueries=true，总计批量循环更新50000条，共计耗时24秒</li><li>jdbcurl加&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true，总计批量循环更新50000条，共计耗时3秒</li></ul><hr><h2 id="Mybatis效率测试"><a href="#Mybatis效率测试" class="headerlink" title="Mybatis效率测试"></a>Mybatis效率测试</h2><h3 id="Mybatis单条更新"><a href="#Mybatis单条更新" class="headerlink" title="Mybatis单条更新"></a>Mybatis单条更新</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">single</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">            BatchTest batchTest = <span class="keyword">new</span> BatchTest(i, <span class="string">"name"</span> + i + <span class="number">4</span>, <span class="keyword">new</span> Date(), <span class="keyword">new</span> Date());</span><br><span class="line">            count = count + batchTestMapper.update(batchTest);</span><br><span class="line">        &#125;</span><br><span class="line">        Long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"总计MyBatis单条更新"</span> + count + <span class="string">"条，共计耗时"</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此处测试的是整合Mybatis测试单条更新效率，和JDBC一样我们针对不同jdbcUrl参数来进行测试<br><strong>最后结果</strong></p><ul><li>不配置JdbcUrl，最后结果：总计MyBatis单条更新50000条，共计耗时234秒。</li><li>配置&amp;rewriteBatchedStatements=true，最后结果：总计MyBatis单条更新50000条，共计耗时224秒</li><li>配置&amp;allowMultiQueries=true，最后结果：总计MyBatis单条更新50000条，共计耗时222秒</li><li>配置&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true，最后结果：总计MyBatis单条更新50000条，共计耗时228秒</li></ul><h3 id="Mybatis批量更新"><a href="#Mybatis批量更新" class="headerlink" title="Mybatis批量更新"></a>Mybatis批量更新</h3><h4 id="CASEWHEN实现批量更新"><a href="#CASEWHEN实现批量更新" class="headerlink" title="CASEWHEN实现批量更新"></a>CASEWHEN实现批量更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;BatchTest&gt; batchTestList = generateTestDate(<span class="number">50000</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            batchTestMapper.updateBatch(batchTestList);</span><br><span class="line">            Long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"总计MyBatis批量更新"</span> + <span class="number">50000</span> + <span class="string">"条，共计耗时"</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;BatchTest&gt; <span class="title">generateTestDate</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">        List&lt;BatchTest&gt; batchTestList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            BatchTest batchTest = <span class="keyword">new</span> BatchTest(i, <span class="string">"name"</span> + i + offset, <span class="keyword">new</span> Date(), <span class="keyword">new</span> Date());</span><br><span class="line">            batchTestList.add(batchTest);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> batchTestList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateBatch"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span>&gt;</span></span><br><span class="line">        update batch_test</span><br><span class="line">        SET test_name =</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">separator</span>=<span class="string">" "</span> <span class="attr">open</span>=<span class="string">"case id"</span> <span class="attr">close</span>=<span class="string">"end"</span>&gt;</span></span><br><span class="line">            when #&#123;item.id&#125; then #&#123;item.testName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        , create_time =</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">separator</span>=<span class="string">" "</span> <span class="attr">open</span>=<span class="string">"case id"</span> <span class="attr">close</span>=<span class="string">"end"</span>&gt;</span></span><br><span class="line">            when #&#123;item.id&#125; then #&#123;item.createTime&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        , update_time =</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">separator</span>=<span class="string">" "</span> <span class="attr">open</span>=<span class="string">"case id"</span> <span class="attr">close</span>=<span class="string">"end"</span>&gt;</span></span><br><span class="line">            when #&#123;item.id&#125; then #&#123;item.updateTime&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        where id in (</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">            #&#123;item.id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CASEWHEN方法实际上是把，众多更新拼接成一条sql语句，一次性提交，如果语句很长的话，效率并不理想<br><strong>最后结果</strong></p><ul><li>不配置JdbcUrl，最后结果：总计MyBatis批量更新50000条，共计耗时146秒</li><li>配置&amp;rewriteBatchedStatements=true，最后结果：总计MyBatis批量更新50000条，共计耗时144秒</li><li>配置&amp;allowMultiQueries=true，最后结果：总计MyBatis批量更新50000条，共计耗时142秒</li><li>配置&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true，最后结果：总计MyBatis批量更新50000条，共计耗时143秒</li></ul><h4 id="拼接多条SQL实现批量更新"><a href="#拼接多条SQL实现批量更新" class="headerlink" title="拼接多条SQL实现批量更新"></a>拼接多条SQL实现批量更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBatchList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;BatchTest&gt; batchTestList = generateTestDate(<span class="number">50000</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            batchTestMapper.updateBatchList(batchTestList);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"总计MyBatis批量更新"</span> + <span class="number">50000</span> + <span class="string">"条，共计耗时"</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateBatchList"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">open</span>=<span class="string">""</span> <span class="attr">close</span>=<span class="string">""</span> <span class="attr">separator</span>=<span class="string">";"</span>&gt;</span></span><br><span class="line">            update batch_test</span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"item.testName != null"</span>&gt;</span></span><br><span class="line">                test_name = #&#123;item.testName&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"item.createTime != null"</span>&gt;</span></span><br><span class="line">                create_time = #&#123;item.createTime&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"item.updateTime != null"</span>&gt;</span></span><br><span class="line">                update_time = #&#123;item.updateTime&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">            where id = #&#123;item.id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用该方法，必须在JdbcUrl后面拼接参数&amp;allowMultiQueries=true，否则将会无法运行。<br>该方法主要是将众多更新语句，用“；”隔开，拼接成多条SQL语句进行批量提交，该方法在要更新大量数据的情况下，效率客观，但是数量越多，服务卡住可能性比较高。<br><strong>最后结果</strong></p><ul><li>配置&amp;rewriteBatchedStatements=true，最后结果：总计MyBatis批量更新50000条，共计耗时25秒</li><li>配置&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true，总计MyBatis批量更新50000条，共计耗时26秒</li></ul><h4 id="开启Mybatis批处理多条SQL"><a href="#开启Mybatis批处理多条SQL" class="headerlink" title="开启Mybatis批处理多条SQL"></a>开启Mybatis批处理多条SQL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executorTypeBatchList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH, <span class="keyword">false</span>);</span><br><span class="line">        BatchTestMapper mapper = sqlSession.getMapper(BatchTestMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;BatchTest&gt; batchTestList = generateTestDate(<span class="number">50000</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mapper.updateBatchList(batchTestList);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sqlSession.commit();</span><br><span class="line">            sqlSession.close();</span><br><span class="line">            Long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"总计MyBatis批量更新"</span> + <span class="number">50000</span> + <span class="string">"条，共计耗时"</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateBatchList"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">open</span>=<span class="string">""</span> <span class="attr">close</span>=<span class="string">""</span> <span class="attr">separator</span>=<span class="string">";"</span>&gt;</span></span><br><span class="line">            update batch_test</span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"item.testName != null"</span>&gt;</span></span><br><span class="line">                test_name = #&#123;item.testName&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"item.createTime != null"</span>&gt;</span></span><br><span class="line">                create_time = #&#123;item.createTime&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"item.updateTime != null"</span>&gt;</span></span><br><span class="line">                update_time = #&#123;item.updateTime&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">            where id = #&#123;item.id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最后结果</strong></p><ul><li>配置&amp;rewriteBatchedStatements=true，最后结果：总计MyBatis批量更新50000条，共计耗时23秒</li><li>配置&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true，总计MyBatis批量更新50000条，共计耗时25秒</li></ul><hr><h2 id="多线程批量更新效率测试"><a href="#多线程批量更新效率测试" class="headerlink" title="多线程批量更新效率测试"></a>多线程批量更新效率测试</h2><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-07-05/%E5%A4%9A%E7%BA%BF%E7%A8%8B1.png" alt="多线程批量测试1"><br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-07-05/%E5%A4%9A%E7%BA%BF%E7%A8%8B2.png" alt="多线程批量测试2"><br>测试发现多线程并不是越多效率越高，多线程之所以快是因为能提高CPU的使用率，但是多线程数量多了，会导致频繁切换CPU上下文，最后就得不偿失了。<br><strong>最后结果</strong></p><ul><li>开启3个线程更新5W条，最后结果：共计耗时22秒</li><li>开启4个线程更新5W条，最后结果：共计耗时65秒</li><li>开启5个线程更新5W条，最后结果：共计耗时65秒</li><li>开启10个线程更新5W条，最后结果：共计耗时98秒</li></ul><hr><h2 id="kafka批量消费更新入库效率测试"><a href="#kafka批量消费更新入库效率测试" class="headerlink" title="kafka批量消费更新入库效率测试"></a>kafka批量消费更新入库效率测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(BatchListener<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcBatchService jdbcBatchService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener</span>(containerFactory = <span class="string">"kafkaBatchListener8"</span>, id = GlobalConstant.KAFKA_LISTENER_ID, topics = GlobalConstant.BENCHMARK_TEST_TOPIC)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records, Acknowledgment ack)</span> </span>&#123;</span><br><span class="line">        logger.warn(<span class="string">"开始时间&#123;&#125;"</span>, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        List&lt;BatchTest&gt; batchTestList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            records.forEach(record -&gt; &#123;</span><br><span class="line">                BatchTest batchTest = JSON.parseObject(record.value().toString(), BatchTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                batchTestList.add(batchTest);</span><br><span class="line">            &#125;);</span><br><span class="line">            logger.warn(jdbcBatchService.updateBatchJdbc(batchTestList) + <span class="string">"\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Kafka监听异常"</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ack.acknowledge();<span class="comment">//手动提交偏移量</span></span><br><span class="line">        &#125;</span><br><span class="line">        logger.warn(<span class="string">"结束时间&#123;&#125;"</span>, System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kafka配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">producer:</span></span><br><span class="line">      <span class="attr">bootstrap-servers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span></span><br><span class="line">      <span class="attr">batch-size:</span> <span class="number">16785</span>                                   <span class="comment">#一次最多发送数据量</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">1</span>                                          <span class="comment">#发送失败后的重复发送次数</span></span><br><span class="line">      <span class="attr">buffer-memory:</span> <span class="number">33554432</span>                             <span class="comment">#32M批处理缓冲区</span></span><br><span class="line">      <span class="attr">linger:</span> <span class="number">1</span>                                           <span class="comment">#如果不设置linger.ms，其默认值就是0，也就说即使batch不满也会发送出去。可现在设置了linger.ms，这样这些本该早就发出去的消息被迫至少等待了linger.ms时间，所以说增加了发送方的延迟</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="attr">bootstrap-servers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span></span><br><span class="line">      <span class="attr">auto-offset-reset:</span> <span class="string">earliest</span>                           <span class="comment">#最早未被消费的offset earliest</span></span><br><span class="line">      <span class="attr">max-poll-records:</span> <span class="number">10000</span>                              <span class="comment">#批量消费一次最大拉取的数据量</span></span><br><span class="line">      <span class="attr">enable-auto-commit:</span> <span class="literal">false</span>                           <span class="comment">#是否开启自动提交</span></span><br><span class="line">      <span class="attr">auto-commit-interval:</span> <span class="number">1000</span>                          <span class="comment">#自动提交的间隔时间</span></span><br><span class="line">      <span class="attr">session-timeout:</span> <span class="number">20000</span>                              <span class="comment">#连接超时时间</span></span><br><span class="line">      <span class="attr">max-poll-interval:</span> <span class="number">15000</span>                            <span class="comment">#手动提交设置与poll的心跳数,如果消息队列中没有消息，等待毫秒后，调用poll()方法。如果队列中有消息，立即消费消息，每次消费的消息的多少可以通过max.poll.records配置。</span></span><br><span class="line">      <span class="attr">max-partition-fetch-bytes:</span> <span class="number">15728640</span>                 <span class="comment">#设置拉取数据的大小,15M</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">batch-listener:</span> <span class="literal">true</span>                                <span class="comment">#是否开启批量消费，true表示批量消费</span></span><br><span class="line">      <span class="attr">concurrencys:</span> <span class="number">1</span><span class="string">,3,4,6,8</span>                                   <span class="comment">#设置消费的线程数</span></span><br><span class="line">      <span class="attr">poll-timeout:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>注意：要使用kafk批量消费，必须开启<code>batch-listener</code>属性,kafka的线程数，和他的分区数对应，有多少分区数，就能开启多少线程去消费。<br><strong>最后结果</strong><br><strong>一个Topic 4个分区 副本1</strong></p><ul><li><p>5W条 5000条为一批 单线程 4145ms </p></li><li><p>5W条 5000条为一批 三线程 1934ms </p></li><li><p>5W条 5000条为一批 四线程 2187ms </p></li><li><p>5W条 1W条为一批 单线程 5746ms </p></li><li><p>5W条 1W条为一批 三线程 3372ms </p></li><li><p>5W条 1W条为一批 四线程 2149ms </p></li><li><p>10W条 1W条为一批 单线程 14039ms</p></li><li><p>10W条 1W条为一批 三线程 6249ms </p></li><li><p>10W条 1W条为一批 四线程 4335ms </p></li></ul><p><strong>一个Topic 8个分区 副本1</strong></p><ul><li>10W条 1W条为一批 单线程 11180ms </li><li>10W条 1W条为一批 四线程 4303ms </li><li>10W条 1W条为一批 六线程 3976ms </li><li>10W条 1W条为一批 八线程 3590ms </li></ul><hr><h2 id="测试Demo地址"><a href="#测试Demo地址" class="headerlink" title="测试Demo地址"></a>测试Demo地址</h2><p><strong><a href="https://github.com/Normcorer/BenchmarkTest.git" target="_blank" rel="noopener">BenchmarkTest</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> 性能测试 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS定时任务</title>
      <link href="/p/e3889fed.html"/>
      <url>/p/e3889fed.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>crontab命令常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。该词来源于希腊语 chronos(χρνο)，原意是时间。通常，crontab储存的指令被守护进程激活， crond常常在后台运行，每一分钟检查是否有预定的作业需要执行。这类作业一般称为cron jobs。</p><p>Linux crontab是用来定期执行程序的命令。<br>当安装完成操作系统之后，默认便会启动此任务调度命令。<br>crond 命令每分锺会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</p><h2 id="crontab使用"><a href="#crontab使用" class="headerlink" title="crontab使用"></a>crontab使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line"> -u &lt;user&gt;  define user</span><br><span class="line"> -e         edit user&#39;s crontab</span><br><span class="line"> -l         list user&#39;s crontab</span><br><span class="line"> -r         delete user&#39;s crontab</span><br><span class="line"> -i         prompt before deleting</span><br><span class="line"> -n &lt;host&gt;  set host in cluster to run users&#39; crontabs</span><br><span class="line"> -c         get host in cluster to run users&#39; crontabs</span><br><span class="line"> -s         selinux context</span><br><span class="line"> -x &lt;mask&gt;  enable debugging</span><br></pre></td></tr></table></figure><ul><li>我们使用service crond status命令来查看当前定时服务是否开启</li></ul><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-30/%E6%9F%A5%E7%9C%8B%E5%AE%9A%E6%97%B6%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81.png" alt="查看定时服务状态"></p><ul><li>使用crontab -e来创建一个定时任务<br>首先我们简单的创建一个shell脚本,输出一个hello world</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello world!&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;crontab</span><br></pre></td></tr></table></figure><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-30/crontab%E5%86%99%E6%B3%95.png" alt="cron写法"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#然后输入来创建当前用户下的定时任务</span><br><span class="line">crontab -e</span><br><span class="line">#在该定时任务文件下，写入任务脚本，该任务表示每5分钟跑一次</span><br><span class="line">5 * * * * sh&#x2F;home&#x2F;sh&#x2F;helloworld.sh</span><br></pre></td></tr></table></figure><ul><li>使用crontab -l来查看当前用户下的定时任务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@zyj sh]# crontab -l</span><br><span class="line">*&#x2F;3 * * * * sh &#x2F;home&#x2F;admin&#x2F;edas-agent&#x2F;bin&#x2F;monitor.sh</span><br><span class="line">5 * * * * sh&#x2F;home&#x2F;sh&#x2F;helloworld.sh </span><br><span class="line">[root@zyj sh]#</span><br></pre></td></tr></table></figure><p>发现我们的定时任务，已经在当前用户下了</p><ul><li>具体各个用户的定时任务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@zyj sh]# cd &#x2F;var&#x2F;spool&#x2F;cron&#x2F;</span><br><span class="line">[root@zyj cron]# ls</span><br><span class="line">admin  root</span><br><span class="line">[root@zyj cron]# cat root</span><br><span class="line">*&#x2F;3 * * * * sh &#x2F;home&#x2F;admin&#x2F;edas-agent&#x2F;bin&#x2F;monitor.sh</span><br><span class="line">5 * * * * sh &#x2F;home&#x2F;sh&#x2F;helloworld.sh </span><br><span class="line">[root@zyj cron]#</span><br></pre></td></tr></table></figure><p>可以看到当前root用户下的所有定时任务，同样道理也可以看到admin的</p><ul><li>通过定时任务日志来确定定时任务是否生效</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#因为我们刚配置定时任务，需要重启服务生效</span><br><span class="line">systemctl restart crond</span><br><span class="line">#查看定时任务日志</span><br><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;cron</span><br></pre></td></tr></table></figure><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-30/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%97%A5%E5%BF%97.png" alt="定时任务日志"></p><ul><li>删除定时任务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#删除当前用户下所有的定时任务,慎用</span><br><span class="line">crontab -r</span><br><span class="line">#删除指定定时任务，删除我们不需要的定时任务即可</span><br><span class="line">crontab -e</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步阻塞IO---BIO</title>
      <link href="/p/9a526a8e.html"/>
      <url>/p/9a526a8e.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JavaBIO：同步阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-21/BIO%E7%AE%80%E5%8D%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="简单示意图"></p><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。<br><b>对BIO编程流程的梳理</b></p><ol><li>服务器点启动一个ServerSocket</li><li>客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯</li><li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝</li><li>如果有相应，客户端线程会等待请求结束后，再继续执行</li></ol><h2 id="BIO应用实例"><a href="#BIO应用实例" class="headerlink" title="BIO应用实例"></a>BIO应用实例</h2><p>实例说明：</p><ol><li>使用BIO模型编写一个服务器端，监听8888端口，当有客户端连接时，就启动一个线程与之通讯。</li><li>要求使用线程池机制改善，可以连接多个客户端</li><li>服务器端可以接受客户端发送的数据（telnet 方式即可）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ExecutorService executors = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程信息ID="</span> + Thread.currentThread().getId() + <span class="string">"名字="</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">"等待连接....."</span>);</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"连接到一个客户端"</span>);</span><br><span class="line">            <span class="comment">//创建一个线程</span></span><br><span class="line">            executors.execute(() -&gt; &#123;</span><br><span class="line">                hanlder(accept);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编写一个Hanlder和客户端通信</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanlder</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程信息ID="</span> + Thread.currentThread().getId() + <span class="string">"名字="</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket 获取一个输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="comment">//循环读取客户端发送的数</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程信息ID="</span> + Thread.currentThread().getId() + <span class="string">"名字="</span> + Thread.currentThread().getName());</span><br><span class="line">                System.out.println(<span class="string">"read......."</span>);</span><br><span class="line">                <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, read)); <span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭和Client的连接"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用WIN + R打开终端界面，开始连接我们写好的服务器<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-21/telnet%E8%BF%9E%E6%8E%A5.png" alt="telnet连接服务器"></p><p>连接好之后，按CTRL + ]进入发送字符串模式<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-21/sendmsg1.png" alt="sendMsg"></p><p>由于我们使用的是线程池，我们可以连接多个客户端，继续按上面的步骤在建立一个telnet的连接<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-21/sendmsg.png" alt="sendMsg2"><br>如下是我们的执行结果，我们可以一步骤一步骤的操作，我们可以发现线程在什么时候阻塞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;结果</span><br><span class="line">等待连接.....</span><br><span class="line">线程信息ID&#x3D;11名字&#x3D;pool-1-thread-1</span><br><span class="line">线程信息ID&#x3D;11名字&#x3D;pool-1-thread-1</span><br><span class="line">read.......</span><br><span class="line">hello world</span><br><span class="line">线程信息ID&#x3D;11名字&#x3D;pool-1-thread-1</span><br><span class="line">read.......</span><br><span class="line">连接到一个客户端</span><br><span class="line">线程信息ID&#x3D;1名字&#x3D;main</span><br><span class="line">等待连接.....</span><br><span class="line">线程信息ID&#x3D;12名字&#x3D;pool-1-thread-2</span><br><span class="line">线程信息ID&#x3D;12名字&#x3D;pool-1-thread-2</span><br><span class="line">read.......</span><br><span class="line">hello world 2</span><br><span class="line">线程信息ID&#x3D;12名字&#x3D;pool-1-thread-2</span><br><span class="line">read.......</span><br></pre></td></tr></table></figure><h2 id="BIO问题分析"><a href="#BIO问题分析" class="headerlink" title="BIO问题分析"></a>BIO问题分析</h2><ol><li>每个请求都需要建立独立的线程，与对应的客户端进行数据的Read -&gt;业务处理 -&gt; 数据Write。</li><li>当并发数较大时，需要创建大量的线程来处理连接，系统资源占用较大。</li><li>连接建立后，如果当前线程暂时没有数据可读就阻塞在Read操作上，造成线程资源的浪费</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020-06-21</title>
      <link href="/p/8d5e8318.html"/>
      <url>/p/8d5e8318.html</url>
      
        <content type="html"><![CDATA[<p>这天我们说了二十句话<br>十年来的五分之一<br>剩下没有几个十年了，我和他<br>此后余生还会突然聊起天来么</p><p>想到这里我就打开了他的朋友圈。<br>只有孤零零的一条，发于一年前的今日<br>是我入围某个文学奖的新闻<br>无人点赞。没有任何共同朋友<br>因为他是我的父亲</p><p>–文珍《鲸鱼破冰》</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-21/%E9%92%B1%E5%A1%98%E6%B1%9F.jpg" alt="生日快乐小赵"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络通信框架（2）---Mina</title>
      <link href="/p/999bcd34.html"/>
      <url>/p/999bcd34.html</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://github.com/Normcorer/MinaDemo.git" target="_blank" rel="noopener">Mina案例源码</a></strong></p><h2 id="简单的TCPServer"><a href="#简单的TCPServer" class="headerlink" title="简单的TCPServer"></a>简单的TCPServer</h2><h3 id="第一步：编写IoService"><a href="#第一步：编写IoService" class="headerlink" title="第一步：编写IoService"></a>第一步：编写IoService</h3><p>编写IoService，按照上面的执行流程，我们首先需要编写IoService，IoService 本身既是服务端，又是客户端，我们这里编写服务端，所以使用IoAcceptor 实现，由于IoAcceptor 是与协议无关的，因为我们要编写TCPServer，所以我们使用IoAcceptor 的实现NioSocketAcceptor，实际上底层就是调用java.nio.channels.ServerSocketChannel 类。当然，如果你使用了Apache 的APR 库，那么你可以选择使AprSocketAcceptor 作为TCPServer 的实现，据传说Apache APR库的性能比JVM 自带的本地库高出很多。那么IoProcessor 是由指定的IoService 内部创建并调用的，我们并不需要关心。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IoAcceptor acceptor &#x3D; new NioSocketAcceptor();</span><br><span class="line">        acceptor.getSessionConfig().setReadBufferSize(2048);</span><br><span class="line">        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置过滤器</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">&#x2F;&#x2F;设置handler</span><br><span class="line">&#x2F;&#x2F;绑定端口</span><br><span class="line">acceptor.bind(new InetSocketAddress(9124));</span><br></pre></td></tr></table></figure><p>这段代码我们初始化了服务端的TCP/IP 的基于NIO 的套接字，然后调用IoSessionConfig设置读取数据的缓冲区大小、读写通道均在10 秒内无任何操作就进入空闲状态。</p><h3 id="第二步：编写过滤器"><a href="#第二步：编写过滤器" class="headerlink" title="第二步：编写过滤器"></a>第二步：编写过滤器</h3><p>这里我们处理最简单的字符串传输，Mina 已经为我们提供了TextLineCodecFactory 编解码器工厂来对字符串进行编解码处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 编写过滤器</span><br><span class="line">acceptor.getFilterChain().addLast(&quot;codec&quot;,</span><br><span class="line">        new ProtocolCodecFilter(new TextLineCodecFactory(Charset.forName(&quot;UTF-8&quot;),</span><br><span class="line">        LineDelimiter.WINDOWS.getValue(), </span><br><span class="line">        LineDelimiter.WINDOWS.getValue())));</span><br></pre></td></tr></table></figure><p>这段代码要在acceptor.bind()方法之前执行，因为绑定套接字之后就不能再做这些准备工作了。这里先不用清楚编解码器是如何工作的，这个是后面重点说明的内容，这里你只需要清楚，我们传输的以换行符为标识的数据，所以使用了Mina 自带的换行符编解码器工厂。</p><h3 id="第三步：编写IoHandler"><a href="#第三步：编写IoHandler" class="headerlink" title="第三步：编写IoHandler"></a>第三步：编写IoHandler</h3><p>这里我们只是简单的打印Client 传说过来的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServerHandler</span> <span class="keyword">extends</span> <span class="title">IoHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里我们使用的SLF4J作为日志门面，至于为什么在后面说明。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(TCPServerHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str = message.toString();</span><br><span class="line">        System.out.println(<span class="string">"The message received is ["</span> + str + <span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">if</span> (str.endsWith(<span class="string">"quit"</span>)) &#123;</span><br><span class="line">            session.close(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server session created"</span>);</span><br><span class="line">        <span class="keyword">super</span>.sessionCreated(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server session Opened"</span>);</span><br><span class="line">        <span class="keyword">super</span>.sessionOpened(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionClosed</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server session Closed"</span>);</span><br><span class="line">        <span class="keyword">super</span>.sessionClosed(session);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们把这个IoHandler 注册到IoService：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置handler</span><br><span class="line">acceptor.setHandler(new TCPServerHandler());</span><br></pre></td></tr></table></figure><p>当然这段代码也要在acceptor.bind()方法之前执行。然后我们运行MyServer 中的main 方法，你可以看到控制台一直处于阻塞状态，等待客户端连接。<br>完成的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoAcceptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IdleStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.LineDelimiter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.TextLineCodecFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.transport.socket.nio.NioSocketAcceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        IoAcceptor acceptor = <span class="keyword">new</span> NioSocketAcceptor();</span><br><span class="line">        acceptor.getSessionConfig().setReadBufferSize(<span class="number">2048</span>);</span><br><span class="line">        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编写过滤器</span></span><br><span class="line">        acceptor.getFilterChain().addLast(<span class="string">"codec"</span>,</span><br><span class="line">                <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> TextLineCodecFactory(Charset.forName(<span class="string">"UTF-8"</span>),</span><br><span class="line">                        LineDelimiter.WINDOWS.getValue(), </span><br><span class="line">                        LineDelimiter.WINDOWS.getValue()))</span><br><span class="line">                );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置handler</span></span><br><span class="line">        acceptor.setHandler(<span class="keyword">new</span> TCPServerHandler());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//绑定端口</span></span><br><span class="line">        acceptor.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9124</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：<br>此时，我们用telnet 127.0.0.1 9123 访问，然后输入一些内容，当按下回车键，你会发现数据在Server 端被输出，但要注意不要输入中文，因为Windows 的命令行窗口不会对传输的数据进行UTF-8 编码。当输入quit 结尾的字符串时，连接被断开。这里注意你如果使用的操作系统，或者使用的Telnet 软件的换行符是什么，如果不清楚，可以删掉第二步中的两个红色的参数，使用TextLineCodec 内部的自动识别机制。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MINA集成 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.mina<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mina-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.mina<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mina-integration-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="简单的TCPClient"><a href="#简单的TCPClient" class="headerlink" title="简单的TCPClient"></a>简单的TCPClient</h2><p>这里我们实现Mina 中的TCPClient，因为前面说过无论是Server 端还是Client 端，在Mina中的执行流程都是一样的。唯一不同的就是IoService 的Client 端实现是IoConnector。</p><h3 id="第一步编写IoService并注册过滤器"><a href="#第一步编写IoService并注册过滤器" class="headerlink" title="第一步编写IoService并注册过滤器"></a>第一步编写IoService并注册过滤器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoConnector;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.LineDelimiter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.TextLineCodecFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.transport.socket.nio.NioSocketConnector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IoConnector connector = <span class="keyword">new</span> NioSocketConnector();</span><br><span class="line">        connector.setConnectTimeoutMillis(<span class="number">30000</span>);</span><br><span class="line">        connector.getFilterChain().addLast(<span class="string">"codec"</span>,</span><br><span class="line">                <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> TextLineCodecFactory(Charset.forName(<span class="string">"UTF-8"</span>),</span><br><span class="line">                        LineDelimiter.WINDOWS.getValue(), </span><br><span class="line">                        LineDelimiter.WINDOWS.getValue())));</span><br><span class="line">        </span><br><span class="line">        connector.setHandler(<span class="keyword">new</span> TCPClientHandler(<span class="string">"你好！\r\n 大家好！"</span>));</span><br><span class="line">        connector.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">9124</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二步：编写IoHandler"><a href="#第二步：编写IoHandler" class="headerlink" title="第二步：编写IoHandler"></a>第二步：编写IoHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClientHandler</span> <span class="keyword">extends</span> <span class="title">IoHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(TCPClientHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String values;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TCPClientHandler</span><span class="params">(String values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.values = values;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(IoSession session)</span> </span>&#123;</span><br><span class="line">        session.write(values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册IoHandler：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connector.setHandler(new ClientHandler(&quot;你好！\r\n 大家好！&quot;));</span><br></pre></td></tr></table></figure><p>然后我们运行MyClient，你会发现MyServer 输出如下语句：<br>The message received is [你好！]<br>The message received is [大家好！]<br>我们看到服务端是按照收到两条消息输出的，因为我们用的编解码器是以换行符判断数据是否读取完毕的。</p><h2 id="介绍Mina的TCP的主要接口"><a href="#介绍Mina的TCP的主要接口" class="headerlink" title="介绍Mina的TCP的主要接口"></a>介绍Mina的TCP的主要接口</h2><p>通过上面的两个示例，你应该对Mina 如何编写TCP/IP 协议栈的网络通信有了一些感性的认识。</p><ol><li><p>IoService：<br>这个接口是服务端IoAcceptor、客户端IoConnector 的抽象，提供IO 服务和管理IoSession的功能，它有如下几个常用的方法：</p><p> A. TransportMetadata getTransportMetadata()：<br>这个方法获取传输方式的元数据描述信息，也就是底层到底基于什么的实现，譬如：nio、apr 等。</p><p> B. void addListener(IoServiceListener listener)：<br>这个方法可以为IoService 增加一个监听器，用于监听IoService 的创建、活动、失效、空闲、销毁，具体可以参考IoServiceListener 接口中的方法，这为你参与IoService 的生命周期提供了机会。</p><p> C. void removeListener(IoServiceListener listener)：<br>这个方法用于移除上面的方法添加的监听器。</p><p> D. void setHandler(IoHandler handler)：<br>这个方法用于向IoService 注册IoHandler，同时有getHandler()方法获取Handler。</p><p> E. Map&lt;Long,IoSession&gt; getManagedSessions()：<br>这个方法获取IoService 上管理的所有IoSession，Map 的key 是IoSession 的id。</p><p> F. IoSessionConfig getSessionConfig()：<br>这个方法用于获取IoSession 的配置对象，通过IoSessionConfig 对象可以设置Socket 连接的一些选项。</p></li><li><p>IoAcceptor：<br>这个接口是TCPServer 的接口，主要增加了void bind()监听端口、void unbind()解除对套接字的监听等方法。这里与传统的JAVA 中的ServerSocket 不同的是IoAcceptor 可以多次调用bind()方法（或者在一个方法中传入多个SocketAddress 参数）同时监听多个端口。 </p></li><li><p>IoConnector：<br>这个接口是TCPClient 的接口,主要增加了ConnectFuture connect(SocketAddressremoteAddress,SocketAddress localAddress)方法，用于与Server 端建立连接，第二个参数如果不传递则使用本地的一个随机端口访问Server 端。这个方法是异步执行的，同样的，也可以同时连接多个服务端。</p></li><li><p>IoSession：<br>这个接口用于表示Server 端与Client 端的连接，IoAcceptor.accept()的时候返回实例。<br>这个接口有如下常用的方法：</p><p> A. WriteFuture write(Object message)：<br>这个方法用于写数据，该操作是异步的。</p><p> B. CloseFuture close(boolean immediately)：<br>这个方法用于关闭IoSession，该操作也是异步的，参数指定true 表示立即关闭，否则就在所有的写操作都flush 之后再关闭。</p><p> C. Object setAttribute(Object key,Object value)：<br>这个方法用于给我们向会话中添加一些属性，这样可以在会话过程中都可以使用，类似于HttpSession 的setAttrbute()方法。IoSession 内部使用同步的HashMap 存储你添加的自定义属性</p><p> D. SocketAddress getRemoteAddress()：<br>这个方法获取远端连接的套接字地址。</p><p> E. void suspendWrite()：<br>这个方法用于挂起写操作，那么有void resumeWrite()方法与之配对。对于read()方法同样适用。</p><p> F. ReadFuture read()：<br>这个方法用于读取数据， 但默认是不能使用的， 你需要调用IoSessionConfig 的setUseReadOperation(true)才可以使用这个异步读取的方法。一般我们不会用到这个方法，因为这个方法的内部实现是将数据保存到一个BlockingQueue，假如是Server 端，因为大量的Client 端发送的数据在Server 端都这么读取，那么可能会导致内存泄漏，但对于Client，可能有的时候会比较便利。</p><p> G. IoService getService()：<br>这个方法返回与当前会话对象关联的IoService 实例。<br>关于TCP连接的关闭：<br>无论在客户端还是服务端，IoSession 都用于表示底层的一个TCP 连接，那么你会发现无论是Server 端还是Client 端的IoSession 调用close()方法之后，TCP 连接虽然显示关闭， 但主线程仍然在运行，也就是JVM 并未退出，这是因为IoSession 的close()仅仅是关闭了TCP的连接通道，并没有关闭Server 端、Client 端的程序。你需要调用IoService 的dispose()方法停止Server 端、Client 端。</p></li><li><p>IoSessionConfig：<br>这个方法用于指定此次会话的配置，它有如下常用的方法：</p><p> A. void setReadBufferSize(int size)：<br>这个方法设置读取缓冲的字节数，但一般不需要调用这个方法，因为IoProcessor 会自动调整缓冲的大小。你可以调用setMinReadBufferSize()、setMaxReadBufferSize()方法，这样无论IoProcessor 无论如何自动调整，都会在你指定的区间。</p><p> B. void setIdleTime(IdleStatus status,int idleTime)：<br>这个方法设置关联在通道上的读、写或者是读写事件在指定时间内未发生，该通道就进入空闲状态。一旦调用这个方法，则每隔idleTime 都会回调过滤器、IoHandler 中的sessionIdle()方法。</p><p> C. void setWriteTimeout(int time)：<br>这个方法设置写操作的超时时间</p><p> D. void setUseReadOperation(boolean useReadOperation)：<br>这个方法设置IoSession 的read()方法是否可用，默认是false。</p></li><li><p>IoHandler：<br>这个接口是你编写业务逻辑的地方，从上面的示例代码可以看出，读取数据、发送数据基本都在这个接口总完成，这个实例是绑定到IoService 上的，有且只有一个实例（没有给一个IoService 注入一个IoHandler 实例会抛出异常）。它有如下几个方法：</p><p> A. void sessionCreated(IoSession session)：<br>这个方法当一个Session 对象被创建的时候被调用。对于TCP 连接来说，连接被接受的时候调用，但要注意此时TCP 连接并未建立，此方法仅代表字面含义，也就是连接的对象IoSession 被创建完毕的时候，回调这个方法。对于UDP 来说，当有数据包收到的时候回调这个方法，因为UDP 是无连接的。</p><p> B. void sessionOpened(IoSession session)：<br>这个方法在连接被打开时调用，它总是在sessionCreated()方法之后被调用。对于TCP 来说，它是在连接被建立之后调用，你可以在这里执行一些认证操作、发送数据等。对于UDP 来说，这个方法与sessionCreated()没什么区别，但是紧跟其后执行。如果你每隔一段时间，发送一些数据，那么sessionCreated()方法只会在第一次调用，但是sessionOpened()方法每次都会调用。</p><p> C. void sessionClosed(IoSession session) ：<br>对于TCP 来说，连接被关闭时，调用这个方法。对于UDP 来说，IoSession 的close()方法被调用时才会毁掉这个方法。</p><p> D. void sessionIdle(IoSession session, IdleStatus status) ：<br>这个方法在IoSession 的通道进入空闲状态时调用，对于UDP 协议来说，这个方法始终不会被调用。</p><p> E. void exceptionCaught(IoSession session, Throwable cause) ：<br>这个方法在你的程序、Mina 自身出现异常时回调，一般这里是关闭IoSession。</p><p> F. void messageReceived(IoSession session, Object message) ：<br>接收到消息时调用的方法，也就是用于接收消息的方法，一般情况下，message 是一个IoBuffer 类，如果你使用了协议编解码器，那么可以强制转换为你需要的类型。通常我们都是会使用协议编解码器的， 就像上面的例子， 因为协议编解码器是<br>TextLineCodecFactory，所以我们可以强制转message 为String 类型。</p><p> G. void messageSent(IoSession session, Object message) ：<br>当发送消息成功时调用这个方法，注意这里的措辞，发送成功之后，也就是说发送消息是不能用这个方法的。<br>发送消息的时机：<br>发送消息应该在sessionOpened()、messageReceived()方法中调用IoSession.write()方法完成。因为在sessionOpened()方法中，TCP 连接已经真正打开，同样的在messageReceived()方法TCP 连接也是打开状态，只不过两者的时机不同。sessionOpened()方法是在TCP 连接建立之后，接收到数据之前发送；messageReceived()方法是在接收到数据之后发送，你可以完成依据收到的内容是什么样子，决定发送什么样的数据。因为这个接口中的方法太多，因此通常使用适配器模式IoHandlerAdapter，覆盖你所感兴趣的方法即可。</p></li><li><p>IoBuffer：<br>这个接口是对JAVA NIO 的ByteBuffer 的封装，这主要是因为ByteBuffer 只提供了对基本数据类型的读写操作，没有提供对字符串等对象类型的读写方法，使用起来更为方便，另外，ByteBuffer 是定长的，如果想要可变，将很麻烦。IoBuffer 的可变长度的实现类似于StringBuffer。IoBuffer 与ByteBuffer 一样，都是非线程安全的。本节的一些内容如果不清楚，可以参考java.nio.ByteBuffer 接口。这个接口有如下常用的方法：</p><p> A. static IoBuffer allocate(int capacity,boolean useDirectBuffer)：<br>这个方法内部通过SimpleBufferAllocator 创建一个实例，第一个参数指定初始化容量，第二个参数指定使用直接缓冲区还是JAVA 内存堆的缓存区，默认为false。</p><p> B. void free()：<br>释放缓冲区，以便被一些IoBufferAllocator 的实现重用，一般没有必要调用这个方法，除非你想提升性能（但可能未必效果明显。</p><p> C. IoBuffer setAutoExpand(boolean autoExpand)：<br>这个方法设置IoBuffer 为自动扩展容量，也就是前面所说的长度可变，那么可以看出长度可变这个特性默认是不开启的。</p><p> D. IoBuffer setAutoShrink(boolean autoShrink)：<br>这个方法设置IoBuffer 为自动收缩，这样在compact()方法调用之后，可以裁减掉一些没有使用的空间。如果这个方法没有被调用或者设置为false，你也可以通过调用shrink()方法手动收缩空间。</p><p> E. IoBuffer order(ByteOrder bo)：<br>这个方法设置是Big Endian 还是Little Endian，JAVA 中默认是Big Endian，C++和其他语言一般是Little Endian。</p><p> F. IoBuffer asReadOnlyBuffer()：<br>这个方法设置IoBuffer 为只读的。</p><p> G. Boolean prefixedDataAvailable(int prefixLength,int maxDataLength)：<br>这个方法用于数据的最开始的1、2、4 个字节表示的是数据的长度的情况，<br>prefixLentgh表示这段数据的前几个字节（只能是1、2、4 的其中一个），代表的是这段数据的长度，<br>maxDataLength 表示最多要读取的字节数。返回结果依赖于等式<br>remaining()-prefixLength&gt;=maxDataLength，也就是总的数据-表示长度的字节，剩下的字节数要比打算读取的字节数大或者相等。</p><p> H. String getPrefixedString(int prefixLength,CharsetDecoder decoder)：<br>如果上面的方法返回true，那么这个方法将开始读取表示长度的字节之后的数据，注意要保持这两个方法的prefixLength 的值是一样的。</p><p> G、H 两个方法在后面讲到的PrefixedStringDecoder 中的内部实现使用。<br>IoBuffer 剩余的方法与ByteBuffer 都是差不多的，额外增加了一些便利的操作方法，例如：<br>IoBuffer putString(String value,CharsetEncoder encoder)可以方便的以指定的编码方式存储字符串、InputStream asInputStream()方法从IoBuffer 剩余的未读的数据中转为输入流等。</p></li><li><p>IoFuture：<br>在Mina 的很多操作中，你会看到返回值是XXXFuture，实际上他们都是IoFuture 的子类，看到这样的返回值，这个方法就说明是异步执行的，主要的子类有ConnectFuture、CloseFuture 、ReadFuture 、WriteFuture 。这个接口的大部分操作都和<br>java.util.concurrent.Future 接口是类似的，譬如：await()、awaitUninterruptibly()等，一般我们常用awaitUninterruptibly()方法可以等待异步执行的结果返回。这个接口有如下常用的方法：</p><p> A. IoFuture addListener(IoFutureListener<?> listener)：`这个方法用于添加一个监听器， 在异步执行的结果返回时监听器中的回调方法operationComplete(IoFuture future)，也就是说，这是替代awaitUninterruptibly()方法另一种等待异步执行结果的方法，它的好处是不会产生阻塞。` B. IoFuture removeListener(IoFutureListener<?> listener)：<br>这个方法用于移除指定的监听器。</p><p> C. IoSession getSession()：<br>这个方法返回当前的IoSession。举个例子，我们在客户端调用connect()方法访问Server 端的时候，实际上这就是一个异步执行的方法，也就是调用connect()方法之后立即返回，执行下面的代码，而不管是否连接成功。那么如果我想在连接成功之后执行一些事情（譬如：获取连接成功后的IoSession对象），该怎么办呢？按照上面的说明，你有如下两种办法：</p></li></ol><ul><li>第一种 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.future.ConnectFuture;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoConnector;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.LineDelimiter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.TextLineCodecFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.transport.socket.nio.NioSocketConnector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dxz.minademo2.TCPClientHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IoConnector connector = <span class="keyword">new</span> NioSocketConnector();</span><br><span class="line">        connector.setConnectTimeoutMillis(<span class="number">30000</span>);</span><br><span class="line">        connector.getFilterChain().addLast(<span class="string">"codec"</span>,</span><br><span class="line">                <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> TextLineCodecFactory(Charset.forName(<span class="string">"UTF-8"</span>),</span><br><span class="line">                        LineDelimiter.WINDOWS.getValue(), </span><br><span class="line">                        LineDelimiter.WINDOWS.getValue())));</span><br><span class="line">        </span><br><span class="line">        connector.setHandler(<span class="keyword">new</span> TCPClientHandler(<span class="string">"你好！\r\n 大家好！"</span>));    </span><br><span class="line">        </span><br><span class="line">        ConnectFuture future = connector.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">9124</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待是否连接成功，相当于是转异步执行为同步执行。    </span></span><br><span class="line">        future.awaitUninterruptibly();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 连接成功后获取会话对象。如果没有上面的等待，由于connect()方法是异步的，session可能会无法获取。    </span></span><br><span class="line">        IoSession session = future.getSession(); </span><br><span class="line">        System.out.println(session);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>第二种 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.future.ConnectFuture;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.future.IoFutureListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoConnector;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.LineDelimiter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.TextLineCodecFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.transport.socket.nio.NioSocketConnector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dxz.minademo2.TCPClientHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IoConnector connector = <span class="keyword">new</span> NioSocketConnector();</span><br><span class="line">        connector.setConnectTimeoutMillis(<span class="number">30000</span>);</span><br><span class="line">        connector.getFilterChain().addLast(<span class="string">"codec"</span>,</span><br><span class="line">                <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> TextLineCodecFactory(Charset.forName(<span class="string">"UTF-8"</span>),</span><br><span class="line">                        LineDelimiter.WINDOWS.getValue(), LineDelimiter.WINDOWS.getValue())));</span><br><span class="line"></span><br><span class="line">        connector.setHandler(<span class="keyword">new</span> TCPClientHandler(<span class="string">"你好！\r\n 大家好！"</span>));</span><br><span class="line">        ConnectFuture future = connector.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">9124</span>));</span><br><span class="line">        future.addListener(<span class="keyword">new</span> IoFutureListener&lt;ConnectFuture&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ConnectFuture future)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                IoSession session = future.getSession();</span><br><span class="line">                System.out.println(<span class="string">"++++++++++++++++++++++++++++"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*************</span><br><span class="line">++++++++++++++++++++++++++++</span><br></pre></td></tr></table></figure></li></ul><h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><p>前面的示例代码中提到了使用SLF4J 作为日志门面，这是<code>因为Mina 内部使用的就是SLF4J</code>，你也使用SLF4J 可以与之保持一致性。Mina 如果想启用日志跟踪Mina 的运行细节，你可以配置LoggingFilter 过滤器，这样你可以看到Session 建立、打开、空闲等一系列细节在日志中输出，默认SJF4J 是按照DEBUG级别输出跟踪信息的，如果你想给某一类别的Mina 运行信息输出指定日志输出级别，可以调用LoggingFilter 的setXXXLogLevel(LogLevel.XXX)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoggingFilter lf &#x3D; new LoggingFilter();    </span><br><span class="line">lf.setSessionOpenedLogLevel(LogLevel.ERROR);    </span><br><span class="line">acceptor.getFilterChain().addLast(&quot;logger&quot;, lf);</span><br></pre></td></tr></table></figure><p>这里IoSession 被打开的跟踪信息将以ERROR 级别输出到日志。</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>前面我们看到了LoggingFilter、ProtocolCodecFilter 两个过滤器，一个负责日志输出，一个负责数据的编解码，通过最前面的Mina 执行流程图，在IoProcessor 与IoHandler 之间可以有很多的过滤器，这种设计方式为你提供可插拔似的扩展功能提供了非常便利的方式，目前的Apache CXF、Apache Struts2 中的拦截器也都是一样的设计思路。Mina 中的IoFilter 是单例的，这与CXF、Apache Struts2 没什么区别。IoService 实例上会绑定一个DefaultIoFilterChainBuilder 实例，DefaultIoFilterChainBuilder 会把使用内部的EntryImpl 类把所有的过滤器按照顺序连在一起，组成一个过滤器链。<br>DefaultIoFilterChainBuilder 类如下常用的方法：</p><p>A. void addFirst(String name,IoFilter filter)：<br>这个方法把过滤器添加到过滤器链的头部，头部就是IoProcessor 之后的第一个过滤器。同样的addLast()方法把过滤器添加到过滤器链的尾部。</p><p>B. void addBefore(String baseName,String name,IoFilter filter)：<br>这个方法将过滤器添加到baseName 指定的过滤器的前面，同样的addAfter()方法把过滤器添加到baseName 指定的过滤器的后面。这里要注意无论是那种添加方法，每个过滤器的名字（参数name）必须是唯一的。</p><p>C. IoFilter remove(Stirng name)：<br>这个方法移除指定名称的过滤器，你也可以调用另一个重载的remove()方法，指定要移除的IoFilter 的类型。</p><p>D. List<Entry> getAll()：<br>这个方法返回当前IoService 上注册的所有过滤器。默认情况下，过滤器链中是空的，也就是getAll()方法返回长度为0 的List，但实际Mina内部有两个隐藏的过滤器：HeadFilter、TailFilter，分别在List 的最开始和最末端，很明显，TailFilter 在最末端是为了调用过滤器链之后，调用IoHandler。但这两个过滤器对你来说是透明的，可以忽略它们的存在。编写一个过滤器很简单，你需要实现IoFilter 接口，如果你只关注某几个方法，可以继承IoFilterAdapter 适配器类。IoFilter 接口中主要包含两类方法，一类是与IoHandler 中的方法名一致的方法，相当于拦截IoHandler 中的方法，另一类是IoFilter 的生命周期回调方法，这些回调方法的执行顺序和解释如下所示：</p><ol><li>init()在首次添加到链中的时候被调用，但你必须将这个IoFilter 用<br>ReferenceCountingFilter 包装起来，否则init()方法永远不会被调用。</li><li>onPreAdd()在调用添加到链中的方法时被调用，但此时还未真正的加入到链。</li><li>onPostAdd()在调用添加到链中的方法后被调，如果在这个方法中有异常抛出，则过滤器会立即被移除，同时destroy()方法也会被调用（前提是使用ReferenceCountingFilter包装）。</li><li>onPreRemove()在从链中移除之前调用。</li><li>onPostRemove()在从链中移除之后调用。</li><li>destory()在从链中移除时被调用，使用方法与init()要求相同。<br>无论是哪个方法，要注意必须在实现时调用参数nextFilter 的同名方法，否则，过滤器链的执行将被中断，IoHandler 中的同名方法一样也不会被执行，这就相当于Servlet 中的Filter 必须调用filterChain.doFilter(request,response)才能继续前进是一样的道理。<br>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.filterchain.IoFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.filterchain.IoFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IdleStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.write.WriteRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIoFilter</span> <span class="keyword">implements</span> <span class="title">IoFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%�stroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(NextFilter nextFilter, IoSession session, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%exceptionCaught"</span>);</span><br><span class="line">        nextFilter.exceptionCaught(session, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filterClose</span><span class="params">(NextFilter nextFilter, IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%filterClose"</span>);</span><br><span class="line">        nextFilter.filterClose(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filterWrite</span><span class="params">(NextFilter nextFilter, IoSession session, WriteRequest writeRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%filterWrite"</span>);</span><br><span class="line">        nextFilter.filterWrite(session, writeRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(NextFilter nextFilter, IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%messageReceived"</span>);</span><br><span class="line">        nextFilter.messageReceived(session, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageSent</span><span class="params">(NextFilter nextFilter, IoSession session, WriteRequest writeRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%messageSent"</span>);</span><br><span class="line">        nextFilter.messageSent(session, writeRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostAdd</span><span class="params">(IoFilterChain parent, String name, NextFilter nextFilter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%onPostAdd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostRemove</span><span class="params">(IoFilterChain parent, String name, NextFilter nextFilter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%onPostRemove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreAdd</span><span class="params">(IoFilterChain parent, String name, NextFilter nextFilter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%onPreAdd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreRemove</span><span class="params">(IoFilterChain parent, String name, NextFilter nextFilter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%onPreRemove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionClosed</span><span class="params">(NextFilter nextFilter, IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%sessionClosed"</span>);</span><br><span class="line">        nextFilter.sessionClosed(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(NextFilter nextFilter, IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%sessionCreated"</span>);</span><br><span class="line">        nextFilter.sessionCreated(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionIdle</span><span class="params">(NextFilter nextFilter, IoSession session, IdleStatus status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%sessionIdle"</span>);</span><br><span class="line">        nextFilter.sessionIdle(session, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(NextFilter nextFilter, IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%sessionOpened"</span>);</span><br><span class="line">        nextFilter.sessionOpened(session);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>我们将这个拦截器注册到上面的TCPServer 的IoAcceptor 的过滤器链中的最后一个：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acceptor.getFilterChain().addLast(&quot;myIoFilter&quot;, new ReferenceCountingFilter(new MyIoFilter()));</span><br></pre></td></tr></table></figure>这里我们将MyIoFilter 用ReferenceCountingFilter 包装起来，这样你可以看到init()、destroy()方法调用。我们启动客户端访问，然后关闭客户端，你会看到执行顺序如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%init</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%onPreAdd</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%onPostAdd</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%sessionCreated</span><br><span class="line">server session created</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%sessionOpened</span><br><span class="line">server session Opened</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%messageReceived</span><br><span class="line">The message received is [你好！]</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%messageReceived</span><br><span class="line">The message received is [ 大家好！]</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%sessionIdle</span><br></pre></td></tr></table></figure>IoHandler 的对应方法会跟在上面的对应方法之后执行，这也就是说从横向（单独的看一个过滤器中的所有方法的执行顺序）上看，每个过滤器的执行顺序是上面所示的顺序；从纵向（方法链的调用）上看，如果有filter1、filter2 两个过滤器，sessionCreated()方法的执行顺序如下所示：</li></ol><p>filter1-sessionCreated filter2-sessionCreated IoHandler-sessionCreated。<br>这里你要注意init、onPreAdd、onPostAdd 三个方法并不是在Server 启动时调用的，而是IoSession 对象创建之前调用的，也就是说IoFilterChain.addXXX()方法仅仅负责初始化过滤器并注册过滤器，但并不调用任何方法，包括init()初始化方法也是在IoProcessor 开始工作的时候被调用。IoFilter 是单例的，那么init()方法是否只被执行一次呢？这个是不一定的，因为IoFilter是被IoProcessor 调用的，而每个IoService 通常是关联多个IoProcessor，所以IoFilter的init()方法是在每个IoProcessor 线程上只执行一次。关于Mina 的线程问题，我们后面会详细讨论，这里你只需要清楚，init()与destroy()的调用次数与IoProceesor 的个数有关，假如一个IoService 关联了3 个IoProcessor，有五个并发的客户端请求，那么你会看到三次init()方法被调用，以后将不再会调用。Mina中自带的过滤器：<br>过滤器 说明<br>BlacklistFilter 设置一些IP 地址为黑名单，不允许访问。<br>BufferedWriteFilter 设置输出时像BufferedOutputStream 一样进行缓冲。<br>CompressionFilter 设置在输入、输出流时启用JZlib 压缩。<br>ConnectionThrottleFilter 这个过滤器指定同一个IP 地址（不含端口号）上的请求在多长的毫秒值内可以有一个请求，如果小于指定的时间间隔就有连续两个请求，那么第二个请求将被忽略（IoSession.close()）。正如Throttle 的名字一样，调节访问的频率这个过滤器最好放在过滤器链的前面。<br>FileRegionWriteFilter 如果你想使用File 对象进行输出，请使用这个过滤器。要注意，你需要使用WriteFuture 或者在<br>messageSent() 方法中关闭File 所关联的FileChannel 通道。<br>StreamWriteFilter 如果你想使用InputStream 对象进行输出，请使用这个过滤器。要注意，你需要使用WriteFuture或者在messageSent()方法中关闭File 所关联的<br>FileChannel 通道。NoopFilter 这个过滤器什么也不做，如果你想测试过滤器链是否起作用，可以用它来测试。<br>ProfilerTimerFilter 这个过滤器用于检测每个事件方法执行的时间，所以最好放在过滤器链的前面。<br>ProxyFilter 这个过滤器在客户端使用ProxyConnector 作为实现时，会自动加入到过滤器链中，用于完成代理功能。<br>RequestResponseFilter 暂不知晓。</p><p>SessionAttributeInitializingFilter 这个过滤器在IoSession 中放入一些属性（Map），通常放在过滤器的前面，用于放置一些初始化的信息。<br>MdcInjectionFilter 针对日志输出做MDC 操作，可以参考LOG4J 的MDC、NDC 的文档。<br>WriteRequestFilter CompressionFilter、RequestResponseFilter 的基类，用于包装写请求的过滤器。<br>还有一些过滤器，会在各节中详细讨论，这里没有列出，譬如：前面的LoggingFilger 日志过滤器。</p><h2 id="协议编解码器"><a href="#协议编解码器" class="headerlink" title="协议编解码器"></a>协议编解码器</h2><p>multiplex：英 [ˈmʌltɪpleks] 美 [ˈmʌltəˌplɛks] adj.多元的，多倍的，复式的;多部的，复合的，多样的，多重的;；[电讯]多路传输的n.多路;多厅影院，多剧场影剧院v.多路传输，多路复用;多重发讯<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-20/%E5%8D%8F%E8%AE%AE%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8.png" alt="协议编解码器"></p><p>前面说过，协议编解码器是在使用Mina 的时候你最需要关注的对象，因为在网络传输的数据都是二进制数据（byte），而你在程序中面向的是JAVA 对象，这就需要你实现在发送数据时将JAVA 对象编码二进制数据，而接收数据时将二进制数据解码为JAVA 对象（这个可不是JAVA 对象的序列化、反序列化那么简单的事情）。Mina 中的协议编解码器通过过滤器ProtocolCodecFilter 构造，这个过滤器的构造方法需要一个ProtocolCodecFactory，这从前面注册TextLineCodecFactory 的代码就可以看出来。<br>ProtocolCodecFactory 中有如下两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProtocolCodecFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">ProtocolEncoder <span class="title">getEncoder</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function">ProtocolDecoder <span class="title">getDecoder</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，构建一个ProtocolCodecFactory 需要ProtocolEncoder、ProtocolDecoder 两个实例。你可能要问JAVA 对象和二进制数据之间如何转换呢？这个要依据具体的通信协议，也就是Server 端要和Client 端约定网络传输的数据是什么样的格式，譬如：第一个字节表示数据长度，第二个字节是数据类型，后面的就是真正的数据（有可能是文字、有可能是图片等等），然后你可以依据长度从第三个字节向后读，直到读取到指定第一个字节指定长度的数据。<br>简单的说，HTTP 协议就是一种浏览器与Web 服务器之间约定好的通信协议，双方按照指定的协议编解码数据。我们再直观一点儿说，前面一直使用的TextLine 编解码器就是在读取网络上传递过来的数据时，只要发现哪个字节里存放的是ASCII 的10、13 字符（/r、/n），就认为之前的字节就是一个字符串（默认使用UTF-8 编码）。以上所说的就是各种协议实际上就是网络七层结构中的应用层协议，它位于网络层（IP）、传输层（TCP）之上，Mina 的协议编解码器就是让你实现一套自己的应用层协议栈。</p><h3 id="简单编解码器示例"><a href="#简单编解码器示例" class="headerlink" title="简单编解码器示例"></a>简单编解码器示例</h3><p>下面我们举一个模拟电信运营商短信协议的编解码器实现，假设通信协议如下所示：<br>M sip:wap.fetion.com.cn SIP-C/2.0<br>S: 1580101xxxx<br>R: 1889020xxxx</p><p>L: 21<br>Hello World!<br>这里的第一行表示状态行，一般表示协议的名字、版本号等，第二行表示短信的发送号码，第三行表示短信接收的号码，第四行表示短信的字节数，最后的内容就是短信的内容。上面的每一行的末尾使用ASC II 的10（/n）作为换行符，因为这是纯文本数据，协议要<br>求双方使用UTF-8 对字符串编解码。实际上如果你熟悉HTTP 协议，上面的这个精简的短信协议和HTTP 协议的组成是非常像的，第一行是状态行，中间的是消息报头，最后面的是消息正文。在解析这个短信协议之前，你需要知晓TCP 的一个事项，那就是数据的发送没有规模性，所谓的规模性就是作为数据的接收端，不知道到底什么时候数据算是读取完毕，所以应用层协议在制定的时候，必须指定数据读取的截至点。一般来说，有如下三种方式设置数据读取的长度：</p><ol><li>使用分隔符，譬如：TextLine 编解码器。你可以使用/r、/n、NUL 这些ASC II 中的特殊的字符来告诉数据接收端，你只要遇见分隔符，就表示数据读完了，不用在那里傻等着不知道还有没有数据没读完啊？我可不可以开始把已经读取到的字节解码为指定的数据类型了啊？</li><li>定长的字节数，这种方式是使用长度固定的数据发送，一般适用于指令发送，譬如：数据发送端规定发送的数据都是双字节，AA 表示启动、BB 表示关闭等等。</li><li>在数据中的某个位置使用一个长度域，表示数据的长度，这种处理方式最为灵活，上面的短信协议中的那个L 就是短信文字的字节数，其实HTTP 协议的消息报头中的Content-Length 也是表示消息正文的长度，这样数据的接收端就知道我到底读到多长的<br>字节数就表示不用再读取数据了。相比较解码（字节转为JAVA 对象，也叫做拆包）来说，编码（JAVA 对象转为字节，也叫做打包）就很简单了，你只需要把JAVA 对象转为指定格式的字节流，write()就可以了。下面我们开始对上面的短信协议进行编解码处理。</li></ol><ul><li>第一步，协议对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String sender;<span class="comment">// 短信发送者</span></span><br><span class="line">    <span class="keyword">private</span> String receiver;<span class="comment">// 短信接受者</span></span><br><span class="line">    <span class="keyword">private</span> String message;<span class="comment">// 短信内容</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSender</span><span class="params">(String sender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sender = sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReceiver</span><span class="params">(String receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>第二步，编码器：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.buffer.IoBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolEncoderAdapter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolEncoderOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CmccSipcEncoder</span> <span class="keyword">extends</span> <span class="title">ProtocolEncoderAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Charset charset;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CmccSipcEncoder</span><span class="params">(Charset charset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.charset = charset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(IoSession session, Object message, ProtocolEncoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SmsObject sms = (SmsObject) message;</span><br><span class="line">        CharsetEncoder ce = charset.newEncoder();</span><br><span class="line">        IoBuffer buffer = IoBuffer.allocate(<span class="number">100</span>).setAutoExpand(<span class="keyword">true</span>);</span><br><span class="line">        String statusLine = <span class="string">"M sip:wap.fetion.com.cn SIP-C/2.0"</span>;</span><br><span class="line">        String sender = sms.getSender();</span><br><span class="line">        String receiver = sms.getReceiver();</span><br><span class="line">        String smsContent = sms.getMessage();</span><br><span class="line">        buffer.putString(statusLine + <span class="string">'\n'</span>, ce);</span><br><span class="line">        buffer.putString(<span class="string">"S: "</span> + sender + <span class="string">'\n'</span>, ce);</span><br><span class="line">        buffer.putString(<span class="string">"R: "</span> + receiver + <span class="string">'\n'</span>, ce);</span><br><span class="line">        buffer.putString(<span class="string">"L: "</span> + (smsContent.getBytes(charset).length) + <span class="string">"\n"</span>, ce);</span><br><span class="line">        buffer.putString(smsContent, ce);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        out.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这里我们依据传入的字符集类型对message 对象进行编码，编码的方式就是按照短信协议拼装字符串到IoBuffer 缓冲区，然后调用ProtocolEncoderOutput 的write()方法输出字节流。这里要注意生成短信内容长度时的红色代码，我们使用String 类与Byte[]类型之间的转换方法获得转为字节流后的字节数。<br>编码器的编写有以下几个步骤：</li></ul><ol><li>将 encode()方法中的message 对象强制转换为指定的对象类型；</li><li>创建IoBuffer 缓冲区对象，并设置为自动扩展；</li><li>将转换后的message 对象中的各个部分按照指定的应用层协议进行组装，并put()到IoBuffer 缓冲区；</li><li>当你组装数据完毕之后，调用flip()方法，为输出做好准备，切记在write()方法之前，要调用IoBuffer 的flip()方法，否则缓冲区的position 的后面是没有数据可以用来输出的，你必须调用flip()方法将position 移至0，limit 移至刚才的position。这个flip()方法的含义请参看java.nio.ByteBuffer。</li><li>最后调用ProtocolEncoderOutput 的write()方法输出IoBuffer 缓冲区实例。</li></ol><ul><li>第三步，解码器：<br>在Mina 中编写解码器，可以实现ProtocolDecoder 接口，其中有decode()、finishDecode()、dispose()三个方法。这里的finishDecode()方法可以用于处理在IoSession 关闭时剩余的未读取数据，一般这个方法并不会被使用到，除非协议中未定义任何标识数据什么时候截止的约定，譬如：Http 响应的Content-Length 未设定，那么在你认为读取完数据后，关闭TCP连接（IoSession 的关闭）后，就可以调用这个方法处理剩余的数据，当然你也可以忽略调剩余的数据。同样的，一般情况下，我们只需要继承适配器ProtocolDecoderAdapter，关注decode()方法即可。但前面说过解码器相对编码器来说，最麻烦的是数据发送过来的规模，以聊天室为例，一个TCP 连接建立之后，那么隔一段时间就会有聊天内容发送过来，也就是decode()方法会被往复调用，这样处理起来就会非常麻烦。<code>那么Mina 中幸好提供了CumulativeProtocolDecoder类，从名字上可以看出累积性的协议解码器</code>，也就是说只要有数据发送过来，这个类就会去读取数据，然后累积到内部的IoBuffer 缓冲区，但是具体的拆包（把累积到缓冲区的数据解码为JAVA 对象）交由子类的doDecode()方法完成，实际上CumulativeProtocolDecoder就是在decode()反复的调用暴漏给子类实现的doDecode()方法。<br>具体执行过程如下所示：</li></ul><ol><li>你的doDecode()方法返回true 时，CumulativeProtocolDecoder 的decode()方法会首先判断你是否在doDecode()方法中从内部的IoBuffer 缓冲区读取了数据，如果没有，则会抛出非法的状态异常，也就是你的doDecode()方法返回true 就表示你已经消费了本次数据（相当于聊天室中一个完整的消息已经读取完毕），进一步说，也就是此时你必须已经消费过内部的IoBuffer 缓冲区的数据（哪怕是消费了一个字节的数据）。如果验证过通过，那么CumulativeProtocolDecoder 会检查缓冲区内是否还有数据未读取，如果有就继续调用doDecode()方法，没有就停止对doDecode()方法的调用，直到有新的数据被缓冲。</li><li>当你的doDecode()方法返回false 时，CumulativeProtocolDecoder 会停止对doDecode()方法的调用，<code>但此时如果本次数据还有未读取完的，就将含有剩余数据的IoBuffer 缓冲区保存到IoSession 中，以便下一次数据到来时可以从IoSession 中提取合并。</code>如果发现本次数据全都读取完毕，则清空IoBuffer 缓冲区。简而言之，当你认为读取到的数据已经够解码了，那么就返回true，否则就返回false。<code>这个CumulativeProtocolDecoder 其实最重要的工作就是帮你完成了数据的累积，因为这个工作是很烦琐的。</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.buffer.IoBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.CumulativeProtocolDecoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolDecoderOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CmccSipcDecoder</span> <span class="keyword">extends</span> <span class="title">CumulativeProtocolDecoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Charset charset;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CmccSipcDecoder</span><span class="params">(Charset charset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.charset = charset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doDecode</span><span class="params">(IoSession session, IoBuffer in, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        IoBuffer buffer = IoBuffer.allocate(<span class="number">100</span>).setAutoExpand(<span class="keyword">true</span>);</span><br><span class="line">        CharsetDecoder cd = charset.newDecoder();</span><br><span class="line">        <span class="keyword">int</span> matchCount = <span class="number">0</span>;</span><br><span class="line">        String statusLine = <span class="string">""</span>, sender = <span class="string">""</span>, receiver = <span class="string">""</span>, length = <span class="string">""</span>, sms = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (in.hasRemaining()) &#123;</span><br><span class="line">            <span class="keyword">byte</span> b = in.get();</span><br><span class="line">            buffer.put(b);</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">10</span> &amp;&amp; i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                matchCount++;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    statusLine = buffer.getString(matchCount, cd);</span><br><span class="line">                    statusLine = statusLine.substring(<span class="number">0</span>, statusLine.length() - <span class="number">1</span>);</span><br><span class="line">                    matchCount = <span class="number">0</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    sender = buffer.getString(matchCount, cd);</span><br><span class="line">                    sender = sender.substring(<span class="number">0</span>, sender.length() - <span class="number">1</span>);</span><br><span class="line">                    matchCount = <span class="number">0</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    receiver = buffer.getString(matchCount, cd);</span><br><span class="line">                    receiver = receiver.substring(<span class="number">0</span>, receiver.length() - <span class="number">1</span>);</span><br><span class="line">                    matchCount = <span class="number">0</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    length = buffer.getString(matchCount, cd);</span><br><span class="line">                    length = length.substring(<span class="number">0</span>, length.length() - <span class="number">1</span>);</span><br><span class="line">                    matchCount = <span class="number">0</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                matchCount++;</span><br><span class="line">                <span class="keyword">if</span> (matchCount == Long.parseLong(length.split(<span class="string">": "</span>)[<span class="number">1</span>])) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    sms = buffer.getString(matchCount, cd);</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                matchCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        SmsObject smsObject = <span class="keyword">new</span> SmsObject();</span><br><span class="line">        smsObject.setSender(sender.split(<span class="string">": "</span>)[<span class="number">1</span>]);</span><br><span class="line">        smsObject.setReceiver(receiver.split(<span class="string">": "</span>)[<span class="number">1</span>]);</span><br><span class="line">        smsObject.setMessage(sms);</span><br><span class="line">        out.write(smsObject);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>我们的这个短信协议解码器使用/n（ASCII 的10 字符）作为分解点，一个字节一个字节的读取，那么第一次发现/n 的字节位置之前的部分，必然就是短信协议的状态行，依次类推，你就可以解析出来发送者、接受者、短信内容长度。然后我们在解析短信内容时，使用获取到的长度进行读取。全部读取完毕之后， 然后构造SmsObject 短信对象， 使用ProtocolDecoderOutput 的write()方法输出，最后返回false，也就是本次数据全部读取完毕，告知CumulativeProtocolDecoder 在本次数据读取中不需要再调用doDecode()方法了。这里需要注意的是两个状态变量i、matchCount，i 用于记录解析到了短信协议中的哪一行（/n），matchCount 记录在当前行中读取到了哪一个字节。状态变量在解码器中经常被使用，我们这里的情况比较简单，因为我们假定短信发送是在一次数据发送中完成的，所以状态变量的使用也比较简单。假如数据的发送被拆成了多次（譬如：短信协议的短信内容、消息报头被拆成了两次数据发送），那么上面的代码势必就会存在问题，因为当第二次调用doDecode()方法时，状态变量i、matchCount 势必会被重置，也就是原来的状态值并没有被保存。那么我们如何解决状态保存的问题呢？答案就是将状态变量保存在IoSession 中或者是Decoder 实例自身，但推荐使用前者，因为虽然Decoder 是单例的，其中的实例变量保存的状态在Decoder 实例销毁前始终保持，但Mina 并不保证每次调用doDecode()方法时都是同一个线程（这也就是说第一次调用doDecode()是IoProcessor-1 线程，第二次有可能就是IoProcessor-2 线程），这就会产生多线程中的实例变量的可视性（Visibility，具体请参考JAVA 的多线程知识）问题。IoSession中使用一个同步的HashMap 保存对象，所以你不需要担心多线程带来的问题。使用IoSession 保存解码器的状态变量通常的写法如下所示：</li><li>在解码器中定义私有的内部类Context，然后将需要保存的状态变量定义在Context 中存储。</li><li>在解码器中定义方法获取这个Context 的实例，这个方法的实现要优先从IoSession 中获取Context。<br>具体代码示例如下所示：<br>// 上下文作为保存状态的内部类的名字，意思很明显，就是让状态跟随上下文，在整个调用过程中都可以被保持。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.buffer.IoBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.AttributeKey;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.CumulativeProtocolDecoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolDecoderOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXDecoder</span> <span class="keyword">extends</span> <span class="title">CumulativeProtocolDecoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AttributeKey CONTEXT = <span class="keyword">new</span> AttributeKey(getClass(), <span class="string">"context"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">getContext</span><span class="params">(IoSession session)</span> </span>&#123;</span><br><span class="line">        Context ctx = (Context) session.getAttribute(CONTEXT);</span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ctx = <span class="keyword">new</span> Context();</span><br><span class="line">            session.setAttribute(CONTEXT, ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 状态变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doDecode</span><span class="params">(IoSession session, IoBuffer in, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意这里我们使用了Mina 自带的AttributeKey 类来定义保存在IoSession 中的对象的键值，这样可以有效的防止键值重复。另外，要注意在全部处理完毕之后，状态要复位，譬如：聊天室中的一条消息读取完毕之后，状态变量要变为初始值，以便下次处理时重新使用。</li></ol><ul><li>第四步，编解码工厂：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolDecoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CmccSipcCodecFactory</span> <span class="keyword">implements</span> <span class="title">ProtocolCodecFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CmccSipcEncoder encoder;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CmccSipcDecoder decoder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CmccSipcCodecFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Charset.defaultCharset());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CmccSipcCodecFactory</span><span class="params">(Charset charSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.encoder = <span class="keyword">new</span> CmccSipcEncoder(charSet);</span><br><span class="line">        <span class="keyword">this</span>.decoder = <span class="keyword">new</span> CmccSipcDecoder(charSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProtocolDecoder <span class="title">getDecoder</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProtocolEncoder <span class="title">getEncoder</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> encoder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>实际上这个工厂类就是包装了编码器、解码器，通过接口中的getEncoder()、getDecoder()方法向ProtocolCodecFilter 过滤器返回编解码器实例，以便在过滤器中对数据进行编解码处理。<br>第五步，运行示例：<br>下面我们修改最一开始的示例中的MyServer、MyClient 的代码，如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoAcceptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IdleStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.LineDelimiter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.TextLineCodecFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.util.ReferenceCountingFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.transport.socket.nio.NioSocketAcceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dxz.minademo2.TCPServerHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        IoAcceptor acceptor = <span class="keyword">new</span> NioSocketAcceptor();</span><br><span class="line">        acceptor.getSessionConfig().setReadBufferSize(<span class="number">2048</span>);</span><br><span class="line">        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编写过滤器</span></span><br><span class="line"></span><br><span class="line">        acceptor.getFilterChain().addLast(<span class="string">"codec"</span>,</span><br><span class="line">                <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> CmccSipcCodecFactory(Charset.forName(<span class="string">"UTF-8"</span>))));</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置handler</span></span><br><span class="line">        acceptor.getFilterChain().addLast(<span class="string">"myIoFilter"</span>, <span class="keyword">new</span> ReferenceCountingFilter(<span class="keyword">new</span> MyIoFilter()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置handler</span></span><br><span class="line">        acceptor.setHandler(<span class="keyword">new</span> TCPServerHandler());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定端口</span></span><br><span class="line">        acceptor.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9124</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(acceptor.getSessionConfig());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>client<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.future.ConnectFuture;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.future.IoFutureListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoConnector;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.LineDelimiter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.TextLineCodecFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.transport.socket.nio.NioSocketConnector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dxz.minademo2.TCPClientHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IoConnector connector = <span class="keyword">new</span> NioSocketConnector();</span><br><span class="line">        connector.setConnectTimeoutMillis(<span class="number">30000</span>);</span><br><span class="line"></span><br><span class="line">        connector.getFilterChain().addLast(<span class="string">"codec"</span>,</span><br><span class="line">                <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> CmccSipcCodecFactory(Charset.forName(<span class="string">"UTF-8"</span>))));</span><br><span class="line"></span><br><span class="line">        connector.setHandler(<span class="keyword">new</span> TCPClientHandler(<span class="string">"你好！\r\n 大家好！"</span>));</span><br><span class="line">        ConnectFuture future = connector.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">9124</span>));</span><br><span class="line">        future.addListener(<span class="keyword">new</span> IoFutureListener&lt;ConnectFuture&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ConnectFuture future)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                IoSession session = future.getSession();</span><br><span class="line">                System.out.println(<span class="string">"++++++++++++++++++++++++++++"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>最后我们在ClientHandler中发送这条短信息：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void sessionOpened(IoSession ioSession) throws Exception &#123;</span><br><span class="line">        SmsObject sm &#x3D; new SmsObject();</span><br><span class="line">        sm.setMessage(&quot;hemaceshi&quot;);</span><br><span class="line">        sm.setReceiver(&quot;1799999999&quot;);</span><br><span class="line">        sm.setSender(&quot;17888888888&quot;);</span><br><span class="line">        ioSession.write(sm);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>在ServerHanlder中接收这条信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void messageReceived(IoSession ioSession, Object message) throws Exception &#123;</span><br><span class="line">        SmsObject sm &#x3D; (SmsObject) message;</span><br><span class="line">        ioSession.write(sm);</span><br><span class="line">        System.out.println(sm.getMessage());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>你会看到Server 端的控制台输出如下信息：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-%%%%%%%%%%%%%%%%%%%%%%%%%%%messageReceived</span><br><span class="line">The message received is [hemaceshi]</span><br><span class="line">-----------------messageReceived</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%filterWrite</span><br><span class="line">hemaceshi</span><br></pre></td></tr></table></figure></li></ul><h3 id="复杂解码器"><a href="#复杂解码器" class="headerlink" title="复杂解码器"></a>复杂解码器</h3><p>下面我们讲解一下如何在解码器中保存状态变量，也就是真正的实现上面所说的Context。<br>我们假设这样一种情况，有两条短信：<br>M sip:wap.fetion.com.cn SIP-C/2.0<br>S: 1580101xxxx<br>R: 1889020xxxx<br>L: 21<br>Hello World!<br>M sip:wap.fetion.com.cn SIP-C/2.0<br>S: 1580101xxxx<br>R: 1889020xxxx<br>L: 21<br>Hello World!<br>他们按照上面的颜色标识发送，也就是说红色部分、蓝色部分、绿色部分分别发送（调用三次IoSession.write()方法），那么如果你还用上面的CmccSipcDecoder，将无法工作，因为第一次数据流（红色部分）发送过取时，数据是不完整的，无法解析出一条短信息，当二次数据流（蓝色部分）发送过去时，已经可以解析出第一条短信息了，但是第二条短信还是不完整的，需要等待第三次数据流（绿色部分）的发送。注意：由于模拟数据发送的规模性问题很麻烦，所以这里采用了这种极端的例子说明问题，虽不具有典型性，但很能说明问题，这就足够了，所以不要追究这种发送消息是否在真实环境中存在，更不要追究其合理性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> codec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.buffer.IoBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.AttributeKey;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.CumulativeProtocolDecoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolDecoderOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CmccSipcDecoder</span> <span class="keyword">extends</span> <span class="title">CumulativeProtocolDecoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Charset charset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AttributeKey CONTEXT = <span class="keyword">new</span> AttributeKey(getClass(),</span><br><span class="line">            <span class="string">"context"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CmccSipcDecoder</span><span class="params">(Charset charset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.charset = charset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doDecode</span><span class="params">(IoSession session, IoBuffer in,</span></span></span><br><span class="line"><span class="function"><span class="params">                               ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Context ctx = getContext(session);</span><br><span class="line">        CharsetDecoder cd = charset.newDecoder();</span><br><span class="line">        <span class="keyword">int</span> matchCount = ctx.getMatchCount();</span><br><span class="line">        <span class="keyword">int</span> line = ctx.getLine();</span><br><span class="line">        IoBuffer buffer = ctx.innerBuffer;</span><br><span class="line">        String statusLine = ctx.getStatusLine(),</span><br><span class="line">                sender = ctx.getSender(),</span><br><span class="line">                receiver = ctx.getReceiver(),</span><br><span class="line">                length = ctx.getLength(),</span><br><span class="line">                sms = ctx.getSms();</span><br><span class="line">        <span class="keyword">while</span> (in.hasRemaining()) &#123;</span><br><span class="line">            <span class="keyword">byte</span> b = in.get();</span><br><span class="line">            matchCount++;</span><br><span class="line">            buffer.put(b);</span><br><span class="line">            <span class="keyword">if</span> (line &lt; <span class="number">4</span> &amp;&amp; b == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    statusLine = buffer.getString(matchCount, cd);</span><br><span class="line">                    statusLine = statusLine.substring(<span class="number">0</span>,</span><br><span class="line">                            statusLine.length() - <span class="number">1</span>);</span><br><span class="line">                    matchCount = <span class="number">0</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    ctx.setStatusLine(statusLine);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="number">1</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    sender = buffer.getString(matchCount, cd);</span><br><span class="line">                    sender = sender.substring(<span class="number">0</span>, sender.length() - <span class="number">1</span>);</span><br><span class="line">                    matchCount = <span class="number">0</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    ctx.setSender(sender);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="number">2</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    receiver = buffer.getString(matchCount, cd);</span><br><span class="line">                    receiver = receiver.substring(<span class="number">0</span>, receiver.length() -</span><br><span class="line">                            <span class="number">1</span>);</span><br><span class="line">                    matchCount = <span class="number">0</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    ctx.setReceiver(receiver);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="number">3</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    length = buffer.getString(matchCount, cd);</span><br><span class="line">                    length = length.substring(<span class="number">0</span>, length.length() - <span class="number">1</span>);</span><br><span class="line">                    matchCount = <span class="number">0</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    ctx.setLength(length);</span><br><span class="line">                &#125;</span><br><span class="line">                line++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matchCount == Long.parseLong(length.split(<span class="string">": "</span>)[<span class="number">1</span>])) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    sms = buffer.getString(matchCount, cd);</span><br><span class="line">                    ctx.setSms(sms);</span><br><span class="line">                    <span class="comment">// 由于下面的break，这里需要调用else外面的两行代码</span></span><br><span class="line">                    ctx.setMatchCount(matchCount);</span><br><span class="line">                    ctx.setLine(line);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.setMatchCount(matchCount);</span><br><span class="line">            ctx.setLine(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ctx.getLine() == <span class="number">4</span></span><br><span class="line">                &amp;&amp; Long.parseLong(ctx.getLength().split(<span class="string">": "</span>)[<span class="number">1</span>]) == ctx</span><br><span class="line">                .getMatchCount()) &#123;</span><br><span class="line">            SmsObject smsObject = <span class="keyword">new</span> SmsObject();</span><br><span class="line">            smsObject.setSender(sender.split(<span class="string">": "</span>)[<span class="number">1</span>]);</span><br><span class="line">            smsObject.setReceiver(receiver.split(<span class="string">": "</span>)[<span class="number">1</span>]);</span><br><span class="line">            smsObject.setMessage(sms);</span><br><span class="line">            out.write(smsObject);</span><br><span class="line">            ctx.reset();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Context <span class="title">getContext</span><span class="params">(IoSession session)</span> </span>&#123;</span><br><span class="line">        Context context = (Context) session.getAttribute(CONTEXT);</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = <span class="keyword">new</span> Context();</span><br><span class="line">            session.setAttribute(CONTEXT, context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> IoBuffer innerBuffer;</span><br><span class="line">        <span class="keyword">private</span> String statusLine = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">private</span> String sender = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">private</span> String receiver = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">private</span> String length = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">private</span> String sms = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            innerBuffer = IoBuffer.allocate(<span class="number">100</span>).setAutoExpand(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> matchCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> line = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMatchCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> matchCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMatchCount</span><span class="params">(<span class="keyword">int</span> matchCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.matchCount = matchCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> line;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLine</span><span class="params">(<span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.line = line;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getStatusLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> statusLine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatusLine</span><span class="params">(String statusLine)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.statusLine = statusLine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sender;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSender</span><span class="params">(String sender)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sender = sender;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> receiver;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReceiver</span><span class="params">(String receiver)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(String length)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.length = length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sms;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSms</span><span class="params">(String sms)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sms = sms;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.innerBuffer.clear();</span><br><span class="line">            <span class="keyword">this</span>.matchCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.line = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.statusLine = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">this</span>.sender = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">this</span>.receiver = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">this</span>.length = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">this</span>.sms = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们做了如下的几步操作：</p><ol><li>所有记录状态的变量移到了Context 内部类中，包括记录读到短信协议的哪一行的line。每一行读取了多少个字节的matchCount，还有记录解析好的状态行、发送者、接受者、短信内容、累积数据的innerBuffer 等。这样就可以在数据不能完全解码，等待下一次doDecode()方法的调用时，还能承接上一次调用的数据。</li><li>在doDecode()方法中主要的变化是各种状态变量首先是从Context 中获取，然后操作之后，将最新的值setXXX()到Context 中保存。</li><li>这里注意doDecode()方法最后的判断，当认为不够解码为一条短信息时，返回false，也就是在本次数据流解码中不要再调用doDecode()方法；当认为已经解码出一条短信息时，输出短消息，然后重置所有的状态变量，返回true，也就是如果本次数据流解码中还有没解码完的数据，继续调用doDecode()方法。下面我们对客户端稍加改造，来模拟上面的红、蓝、绿三次发送聊天短信息的情况：<br>MyClient：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ConnectFuture future &#x3D; connector.connect(new InetSocketAddress(&quot;localhost&quot;, 8888));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等待是否连接成功，相当于是转异步执行为同步执行</span><br><span class="line">future.awaitUninterruptibly();</span><br><span class="line">&#x2F;&#x2F; 连接成功后获取会话对象。如果没有上面的等待，由于connect()方法是异步的，session可能无法被获取</span><br><span class="line">IoSession session &#x3D; future.getSession();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">    SmsObject smsObject &#x3D; new SmsObject();</span><br><span class="line">    session.write(smsObject);</span><br><span class="line">    System.out.println(&quot;*********&quot; + i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>这里我们为了方便演示，不在IoHandler 中发送消息，而是直接在MyClient 中发送，你要注意的是三次发送都要使用同一个IoSession，否则就不是从同一个通道发送过去的了。<br>CmccSipcEncoder：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void encode(IoSession session, Object message,</span><br><span class="line">                   ProtocolEncoderOutput out) throws Exception &#123;</span><br><span class="line">    SmsObject sms &#x3D; (SmsObject) message;</span><br><span class="line">    CharsetEncoder ce &#x3D; charset.newEncoder();</span><br><span class="line">    String statusLine &#x3D; &quot;M sip:wap.fetion.com.cn SIP-C&#x2F;2.0&quot;;</span><br><span class="line">    String sender &#x3D; &quot;15801012253&quot;;</span><br><span class="line">    String receiver &#x3D; &quot;15866332698&quot;;</span><br><span class="line">    String smsContent &#x3D; &quot;你好！Hello World!&quot;;</span><br><span class="line">    IoBuffer buffer &#x3D; IoBuffer.allocate(100).setAutoExpand(true);</span><br><span class="line">    buffer.putString(statusLine + &quot;&#x2F;n&quot;, ce);</span><br><span class="line">    buffer.putString(&quot;S: &quot; + sender + &quot;&#x2F;n&quot;, ce);</span><br><span class="line">    buffer.putString(&quot;R: &quot; + receiver + &quot;&#x2F;n&quot;, ce);</span><br><span class="line">    buffer.flip();</span><br><span class="line">    out.write(buffer);</span><br><span class="line">    IoBuffer buffer2 &#x3D; IoBuffer.allocate(100).setAutoExpand(true);</span><br><span class="line">    buffer2.putString(&quot;L: &quot; + (smsContent.getBytes(charset).length)</span><br><span class="line">            + &quot;&#x2F;n&quot;,ce);</span><br><span class="line">    buffer2.putString(smsContent, ce);</span><br><span class="line">    buffer2.putString(statusLine + &quot;&#x2F;n&quot;, ce);</span><br><span class="line">    buffer2.flip();</span><br><span class="line">    out.write(buffer2);</span><br><span class="line">    IoBuffer buffer3 &#x3D; IoBuffer.allocate(100).setAutoExpand(true);</span><br><span class="line">    buffer3.putString(&quot;S: &quot; + sender + &quot;&#x2F;n&quot;, ce);</span><br><span class="line">    buffer3.putString(&quot;R: &quot; + receiver + &quot;&#x2F;n&quot;, ce);</span><br><span class="line">    buffer3.putString(&quot;L: &quot; + (smsContent.getBytes(charset).length)</span><br><span class="line">            + &quot;&#x2F;n&quot;,ce);</span><br><span class="line">    buffer3.putString(smsContent, ce);</span><br><span class="line">    buffer3.putString(statusLine + &quot;&#x2F;n&quot;, ce);</span><br><span class="line">    buffer3.flip();</span><br><span class="line">    out.write(buffer3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上面的这段代码要配合MyClient来操作，你需要做的是在MyClient中的红色输出语句处设置断点，然后第一调用时CmccSipcEncoder中注释掉蓝、绿色的代码，也就是发送两条短信息的第一部分（红色的代码），依次类推，也就是MyClient的中的三次断点中，分别执行CmccSipcEncoder中的红、蓝、绿三段代码，也就是模拟两条短信的三段发送。你会看到Server端的运行结果是：当MyClient第一次到达断点时，没有短信息被读取到，当MyClient第二次到达断点时，第一条短信息输出，当MyClient第三次到达断点时，第二条短信息输出。</li></ol><p>Mina中自带的解码器：</p><p>解码器 说明<br><code>CumulativeProtocolDecoder 累积性解码器</code>，上面我们重点说明了这个解码器的用法。<br>SynchronizedProtocolDecoder 这个解码器用于将任何一个解码器包装为一个线程安全的解码器，用于解决上面说的每次执行decode()方法时可能线程不是上一次的线程的问题，但这样会在高并发时，大大降低系统的性能。<br>TextLineDecoder 按照文本的换行符（ Windows:/r/n 、Linux:/n、Mac:/r）解码数据。<br>PrefixedStringDecoder 这个类继承自CumulativeProtocolDecoder类，用于读取数据最前端的1、2、4 个字节表示后面的数据长度的数据。譬如：一个段数据的前两个字节表示后面的真实数据的长度，那么你就可以用这个方法进行解码。</p><h3 id="多路分离的解码器"><a href="#多路分离的解码器" class="headerlink" title="多路分离的解码器"></a>多路分离的解码器</h3><p>假设一段数据发送过来之后，需要根据某种条件决定使用哪个解码器，而不是像上面的例子，固定使用一个解码器，那么该如何做呢？幸好Mina 提供了org.apache.mina.filter.codec.demux 包来完成这种多路分离（Demultiplexes）的解码工作，也就是同时注册多个解码器，然后运行时依据传入的数据决定到底使用哪个解码器来工作。<code>所谓多路分离就是依据条件分发到指定的解码器</code>，譬如：上面的短信协议进行扩展，可以依据状态行来判断使用1.0 版本的短信协议解码器还是2.0版本的短信协议解码器。<br>下面我们使用一个简单的例子，说明这个多路分离的解码器是如何使用的，需求如下所示：</p><ol><li><p>客户端传入两个int 类型的数字，还有一个char 类型的符号。</p></li><li><p>如果符号是+，服务端就是用1 号解码器，对两个数字相加，然后把结果返回给客户端。</p></li><li><p>如果符号是-，服务端就使用2 号解码器，将两个数字变为相反数，然后相加，把结果返回给客户端。<br>Demux 开发编解码器主要有如下几个步骤：</p><p> A. 定义Client 端、Server 端发送、接收的数据对象。</p><p> B. 使用Demux 编写编码器是实现MessageEncoder<T>接口，T 是你要编码的数据对象，这个MessageEncoder 会在DemuxingProtocolEncoder 中调用。</p><p> C. 使用Demux 编写编码器是实现MessageDecoder 接口，这个MessageDecoder 会在DemuxingProtocolDecoder 中调用。</p><p> D. 在 DemuxingProtocolCodecFactory 中调用addMessageEncoder()、addMessageDecoder()方法组装编解码器。</p></li></ol><p>MessageEncoder的接口如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageEncoder</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(IoSession session, T message, ProtocolEncoderOutput out)</span> <span class="keyword">throws</span> Exception</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你注意到消息编码器接口与在ProtocolEncoder 中没什么不同，区别就是Object message被泛型具体化了类型，你不需要手动的类型转换了。<br>MessageDecoder的接口如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageDecoder</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">static</span> MessageDecoderResult OK = MessageDecoderResult.OK;    </span><br><span class="line">    <span class="keyword">static</span> MessageDecoderResult NEED_DATA = MessageDecoderResult.NEED_DATA;    </span><br><span class="line">    <span class="keyword">static</span> MessageDecoderResult NOT_OK = MessageDecoderResult.NOT_OK;    </span><br><span class="line">    <span class="function">MessageDecoderResult <span class="title">decodable</span><span class="params">(IoSession session, IoBuffer in)</span></span>;    </span><br><span class="line">    <span class="function">MessageDecoderResult <span class="title">decode</span><span class="params">(IoSession session, IoBuffer in,    </span></span></span><br><span class="line"><span class="function"><span class="params">    ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finishDecode</span><span class="params">(IoSession session, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>decodable()方法有三个返回值，分别表示如下的含义：</p><p> A. MessageDecoderResult.NOT_OK：表示这个解码器不适合解码数据，然后检查其它解码器，如果都不满足会抛异常；</p><p> B. MessageDecoderResult.NEED_DATA：表示当前的读入的数据不够判断是否能够使用这个解码器解码，然后再次调用decodable()方法检查其它解码器，如果都是NEED_DATA,则等待下次输入；</p><p> C. MessageDecoderResult.OK： 表示这个解码器可以解码读入的数据， 然后则调用MessageDecoder 的decode()方法。<code>这里注意decodable()方法对参数IoBuffer in 的任何操作在方法结束之后，都会复原</code>，也就是你不必担心在调用decode()方法时，position 已经不在缓冲区的起始位置。这个方法相当于是预读取，用于判断是否是可用的解码器。</p></li><li><p>decode()方法有三个返回值，分别表示如下的含义：</p><p> A. MessageDecoderResult.NOT_OK：表示解码失败，会抛异常；<br> B. MessageDecoderResult.NEED_DATA：表示数据不够，需要读到新的数据后，再次调用decode()方法。<br> C. MessageDecoderResult.OK：表示解码成功。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"><span class="comment">//客户端发送的数据对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> symbol = <span class="string">'+'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getSymbol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSymbol</span><span class="params">(<span class="keyword">char</span> symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.symbol = symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJ</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.j = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"><span class="comment">//服务端发送的返回结果对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(<span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.buffer.IoBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolEncoderOutput;</span><br><span class="line"><span class="comment">//客户端使用的SendMessage的编码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendSmsMessageEncoder</span> <span class="keyword">implements</span> <span class="title">SmsMessageEncoder</span>&lt;<span class="title">SendMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(IoSession session, SendMessage message, ProtocolEncoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        IoBuffer buffer = IoBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        buffer.putChar(message.getSymbol());</span><br><span class="line">        buffer.putInt(message.getI());</span><br><span class="line">        buffer.putInt(message.getJ());</span><br><span class="line">        buffer.flip();</span><br><span class="line">        out.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们的SendMessage、ResultMessage 中的字段都是用长度固定的基本数据类型，这样IoBuffer 就不需要自动扩展了，提高性能。按照一个char、两个int 计算，这里的IoBuffer只需要10 个字节的长度就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.buffer.IoBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolDecoderOutput;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.demux.MessageDecoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.demux.MessageDecoderResult;</span><br><span class="line"><span class="comment">//服务端使用的SendMessage的1号解码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageDecoderPositive</span> <span class="keyword">implements</span> <span class="title">MessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageDecoderResult <span class="title">decodable</span><span class="params">(IoSession session, IoBuffer in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in.remaining() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> MessageDecoderResult.NEED_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> symbol = in.getChar();</span><br><span class="line">            <span class="keyword">if</span> (symbol == <span class="string">'+'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> MessageDecoderResult.OK;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> MessageDecoderResult.NOT_OK;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageDecoderResult <span class="title">decode</span><span class="params">(IoSession session, IoBuffer in, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SendMessage sm = <span class="keyword">new</span> SendMessage();</span><br><span class="line">        sm.setSymbol(in.getChar());</span><br><span class="line">        sm.setI(in.getInt());</span><br><span class="line">        sm.setJ(in.getInt());</span><br><span class="line">        out.write(sm);</span><br><span class="line">        <span class="keyword">return</span> MessageDecoderResult.OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishDecode</span><span class="params">(IoSession session, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// undo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为客户端发送的SendMessage 的前两个字节（char）就是符号位，所以我们在decodable()方法中对此条件进行了判断，之后读到两个字节，并且这两个字节表示的字符是+时，才认为这个解码器可用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.buffer.IoBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolDecoderOutput;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.demux.MessageDecoderResult;</span><br><span class="line"><span class="comment">//服务端使用的SendMessage的2号解码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendSmsMessageDecoderNegative</span> <span class="keyword">implements</span> <span class="title">SmsMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageDecoderResult <span class="title">decodable</span><span class="params">(IoSession session, IoBuffer in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in.remaining() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> MessageDecoderResult.NEED_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> symbol = in.getChar();</span><br><span class="line">            <span class="keyword">if</span> (symbol == <span class="string">'-'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> MessageDecoderResult.OK;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> MessageDecoderResult.NOT_OK;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageDecoderResult <span class="title">decode</span><span class="params">(IoSession session, IoBuffer in, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SendMessage sm = <span class="keyword">new</span> SendMessage();</span><br><span class="line">        sm.setSymbol(in.getChar());</span><br><span class="line">        sm.setI(-in.getInt());</span><br><span class="line">        sm.setJ(-in.getInt());</span><br><span class="line">        out.write(sm);</span><br><span class="line">        <span class="keyword">return</span> MessageDecoderResult.OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishDecode</span><span class="params">(IoSession session, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// undo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"><span class="comment">//服务端使用的ResultMessage的编码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(<span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.buffer.IoBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolDecoderOutput;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.demux.MessageDecoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.demux.MessageDecoderResult;</span><br><span class="line"><span class="comment">//客户端使用的ResultMessage的解码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultMessageDecoder</span> <span class="keyword">implements</span> <span class="title">MessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageDecoderResult <span class="title">decodable</span><span class="params">(IoSession session, IoBuffer in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in.remaining() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> MessageDecoderResult.NEED_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in.remaining() == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> MessageDecoderResult.OK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> MessageDecoderResult.NOT_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageDecoderResult <span class="title">decode</span><span class="params">(IoSession session, IoBuffer in, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ResultMessage rm = <span class="keyword">new</span> ResultMessage();</span><br><span class="line">        rm.setResult(in.getInt());</span><br><span class="line">        out.write(rm);</span><br><span class="line">        <span class="keyword">return</span> MessageDecoderResult.OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishDecode</span><span class="params">(IoSession session, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// undo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.demux.DemuxingProtocolCodecFactory;</span><br><span class="line"><span class="comment">//组装这些编解码器的工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathProtocolCodecFactory</span> <span class="keyword">extends</span> <span class="title">DemuxingProtocolCodecFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MathProtocolCodecFactory</span><span class="params">(<span class="keyword">boolean</span> server)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (server) &#123;</span><br><span class="line">            <span class="keyword">super</span>.addMessageEncoder(ResultMessage<span class="class">.<span class="keyword">class</span>, <span class="title">ResultMessageEncoder</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            <span class="keyword">super</span>.addMessageDecoder(SendMessageDecoderPositive<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">super</span>.addMessageDecoder(SendSmsMessageDecoderNegative<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.addMessageEncoder(SendMessage<span class="class">.<span class="keyword">class</span>, <span class="title">SendSmsMessageEncoder</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            <span class="keyword">super</span>.addMessageDecoder(ResultMessageDecoder<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个工厂类我们使用了构造方法的一个布尔类型的参数，以便其可以在Server 端、Client端同时使用。我们以Server 端为例，你可以看到调用两次addMessageDecoder()方法添加了1 号、2 号解码器，其实DemuxingProtocolDecoder 内部在维护了一个MessageDecoder数组，用于保存添加的所有的消息解码器，每次decode()的时候就调用每个MessageDecoder的decodable()方法逐个检查，只要发现一个MessageDecoder 不是对应的解码器，就从数组中移除，直到找到合适的MessageDecoder，如果最后发现数组为空，就表示没找到对应的MessageDecoder，最后抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoAcceptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IdleStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.logging.LoggingFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.transport.socket.nio.NioSocketAcceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="comment">//Server端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        IoAcceptor acceptor = <span class="keyword">new</span> NioSocketAcceptor();</span><br><span class="line">        LoggingFilter lf = <span class="keyword">new</span> LoggingFilter();</span><br><span class="line">        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, <span class="number">5</span>);</span><br><span class="line">        acceptor.getFilterChain().addLast(<span class="string">"logger"</span>, lf);</span><br><span class="line">        acceptor.getFilterChain().addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> MathProtocolCodecFactory(<span class="keyword">true</span>)));</span><br><span class="line">        acceptor.setHandler(<span class="keyword">new</span> ServerHandler());</span><br><span class="line">        acceptor.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9123</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IdleStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="comment">//ServerHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">IoHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(ServerHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionIdle</span><span class="params">(IoSession session, IdleStatus status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        session.close(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SendMessage sm = (SendMessage) message;</span><br><span class="line">        System.out.println(<span class="string">"The message received is [ "</span> + sm.getI() + <span class="string">" "</span> + sm.getSymbol() + <span class="string">" "</span> + sm.getJ() + <span class="string">" ]"</span>);</span><br><span class="line">        ResultMessage rm = <span class="keyword">new</span> ResultMessage();</span><br><span class="line">        rm.setResult(sm.getI() + sm.getJ());</span><br><span class="line">        session.write(rm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoConnector;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.logging.LoggingFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.transport.socket.nio.NioSocketConnector;</span><br><span class="line"><span class="comment">//Client端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        IoConnector connector = <span class="keyword">new</span> NioSocketConnector();</span><br><span class="line">        connector.setConnectTimeoutMillis(<span class="number">30000</span>);</span><br><span class="line">        connector.getFilterChain().addLast(<span class="string">"logger"</span>, <span class="keyword">new</span> LoggingFilter());</span><br><span class="line">        connector.getFilterChain().addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> MathProtocolCodecFactory(<span class="keyword">false</span>)));</span><br><span class="line">        connector.setHandler(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">        connector.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">9123</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="comment">//client的Hanlder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">IoHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(ClientHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SendMessage sm = <span class="keyword">new</span> SendMessage();</span><br><span class="line">        sm.setI(<span class="number">100</span>);</span><br><span class="line">        sm.setJ(<span class="number">99</span>);</span><br><span class="line">        sm.setSymbol(<span class="string">'+'</span>);</span><br><span class="line">        session.write(sm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(IoSession session, Object message)</span> </span>&#123;</span><br><span class="line">        ResultMessage rs = (ResultMessage) message;</span><br><span class="line">        System.out.println(String.valueOf(rs.getResult()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;结果</span><br><span class="line">The message received is [ -100 - -99 ]</span><br><span class="line">The message received is [ 100 + 99 ]</span><br></pre></td></tr></table></figure><h2 id="线程模型配置"><a href="#线程模型配置" class="headerlink" title="线程模型配置"></a>线程模型配置</h2><p>Mina 中的很多执行环节都使用了多线程机制，用于提高性能。<code>Mina 中默认在三个地方使用了线程</code>：</p><ol><li>IoAcceptor：<br>这个地方用于接受客户端的连接建立，每监听一个端口（每调用一次bind()方法），都启用一个线程，这个数字我们不能改变。这个线程监听某个端口是否有请求到来，一旦发现，则创建一个IoSession 对象。因为这个动作很快，所以有一个线程就够了。</li><li>IoConnector：<br>这个地方用于与服务端建立连接，每连接一个服务端（每调用一次connect()方法），就启用一个线程，我们不能改变。同样的，这个线程监听是否有连接被建立，一旦发现，则创建一个IoSession 对象。因为这个动作很快，所以有一个线程就够了。</li><li>IoProcessor：<br>这个地方用于执行真正的IO 操作，默认启用的线程个数是CPU 的核数+1，譬如：单CPU 双核的电脑，默认的IoProcessor 线程会创建3 个。这也就是说一个IoAcceptor 或者IoConnector 默认会关联一个IoProcessor 池，这个池中有3 个IoProcessor。因为IO 操作耗费资源，所以这里使用IoProcessor 池来完成数据的读写操作，有助于提高性能。这也就是前面说的IoAccetor、IoConnector 使用一个Selector，而IoProcessor 使用自己单独的Selector 的原因。那么为什么IoProcessor 池中的IoProcessor 数量只比CPU 的核数大1 呢？因为IO 读写操作是耗费CPU 的操作，而每一核CPU 同时只能运行一个线程，因此IoProcessor 池中的IoProcessor 的数量并不是越多越好。</li></ol><p>这个IoProcessor 的数量可以调整，如下所示：<br>IoAcceptor acceptor=new NioSocketAcceptor(5);<br>IoConnector connector=new NioSocketConnector(5);<br>这样就会将IoProcessor 池中的数量变为5 个，也就是说可以同时处理5 个读写操作。<code>还记得前面说过Mina 的解码器要使用IoSession 保存状态变量，而不是Decoder 本身，这是因为Mina 不保证每次执行doDecode()方法的都是同一个IoProcessor 这句话吗？</code>其实这个问题的根本原因是IoProcessor 是一个池，每次IoSession 进入空闲状态时（无读些数据发生），IoProcessor 都会被回收到池中，以便其他的IoSession 使用，所以当IoSession从空闲状态再次进入繁忙状态时，IoProcessor 会再次分配给其一个IoProcessor 实例，而此时已经不能保证还是上一次繁忙状态时的那个IoProcessor 了。<code>你还会发现IoAcceptor 、IoConnector 还有一个构造方法， 你可以指定一个java.util.concurrent.Executor 类作为线程池对象，那么这个线程池对象是做什么用的呢？</code>其实就是用于创建(1.)、(2.)中的用于监听是否有TCP 连接建立的那个线程，默认情况下，使用Executors.newCachedThreadPool()方法创建Executor 实例，也就是一个无界的线程池（具体内容请参看JAVA 的并发库）。大家不要试图改变这个Executor 的实例，也就是使用内置的即可，否则可能会造成一些莫名其妙的问题，譬如：性能在某个访问量级别时，突然下降。因为无界线程池是有多少个Socket 建立，就分配多少个线程，如果你改为Executors 的其他创建线程池的方法，创建了一个有界线程池，那么一些请求将无法得到及时响应，从而出现一些问题。</p><p><code>下面我们完整的综述一下Mina 的工作流程：</code></p><p><code>1. 当 IoService 实例创建的时候，同时一个关联在IoService上的IoProcessor 池、线程池也被创建；</code></p><p><code>2. 当 IoService 建立套接字（IoAcceptor 的bind()或者是IoConnector 的connect()方法被调用）时，IoService 从线程池中取出一个线程，监听套接字端口；</code></p><p><code>3. 当 IoService 监听到套接字上有连接请求时，建立IoSession 对象，从IoProcessor池中取出一个IoProcessor 实例执行这个会话通道上的过滤器、IoHandler；</code></p><p><code>4. 当这条IoSession 通道进入空闲状态或者关闭时，IoProcessor 被回收。上面说的是Mina 默认的线程工作方式，那么我们这里要讲的是如何配置IoProcessor 的多线程工作方式。因为一个IoProcessor 负责执行一个会话上的所有过滤器、IoHandler，也就是对于IO 读写操作来说，是单线程工作方式（就是按照顺序逐个执行）。假如你想让某个事件方法（譬如：sessionIdle()、sessionOpened()等）在单独的线程中运行（也就是非IoProcessor 所在的线程），那么这里就需要用到一个ExecutorFilter 的过滤器。你可以看到IoProcessor 的构造方法中有一个参数是java.util.concurrent.Executor，也就是可以让IoProcessor 调用的过滤器、IoHandler 中的某些事件方法在线程池中分配的线程上独立运行，而不是运行在IoProcessor 所在的线程。</code></p><p>例：<br>acceptor.getFilterChain().addLast(“exceutor”, new ExecutorFilter());<br>我们看到是用这个功能，简单的一行代码就可以了。那么ExecutorFilter 还有许多重载的构造方法，这些重载的有参构造方法，参数主要用于指定如下信息：</p><ol><li>指定线程池的属性信息，譬如：核心大小、最大大小、等待队列的性质等。你特别要关注的是ExecutorFilter 内部默认使用的是OrderedThreadPoolExecutor 作为线程池的实现，从名字上可以看出是保证各个事件在多线程执行中的顺序（譬如：各个事件方法的执行是排他的，也就是不可能出现两个事件方法被同时执行；messageReceived()总是在sessionClosed() 方法之前执行）， 这是因为多线程的执行是异步的， 如果没有OrderedThreadPoolExecutor 来保证IoHandler 中的方法的调用顺序，可能会出现严重的问题。但是如果你的代码确实没有依赖于IoHandler 中的事件方法的执行顺序，那么你可以使用UnorderedThreadPoolExecutor 作为线程池的实现。因此，你也最好不要改变默认的Executor 实现，否则，事件的执行顺序就会混乱，譬如：messageReceived()、messageSent()方法被同时执行。</li><li>哪些事件方法被关注，也就哪些事件方法用这个线程池执行。线程池可以异步执行的事件类型是位于IoEventType 中的九个枚举值中除了SESSION_CREATED 之外的其余八个，这说明Session 建立的事件只能与IoProcessor 在同一个线程上执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> IoEventType &#123;    </span><br><span class="line">SESSION_CREATED,    </span><br><span class="line">SESSION_OPENED,    </span><br><span class="line">SESSION_CLOSED,    </span><br><span class="line">MESSAGE_RECEIVED,    </span><br><span class="line">MESSAGE_SENT,    </span><br><span class="line">SESSION_IDLE,    </span><br><span class="line">EXCEPTION_CAUGHT,    </span><br><span class="line">WRITE,    </span><br><span class="line">CLOSE,    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>默认情况下，没有配置关注的事件类型，有如下六个事件方法会被自动使用线程池异步执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IoEventType.EXCEPTION_CAUGHT,</span><br><span class="line">IoEventType.MESSAGE_RECEIVED,</span><br><span class="line">IoEventType.MESSAGE_SENT,</span><br><span class="line">IoEventType.SESSION_CLOSED,</span><br><span class="line">IoEventType.SESSION_IDLE,</span><br><span class="line">IoEventType.SESSION_OPENED</span><br></pre></td></tr></table></figure>其实ExecutorFilter 的工作机制很简单，就是在调用下一个过滤器的事件方法时，把其交给Executor 的execute(Runnable runnable)方法来执行，其实你自己在IoHandler 或者某个过滤器的事件方法中开启一个线程，也可以完成同样的功能，只不过这样做，你就失去了程序的可配置性，线程调用的代码也会完全耦合在代码中。但要注意的是绝对不能开启线程让其执行sessionCreated()方法。如果你真的打算使用这个ExecutorFilter，那么最好想清楚它该放在过滤器链的哪个位置，针对哪些事件做异步处理机制。一般ExecutorFilter 都是要放在ProtocolCodecFilter 过滤器的后面，也就是不要让编解码运行在独立的线程上，而是要运行在IoProcessor 所在的线程，因为编解码处理的数据都是由IoProcessor 读取和发送的，没必要开启新的线程，否则性能反而会下降。一般使用ExecutorFilter 的典型场景是将业务逻辑（譬如：耗时的数据库操作）放在单独的线程中运行，也就是说与IO 处理无关的操作可以考虑使用ExecutorFilter 来异步执行。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 互联网架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> Mina </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络通信框架（1）---Mina</title>
      <link href="/p/55146056.html"/>
      <url>/p/55146056.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为公司需要重构一个老项目，老项目的网络通信框架用的是Mina，现在需要迁移到Netty实现，所以趁着空闲的时间学习一下Mina。</p><h2 id="Mina框架概述"><a href="#Mina框架概述" class="headerlink" title="Mina框架概述"></a>Mina框架概述</h2><p>Apache Mina是一个能够帮助用户开发高性能和高伸缩性网络应用程序的框架。它通过Java nio技术基于TCP/IP和UDP/IP协议提供了抽象的、事件驱动的、异步的API。<br>学习Mina，需要你已掌握Java IO,Java NIO,Java Socket,Java线程及并发库(java.util.concurrent包)知识。<br>Mina同时提供了网络通信的Server端、Client端的封装。<br>Mina的底层依赖的主要是Java NIO库，上层提供的是基于事件的异步接口。<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-13/mina.png" alt="Mina架构"></p><h2 id="Mina主要接口"><a href="#Mina主要接口" class="headerlink" title="Mina主要接口"></a>Mina主要接口</h2><table><thead><tr><th>包名</th><th align="center">作用</th></tr></thead><tbody><tr><td>org.apache.mina.core.buffer</td><td align="center">用于缓冲区的IoBuffer</td></tr><tr><td>org.apache.mina.core.service org.apache.mina.transport.*</td><td align="center">用于提供连接的service</td></tr><tr><td>org.apache.mina.core.session</td><td align="center">用于提供两端状态的session</td></tr><tr><td>org.apache.mina.core.filterchain org.apache.mina.filter.*</td><td align="center">用于拦截所有IO事件和请求的filter chain和各类拦截器（在IoService和IoHandler之间）</td></tr><tr><td>org.apache.mina.handler.*</td><td align="center">用于处理IO事件的handler</td></tr><tr><td>org.apache.mina.core.future</td><td align="center">用于实现异步IO操作的 future</td></tr><tr><td>org.apache.mina.core.polling.*</td><td align="center">用于实现IO轮询的的polling</td></tr><tr><td>org.apache.mina.proxy.*</td><td align="center">用于实现代理的proxy</td></tr></tbody></table><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-20/Mina%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png" alt="Mina工作流程"></p><p><b>IoService:</b><br>这个接口在一个线程上负责套接字的建立，拥有自己的 Selector，监听是否有连接被建立。<br><b>IoProcessor:</b><br>这个接口在另一个线程丧负责检查是否有数据在通道中读写，也就是说它也拥有自己的Selector，这是与我们使用Java NIO编码时的一个不同之处，通常在Java NIO编码中，我们都是使用一个Selector，也就是不区分IoService和IoProcessor两个功能接口，另外IoProcessor负责调用在IoService上的过滤器，并在过滤器链之后调用IoHandler<br><b>IoAccepter:</b><br>相当于网络应用程序中的服务器端<br><b>IoConnector:</b><br>相当于客户端<br><b>IoSession:</b><br>当前客户端到服务器端的一个连接实例<br><b>IoHandler:</b><br>这个接口负责编写业务逻辑，也就是接收、发送数据的地方。这也是实际开发过程中需要用户自己编写的部分代码。<br><b>IoFilter :</b><br>过滤器用于悬接通讯层接口与业务层接口，这个接口定义一组拦截器，这些拦截器可以包括日志输出、黑名单过滤、数据的编码（write 方向）与解码（read 方向）等功能，其中数据的 encode与 decode是最为重要的、也是你在使用 Mina时最主要关注的地方。<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-20/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png" alt="Mina通信过程"></p><p>服务端流程：</p><ol><li>通过SocketAcceptor 同客户端建立连接；</li><li>连接建立之后 I/O的读写交给了I/O Processor线程，I/O Processor是多线程的；</li><li>通过I/O Processor 读取的数据经过IoFilterChain里所有配置的IoFilter，IoFilter进行消息的过滤，格式的转换，在这个层面可以制定一些自定义的协议；</li><li>最后IoFilter将数据交给 Handler  进行业务处理，完成了整个读取的过程；<br>写入过程也是类似，只是刚好倒过来，通过IoSession.write 写出数据，然后Handler进行写入的业务处理，处理完成后交给IoFilterChain，进行消息过滤和协议的转换，最后通过 I/O Processor 将数据写出到 socket 通道。<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-20/Mina%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%9B%BE.png" alt="Mina核心类图"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 互联网架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> Mina </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步非阻塞IO---NIO</title>
      <link href="/p/b7c39a63.html"/>
      <url>/p/b7c39a63.html</url>
      
        <content type="html"><![CDATA[<h2 id="高并发引起的问题"><a href="#高并发引起的问题" class="headerlink" title="高并发引起的问题"></a>高并发引起的问题</h2><p>一个使用传统阻塞I/O的系统,如果还是使用传统的一个请求对应一个线程这种模式,一旦有高并发的大量请求,就会有如下问题： </p><ol><li>线程不够用, 就算使用了线程池复用线程也无济于事; </li><li>阻塞I/O模式下,会有大量的线程被阻塞,一直在等待数据,这个时候的线程被挂起,只能干等,CPU利用率很低,换句话说,系统的吞吐量差; </li><li>如果网络I/O堵塞或者有网络抖动或者网络故障等,线程的阻塞时间可能很长。整个系统也变的不可靠;</li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>指JDK1.4及以上版本里提供的新的API，为所有原始类型（boolean类型除外）提供缓存支持的数据容器，使用它可以提供非阻塞式的高伸缩性网络。</li><li>NIO的作用：进行数据传输</li><li>NIO的组件：Buffer，Channel，Selector<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; IO的分类</span><br><span class="line">BIO - BlockingIO - 同步阻塞式IO</span><br><span class="line">NIO - NewIO - NonBlockingIO - 同步非阻塞IO - JDK1.4</span><br><span class="line">AIO - AsynchronousIO - 异步非阻塞式IO - JDK1.8</span><br></pre></td></tr></table></figure><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-12/NIO.png" alt="NIO"></li></ol><h2 id="阻塞与同步"><a href="#阻塞与同步" class="headerlink" title="阻塞与同步"></a>阻塞与同步</h2><p><a href="https://www.cnblogs.com/xcywt/p/8146123.html" target="_blank" rel="noopener">点击了解烧水壶例子</a></p><p><b>同步：</b><br>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。<br>例如普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事</p><p><b>异步：</b><br>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。<br>例如 ajax请求（异步）: 请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕</p><p><b>阻塞：</b><br>阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。<br>有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回,它还会抢占cpu去执行其他逻辑，也会主动检测io是否准备好。</p><p><b>非阻塞</b><br>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p><p>再简单点理解就是：</p><ol><li>同步：就是我调用一个功能，该功能没有结束前，我死等结果。</li><li>异步：就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）</li><li>阻塞：就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。</li><li>非阻塞：就是调用我（函数），我（函数）立即返回，通过select通知调用者</li></ol><p>同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞<br>阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回<br><b>综上可知:</b><br>同步和异步,阻塞和非阻塞,有些混用,其实它们完全不是一回事,而且它们修饰的对象也不相同。</p><h2 id="BIO与NIO对比"><a href="#BIO与NIO对比" class="headerlink" title="BIO与NIO对比"></a>BIO与NIO对比</h2><table><thead><tr><th>IO模型</th><th align="center">BIO</th><th align="center">NIO</th></tr></thead><tbody><tr><td>方式</td><td align="center">从硬盘到内存</td><td align="center">从内存到硬盘</td></tr><tr><td>通信</td><td align="center">面向流</td><td align="center">面向缓存</td></tr><tr><td>处理</td><td align="center">阻塞式IO</td><td align="center">非阻塞IO</td></tr><tr><td>触发</td><td align="center">无</td><td align="center">选择器（轮询机制）</td></tr></tbody></table><ol><li>BIO缺点<br> a.阻塞：导致效率整体降低。<br>b.一对一连接：客户端每过来一个请求，那么在服务端就需要一个线程去处理这个请求。如果客户端产生大量的请求，会导致服务端也产生大量的线程去处理请求，服务器端的线程数量一旦过多，会导致服务器的卡顿甚至崩溃。<br>c.如果客户端连接之后不产生任何操作，依然会占用服务端的线程，导致服务器资源的浪费。</li><li>面向流与面向缓冲<br>Java NIO和IO之间第一个最大的区别是，IO是面向流的.NIO是面向缓冲区的。Java IO面向流意味着毎次从流中读一个成多个字节，直至读取所有字节，它们没有被缓存在任何地方，此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的教据，需要先将它缓存到一个缓冲区。Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，霱要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数裾。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</li></ol><h2 id="Buffer-缓存区"><a href="#Buffer-缓存区" class="headerlink" title="Buffer - 缓存区"></a>Buffer - 缓存区</h2><ol><li>作用存储数据</li><li>容器：数组，针对基本类型提供了其中对应的Buffer（boolean类型除外）</li><li>重要位置： capacity &gt;= limit &gt;= position &gt;= mark<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-12/buffer.png" alt="Buffer"><br><b>容量（Capacity）：</b>缓冲区能够容纳的数据元素的最大数量。这一个容量在缓冲区创建时被设定，并且永远不能改变。<br><b>上界(Limit)：</b>限制位。用于限制操作位所能达到的最大位置。缓冲区刚创建时，limit和capacity重合<br><b>位置(Position)：</b>下一个要被读或写的元素的索引。用于执行要读写的位置。默认pisition为0。<br><b>标记(Mark)：</b>下一个要被读或写的元素的索引。类似于数组的下标，用于执行要读写的位置。默认情况下mark为-1</li><li>重要操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flip:翻转缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   limit = position;</span><br><span class="line">   position = <span class="number">0</span>;</span><br><span class="line">   mark = -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear:清空缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   position = <span class="number">0</span>;</span><br><span class="line">   limit =  capacity;</span><br><span class="line">   mark = -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reset:重置缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   postion = <span class="number">0</span>;</span><br><span class="line">   mark = -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel - 通道"></a>Channel - 通道</h2><ol><li>作用：传输数据。</li><li>分类：<br> a.文件 - FileChannel<br>b.UDP - DatagramChannel<br>c.TCP - SocketChannel、ServerSocketChannel</li><li>通道默认时阻塞的，可以手动设置为非阻塞。</li><li>通道可以进行双向传输。</li></ol><h2 id="Selector-选择器"><a href="#Selector-选择器" class="headerlink" title="Selector - 选择器"></a>Selector - 选择器</h2><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通里已经有可以处理的褕入，或者选择已准备写入的通道。这选怿机制，使得一个单独的线程很容易来管理多个通道。</p><ol><li>作用：选择事件。</li><li>选择器是面向通道进行操作，但是选择器要求通道必须是非阻塞的。</li><li>利用选择器，可以实现一对多的效果。</li></ol><p><a href="https://blog.csdn.net/charjay_lin/article/details/81810922" target="_blank" rel="noopener">参考资料</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS添加开机自启动命令及脚本</title>
      <link href="/p/7156016b.html"/>
      <url>/p/7156016b.html</url>
      
        <content type="html"><![CDATA[<h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>如果只是添加一条简单的开机启动命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod + x &#x2F;etc&#x2F;rc.d&#x2F;rc.local</span><br><span class="line">#将要执行的命令写到 &#x2F;etc&#x2F;rc.d&#x2F;rc.local 这个文件中</span><br><span class="line">#重新启动即可</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>添加开机自启服务，在CentOS中添加开机自启动服务非常方便，只需要两条命令（以Nginx为例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nginx.service #设置Nginx服务为自启动服务</span><br><span class="line">systemctl start nginx.service  #设置Nginx服务</span><br></pre></td></tr></table></figure><p>如果没有nginx.service附件需要自己添加，自定义服务文件，添加到系统服务通过Systemctl管理,如下服务文件实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]:服务的说明</span><br><span class="line">Description:描述服务</span><br><span class="line">After:描述服务类别</span><br><span class="line"></span><br><span class="line">[Service]服务运行参数的设置</span><br><span class="line">Type&#x3D;forking是后台运行的形式</span><br><span class="line">ExecStart为服务的具体运行命令</span><br><span class="line">ExecReload为重启命令</span><br><span class="line">ExecStop为停止命令</span><br><span class="line">PrivateTmp&#x3D;True表示给服务分配独立的临时空间</span><br><span class="line">注意：启动、重启、停止命令全部要求使用绝对路径</span><br><span class="line">[Install]服务安装的相关设置，可设置为多用户</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;nginx - high performance web server</span><br><span class="line">After&#x3D;network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">ExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload</span><br><span class="line">ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s stop</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><ol><li>保存目录，以754权限保存在/usr/lib/systemd/system</li><li>设置开机自启动，在任意目录下执行 systemctl enable nginx.service</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#启动nginx服务</span><br><span class="line">systemctl start nginx.service</span><br><span class="line">#设置开机自启动</span><br><span class="line">systemctl enable nginx.service</span><br><span class="line">#停止开机自启动</span><br><span class="line">systemctl disable nginx.service</span><br><span class="line">#查看服务当前状态</span><br><span class="line">systemctl status nginx.service</span><br><span class="line">#重新启动服务</span><br><span class="line">systemctl restart nginx.service</span><br><span class="line">#查看所有已启动的服务</span><br><span class="line">systemctl list-units --type&#x3D;service</span><br></pre></td></tr></table></figure><h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><p>添加开机自启脚本</p><p>在CentOS中添加脚本有两种常用的方法，首先添加nginx启动脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">## processname: nginx</span><br><span class="line"></span><br><span class="line">nginx&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line">conf&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">case $1 in</span><br><span class="line">start)</span><br><span class="line">echo -n &quot;Starting Nginx&quot;</span><br><span class="line">$nginx -c $conf</span><br><span class="line">echo &quot; done&quot;</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">echo -n &quot;Stopping Nginx&quot;</span><br><span class="line">killall -9 nginx</span><br><span class="line">echo &quot; done&quot;</span><br><span class="line">;;</span><br><span class="line">test)</span><br><span class="line">$nginx -t -c $conf</span><br><span class="line">;;</span><br><span class="line">reload)</span><br><span class="line">echo -n &quot;Reloading Nginx&quot;</span><br><span class="line">ps auxww | grep nginx | grep master | awk &#39;&#123;print $2&#125;&#39; | xargs kill -HUP</span><br><span class="line">echo &quot; done&quot;</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">$0 stop</span><br><span class="line">$0 start</span><br><span class="line">;;</span><br><span class="line">show)</span><br><span class="line">ps -aux|grep nginx</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo -n &quot;Usage: $0 &#123;start|restart|reload|stop|test|show&#125;&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>赋予脚本可执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x 脚本位置</span><br><span class="line">chomod +x &#x2F;etc&#x2F;rc.d&#x2F;rc.local</span><br><span class="line">vi &#x2F;etc&#x2F;rc.d&#x2F;rc.local #在该文件下末尾增加执行脚本文件命令即可</span><br></pre></td></tr></table></figure><h2 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#将脚本移动到&#x2F;etc&#x2F;rc.d&#x2F;init.d 目录下</span><br><span class="line">mv &#x2F;home&#x2F;nginx.sh &#x2F;etc&#x2F;rc&#x2F;d&#x2F;init.d</span><br><span class="line">#增加脚本可执行权限</span><br><span class="line">chmod +x &#x2F;etc&#x2F;rc&#x2F;d&#x2F;init.d&#x2F;nginx.sh</span><br><span class="line">#添加脚本到开机自动启动项目中</span><br><span class="line">cd &#x2F;etc&#x2F;rc.d&#x2F;init.d</span><br><span class="line">chkconfig --add nginx.sh</span><br><span class="line">chkconfig nginx.sh on</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站历程</title>
      <link href="/p/39507609.html"/>
      <url>/p/39507609.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在建立这个博客的时候，我一直考虑在哪里托管静态页面</span><br><span class="line">如下是我几次托管的经历，站在自身的角度，判断他们的特点。</span><br></pre></td></tr></table></figure><h3 id="GitHub-Page"><a href="#GitHub-Page" class="headerlink" title="GitHub Page"></a>GitHub Page</h3><ol><li><p>优点：建站很快，无需自己搭建服务器，基于GIT方便版本控制，免费300M存储空间，绑定域名容易，直接解析CNAME指向即可，重点他<strong>免费！！</strong></p></li><li><p>缺点：访问速度奇慢无比</p></li></ol><h3 id="Ali-OSS"><a href="#Ali-OSS" class="headerlink" title="Ali OSS"></a>Ali OSS</h3><ol><li><p>优点：托管方便，访问速度快，在阿里云强大的数据系统下，可以监测网站各项数据，对于阿里云OSS各项优点一一不再赘述，了解过对象存储的同学应该都知道，对于没了解的同学可以<a href="https://www.alibabacloud.com/help/zh/doc-detail/31818.htm?spm=a2c63.p38356.b99.5.1a3e4c208lSNMv" target="_blank" rel="noopener">点此了解</a>。</p></li><li><p>缺点：流量不可控，除了贵没啥好说的，另外部署静态页面比较麻烦，hexo生成的静态博客很多都是以文件夹形式的，然后默认省略了index.html。而对于阿里云的OSS来说，并不会默认访问文件夹下的index.html，所以，生成的时候需要对源码进行调整，<a href="https://zengwu.com.cn/p/dd7e8a7b.html" target="_blank" rel="noopener">具体步骤</a>。因此最后放弃了OSS部署，先把OSS作为图床。</p></li></ol><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-06/ossfee.png" alt="OSS计费"></p><h3 id="Ali-ECS"><a href="#Ali-ECS" class="headerlink" title="Ali ECS"></a>Ali ECS</h3><ol><li>优点：方便管理，容易迁移，访问速度快</li><li>缺点：Nginx有时候会宕机，不过设置了开机自启动和阿里云进程报警，也还能接受。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
