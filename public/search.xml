<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>同步非阻塞IO---NIO</title>
      <link href="/p/b7c39a63.html"/>
      <url>/p/b7c39a63.html</url>
      
        <content type="html"><![CDATA[<h2 id="高并发引起的问题"><a href="#高并发引起的问题" class="headerlink" title="高并发引起的问题"></a>高并发引起的问题</h2><p>一个使用传统阻塞I/O的系统,如果还是使用传统的一个请求对应一个线程这种模式,一旦有高并发的大量请求,就会有如下问题： </p><ol><li>线程不够用, 就算使用了线程池复用线程也无济于事; </li><li>阻塞I/O模式下,会有大量的线程被阻塞,一直在等待数据,这个时候的线程被挂起,只能干等,CPU利用率很低,换句话说,系统的吞吐量差; </li><li>如果网络I/O堵塞或者有网络抖动或者网络故障等,线程的阻塞时间可能很长。整个系统也变的不可靠;</li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>指JDK1.4及以上版本里提供的新的API，为所有原始类型（boolean类型除外）提供缓存支持的数据容器，使用它可以提供非阻塞式的高伸缩性网络。</li><li>NIO的作用：进行数据传输</li><li>NIO的组件：Buffer，Channel，Selector<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; IO的分类</span><br><span class="line">BIO - BlockingIO - 同步阻塞式IO</span><br><span class="line">NIO - NewIO - NonBlockingIO - 同步非阻塞IO - JDK1.4</span><br><span class="line">AIO - AsynchronousIO - 异步非阻塞式IO - JDK1.8</span><br></pre></td></tr></table></figure><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-12/NIO.png" alt="NIO"></li></ol><h2 id="阻塞与同步"><a href="#阻塞与同步" class="headerlink" title="阻塞与同步"></a>阻塞与同步</h2><p><a href="https://www.cnblogs.com/xcywt/p/8146123.html" target="_blank" rel="noopener">点击了解烧水壶例子</a></p><p><b>同步：</b><br><br>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。</p><p>例如普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事</p><p><b>异步：</b><br><br>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。</p><p>例如 ajax请求（异步）: 请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕</p><p><b>阻塞：</b><br><br>阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。</p><p>有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回,它还会抢占cpu去执行其他逻辑，也会主动检测io是否准备好。</p><p><b>非阻塞</b><br><br>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p><p>再简单点理解就是：</p><ol><li>同步，就是我调用一个功能，该功能没有结束前，我死等结果。</li><li>异步，就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）</li><li>阻塞，就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。</li><li>非阻塞，就是调用我（函数），我（函数）立即返回，通过select通知调用者</li></ol><p>同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞<br>阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回<br><br><b>综上可知:</b><br><br>同步和异步,阻塞和非阻塞,有些混用,其实它们完全不是一回事,而且它们修饰的对象也不相同。</p><h2 id="BIO与NIO对比"><a href="#BIO与NIO对比" class="headerlink" title="BIO与NIO对比"></a>BIO与NIO对比</h2><table><thead><tr><th>IO模型</th><th align="center">BIO</th><th align="center">NIO</th></tr></thead><tbody><tr><td>方式</td><td align="center">从硬盘到内存</td><td align="center">从内存到硬盘</td></tr><tr><td>通信</td><td align="center">面向流</td><td align="center">面向缓存</td></tr><tr><td>处理</td><td align="center">阻塞式IO</td><td align="center">非阻塞IO</td></tr><tr><td>触发</td><td align="center">无</td><td align="center">选择器（轮询机制）</td></tr></tbody></table><ol><li>BIO缺点<br><br> a.阻塞：导致效率整体降低。<br><br>b.一对一连接：客户端每过来一个请求，那么在服务端就需要一个线程去处理这个请求。如果客户端产生大量的请求，会导致服务端也产生大量的线程去处理请求，服务器端的线程数量一旦过多，会导致服务器的卡顿甚至崩溃。<br><br>c.如果客户端连接之后不产生任何操作，依然会占用服务端的线程，导致服务器资源的浪费。<br> </li><li>面向流与面向缓冲<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java NIO和IO之间第一个最大的区别是，IO是面向流的.NIO是面向缓冲区的。Java IO面向流意味着毎次从流中读一个成多个字节，直至读取所有字节，它们没有被缓存在任何地方，此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的教据，需要先将它缓存到一个缓冲区。Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，霱要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数裾。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</li></ol><h2 id="Buffer-缓存区"><a href="#Buffer-缓存区" class="headerlink" title="Buffer - 缓存区"></a>Buffer - 缓存区</h2><ol><li>作用存储数据</li><li>容器：数组，针对基本类型提供了其中对应的Buffer（boolean类型除外）</li><li>重要位置： capacity &gt;= limit &gt;= position &gt;= mark<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-12/buffer.png" alt="Buffer"><br><b>容量（Capacity）：</b>缓冲区能够容纳的数据元素的最大数量。这一个容量在缓冲区创建时被设定，并且永远不能改变。<br><br><b>上界(Limit)：</b>限制位。用于限制操作位所能达到的最大位置。缓冲区刚创建时，limit和capacity重合<br><br><b>位置(Position)：</b>下一个要被读或写的元素的索引。用于执行要读写的位置。默认pisition为0。<br><br><b>标记(Mark)：</b>下一个要被读或写的元素的索引。类似于数组的下标，用于执行要读写的位置。默认情况下mark为-1<br></li><li>重要操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; flip:翻转缓冲区</span><br><span class="line">public final Buffer flip() &#123;</span><br><span class="line">limit &#x3D; position;</span><br><span class="line">   position &#x3D; 0;</span><br><span class="line">   mark &#x3D; -1;</span><br><span class="line">   return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; clear:清空缓冲区</span><br><span class="line">public final Buffer clear() &#123;</span><br><span class="line">position &#x3D; 0;</span><br><span class="line">   limit &#x3D;  capacity;</span><br><span class="line">   mark &#x3D; -1;</span><br><span class="line">   return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; reset:重置缓冲区</span><br><span class="line">public final Buffer rewind() &#123;</span><br><span class="line">postion &#x3D; 0;</span><br><span class="line">   mark &#x3D; -1;</span><br><span class="line">   return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel - 通道"></a>Channel - 通道</h2><ol><li>作用：传输数据。</li><li>分类：<br><br> a.文件 - FileChannel<br><br>b.UDP - DatagramChannel<br><br>c.TCP - SocketChannel、ServerSocketChannel</li><li>通道默认时阻塞的，可以手动设置为非阻塞。</li><li>通道可以进行双向传输。</li></ol><h2 id="Selector-选择器"><a href="#Selector-选择器" class="headerlink" title="Selector - 选择器"></a>Selector - 选择器</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通里已经有可以处理的褕入，或者选择已准备写入的通道。这选怿机制，使得一个单独的线程很容易来管理多个通道。</p><ol><li>作用：选择事件。</li><li>选择器是面向通道进行操作，但是选择器要求通道必须是非阻塞的。</li><li>利用选择器，可以实现一对多的效果。</li></ol><p><a href="https://blog.csdn.net/charjay_lin/article/details/81810922" target="_blank" rel="noopener">参考资料</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS添加开机自启动命令及脚本</title>
      <link href="/p/7156016b.html"/>
      <url>/p/7156016b.html</url>
      
        <content type="html"><![CDATA[<h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>如果只是添加一条简单的开机启动命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod + x &#x2F;etc&#x2F;rc.d&#x2F;rc.local</span><br><span class="line">#将要执行的命令写到 &#x2F;etc&#x2F;rc.d&#x2F;rc.local 这个文件中</span><br><span class="line">#重新启动即可</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>添加开机自启服务，在CentOS中添加开机自启动服务非常方便，只需要两条命令（以Nginx为例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nginx.service #设置Nginx服务为自启动服务</span><br><span class="line">systemctl start nginx.service  #设置Nginx服务</span><br></pre></td></tr></table></figure><p>如果没有nginx.service附件需要自己添加，自定义服务文件，添加到系统服务通过Systemctl管理,如下服务文件实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]:服务的说明</span><br><span class="line">Description:描述服务</span><br><span class="line">After:描述服务类别</span><br><span class="line"></span><br><span class="line">[Service]服务运行参数的设置</span><br><span class="line">Type&#x3D;forking是后台运行的形式</span><br><span class="line">ExecStart为服务的具体运行命令</span><br><span class="line">ExecReload为重启命令</span><br><span class="line">ExecStop为停止命令</span><br><span class="line">PrivateTmp&#x3D;True表示给服务分配独立的临时空间</span><br><span class="line">注意：启动、重启、停止命令全部要求使用绝对路径</span><br><span class="line">[Install]服务安装的相关设置，可设置为多用户</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;nginx - high performance web server</span><br><span class="line">After&#x3D;network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">ExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload</span><br><span class="line">ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s stop</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><ol><li>保存目录，以754权限保存在/usr/lib/systemd/system</li><li>设置开机自启动，在任意目录下执行 systemctl enable nginx.service</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#启动nginx服务</span><br><span class="line">systemctl start nginx.service</span><br><span class="line">#设置开机自启动</span><br><span class="line">systemctl enable nginx.service</span><br><span class="line">#停止开机自启动</span><br><span class="line">systemctl disable nginx.service</span><br><span class="line">#查看服务当前状态</span><br><span class="line">systemctl status nginx.service</span><br><span class="line">#重新启动服务</span><br><span class="line">systemctl restart nginx.service</span><br><span class="line">#查看所有已启动的服务</span><br><span class="line">systemctl list-units --type&#x3D;service</span><br></pre></td></tr></table></figure><h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><p>添加开机自启脚本</p><p>在CentOS中添加脚本有两种常用的方法，首先添加nginx启动脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">## processname: nginx</span><br><span class="line"></span><br><span class="line">nginx&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line">conf&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">case $1 in</span><br><span class="line">start)</span><br><span class="line">echo -n &quot;Starting Nginx&quot;</span><br><span class="line">$nginx -c $conf</span><br><span class="line">echo &quot; done&quot;</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">echo -n &quot;Stopping Nginx&quot;</span><br><span class="line">killall -9 nginx</span><br><span class="line">echo &quot; done&quot;</span><br><span class="line">;;</span><br><span class="line">test)</span><br><span class="line">$nginx -t -c $conf</span><br><span class="line">;;</span><br><span class="line">reload)</span><br><span class="line">echo -n &quot;Reloading Nginx&quot;</span><br><span class="line">ps auxww | grep nginx | grep master | awk &#39;&#123;print $2&#125;&#39; | xargs kill -HUP</span><br><span class="line">echo &quot; done&quot;</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">$0 stop</span><br><span class="line">$0 start</span><br><span class="line">;;</span><br><span class="line">show)</span><br><span class="line">ps -aux|grep nginx</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo -n &quot;Usage: $0 &#123;start|restart|reload|stop|test|show&#125;&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>赋予脚本可执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x 脚本位置</span><br><span class="line">chomod +x &#x2F;etc&#x2F;rc.d&#x2F;rc.local</span><br><span class="line">vi &#x2F;etc&#x2F;rc.d&#x2F;rc.local #在该文件下末尾增加执行脚本文件命令即可</span><br></pre></td></tr></table></figure><h2 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#将脚本移动到&#x2F;etc&#x2F;rc.d&#x2F;init.d 目录下</span><br><span class="line">mv &#x2F;home&#x2F;nginx.sh &#x2F;etc&#x2F;rc&#x2F;d&#x2F;init.d</span><br><span class="line">#增加脚本可执行权限</span><br><span class="line">chmod +x &#x2F;etc&#x2F;rc&#x2F;d&#x2F;init.d&#x2F;nginx.sh</span><br><span class="line">#添加脚本到开机自动启动项目中</span><br><span class="line">cd &#x2F;etc&#x2F;rc.d&#x2F;init.d</span><br><span class="line">chkconfig --add nginx.sh</span><br><span class="line">chkconfig nginx.sh on</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站历程</title>
      <link href="/p/39507609.html"/>
      <url>/p/39507609.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在建立这个博客的时候，我一直考虑在哪里托管静态页面</span><br><span class="line">如下是我几次托管的经历，站在自身的角度，判断他们的特点。</span><br></pre></td></tr></table></figure><h3 id="GitHub-Page"><a href="#GitHub-Page" class="headerlink" title="GitHub Page"></a>GitHub Page</h3><ol><li><p>优点：建站很快，无需自己搭建服务器，基于GIT方便版本控制，免费300M存储空间，绑定域名容易，直接解析CNAME指向即可，重点他<strong>免费！！</strong></p></li><li><p>缺点：访问速度奇慢无比</p></li></ol><h3 id="Ali-OSS"><a href="#Ali-OSS" class="headerlink" title="Ali OSS"></a>Ali OSS</h3><ol><li><p>优点：托管方便，访问速度快，在阿里云强大的数据系统下，可以监测网站各项数据，对于阿里云OSS各项优点一一不再赘述，了解过对象存储的同学应该都知道，对于没了解的同学可以<a href="https://www.alibabacloud.com/help/zh/doc-detail/31818.htm?spm=a2c63.p38356.b99.5.1a3e4c208lSNMv" target="_blank" rel="noopener">点此了解</a>。</p></li><li><p>缺点：流量不可控，除了贵没啥好说的，另外部署静态页面比较麻烦，hexo生成的静态博客很多都是以文件夹形式的，然后默认省略了index.html。而对于阿里云的OSS来说，并不会默认访问文件夹下的index.html，所以，生成的时候需要对源码进行调整，<a href="https://zengwu.com.cn/p/dd7e8a7b.html" target="_blank" rel="noopener">具体步骤</a>。因此最后放弃了OSS部署，先把OSS作为图床。</p></li></ol><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-06/ossfee.png" alt="OSS计费"></p><h3 id="Ali-ECS"><a href="#Ali-ECS" class="headerlink" title="Ali ECS"></a>Ali ECS</h3><ol><li>优点：方便管理，容易迁移，访问速度快</li><li>缺点：Nginx有时候会宕机，不过设置了开机自启动和阿里云进程报警，也还能接受。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
