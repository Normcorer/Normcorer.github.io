<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>KafkaConsumer多线程实例</title>
      <link href="/p/72a88712.html"/>
      <url>/p/72a88712.html</url>
      
        <content type="html"><![CDATA[<h2 id="Kafka-Consumer多线程实例"><a href="#Kafka-Consumer多线程实例" class="headerlink" title="Kafka Consumer多线程实例"></a>Kafka Consumer多线程实例</h2><p>  Kafka 0.9版本开始推出了Java版本的consumer，优化了coordinator的设计以及摆脱了对zookeeper的依赖。社区最近也在探讨正式用这套consumer API替换Scala版本的consumer的计划。鉴于目前这方面的资料并不是很多，本文将尝试给出一个利用KafkaConsumer编写的多线程消费者实例，希望对大家有所帮助。</p><p>这套API最重要的入口就KafkaConsumer(o.a.k.clients.consumer.KafkaConsumer)，普通的单线程使用方法官网API已有介绍，这里不再赘述了。因此，我们直奔主题——讨论一下如何创建多线程的方式来使用KafkaConsumer。KafkaConsumer和KafkaProducer不同，后者是线程安全的，因此我们鼓励用户在多个线程中共享一个KafkaProducer实例，这样通常都要比每个线程维护一个KafkaProducer实例效率要高。但对于KafkaConsumer而言，它不是线程安全的。</p><hr><h2 id="实现多线程时通常由两种实现方法"><a href="#实现多线程时通常由两种实现方法" class="headerlink" title="实现多线程时通常由两种实现方法"></a>实现多线程时通常由两种实现方法</h2><p>1.每个线程维护一个KafkaConsumer</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-08-31/%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BB%B4%E6%8A%A4%E4%B8%80%E4%B8%AAConsumer.png" alt="每个线程维护一个KafkaConsumer"></p><p>2.维护一个或多个KafkaConsumer，同时维护多个事件处理线程(worker thread)</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-08-31/%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%BB%B4%E6%8A%A4%E5%A4%9A%E4%B8%AA%E6%88%96%E4%B8%80%E4%B8%AAConsumer.png" alt="维护一个或多个KafkaConsumer"><br>当然，这种方法还可以有多个变种：比如每个worker线程有自己的处理队列。consumer根据某种规则或逻辑将消息放入不同的队列。不过总体思想还是相同的，故这里不做过多展开讨论了。</p><p>3.两种方式的优缺点</p><table><thead><tr><th></th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>方法1(每个线程维护一个KafkaConsumer)</td><td>方便实现速度较快，因为不需要任何线程间交互。<br>易于维护分区内的消息顺序。</td><td>更多的TCP连接开销(每个线程都要维护若干个TCP连接)。<br>consumer数受限于topic分区数，扩展性差。<br>频繁请求导致吞吐量下降。<br>线程自己处理消费到的消息可能会导致超时，从而造成rebalance。</td></tr><tr><td>方法2 (单个(或多个)consumer，多个worker线程)</td><td>可独立扩展consumer数和worker数，伸缩性好</td><td>实现麻烦。<br>通常难于维护分区内的消息顺序。<br>处理链路变长，导致难以保证提交位移的语义正确性。</td></tr></tbody></table><p>下面我们分别实现这两种方法。需要指出的是，下面的代码都是最基本的实现，并没有考虑很多编程细节，比如如何处理错误等。</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3><p><strong><em>ConsumerRunnable类</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个线程维护私有的KafkaConsumer实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KafkaConsumer&lt;String, String&gt; consumer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumerRunnable</span><span class="params">(String brokerList, String groupId, String topic)</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, brokerList);</span><br><span class="line">        props.put(<span class="string">"group.id"</span>, groupId);</span><br><span class="line">        props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);        <span class="comment">//本例使用自动提交位移</span></span><br><span class="line">        props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>);</span><br><span class="line">        props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</span><br><span class="line">        props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        <span class="keyword">this</span>.consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(topic));   <span class="comment">// 本例使用分区副本自动分配策略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">200</span>);   <span class="comment">// 本例使用200ms作为获取超时时间</span></span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                <span class="comment">// 这里面写处理消息的逻辑，本例中只是简单地打印消息</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" consumed "</span> + record.partition() +</span><br><span class="line">                        <span class="string">"th message with offset: "</span> + record.offset());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>ConsumerGroup类</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.my.kafka.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerGroup</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ConsumerRunnable&gt; consumers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumerGroup</span><span class="params">(<span class="keyword">int</span> consumerNum, String groupId, String topic, String brokerList)</span> </span>&#123;</span><br><span class="line">        consumers = <span class="keyword">new</span> ArrayList&lt;&gt;(consumerNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; consumerNum; ++i) &#123;</span><br><span class="line">            ConsumerRunnable consumerThread = <span class="keyword">new</span> ConsumerRunnable(brokerList, groupId, topic);</span><br><span class="line">            consumers.add(consumerThread);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ConsumerRunnable task : consumers) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>ConsumerMain类</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String brokerList = <span class="string">"localhost:9092"</span>;</span><br><span class="line">        String groupId = <span class="string">"testGroup1"</span>;</span><br><span class="line">        String topic = <span class="string">"test-topic"</span>;</span><br><span class="line">        <span class="keyword">int</span> consumerNum = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">        ConsumerGroup consumerGroup = <span class="keyword">new</span> ConsumerGroup(consumerNum, groupId, topic, brokerList);</span><br><span class="line">        consumerGroup.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h3><p><strong><em>Worker类</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ConsumerRecord&lt;String, String&gt; consumerRecord;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(ConsumerRecord record)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.consumerRecord = record;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这里写你的消息处理逻辑，本例中只是简单地打印消息</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" consumed "</span> + consumerRecord.partition()</span><br><span class="line">            + <span class="string">"th message with offset: "</span> + consumerRecord.offset());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>ConsumerHandler类</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecord;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.ConsumerRecords;</span><br><span class="line"><span class="keyword">import</span> org.apache.kafka.clients.consumer.KafkaConsumer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ArrayBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本例中使用一个consumer将消息放入后端队列，你当然可以使用前一种方法中的多实例按照某张规则同时把消息放入后端队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> KafkaConsumer&lt;String, String&gt; consumer;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService executors;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsumerHandler</span><span class="params">(String brokerList, String groupId, String topic)</span> </span>&#123;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(<span class="string">"bootstrap.servers"</span>, brokerList);</span><br><span class="line">        props.put(<span class="string">"group.id"</span>, groupId);</span><br><span class="line">        props.put(<span class="string">"enable.auto.commit"</span>, <span class="string">"true"</span>);</span><br><span class="line">        props.put(<span class="string">"auto.commit.interval.ms"</span>, <span class="string">"1000"</span>);</span><br><span class="line">        props.put(<span class="string">"session.timeout.ms"</span>, <span class="string">"30000"</span>);</span><br><span class="line">        props.put(<span class="string">"key.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        props.put(<span class="string">"value.deserializer"</span>, <span class="string">"org.apache.kafka.common.serialization.StringDeserializer"</span>);</span><br><span class="line">        consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line">        consumer.subscribe(Arrays.asList(topic));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">int</span> workerNum)</span> </span>&#123;</span><br><span class="line">        executors = <span class="keyword">new</span> ThreadPoolExecutor(workerNum, workerNum, <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1000</span>), <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">final</span> ConsumerRecord record : records) &#123;</span><br><span class="line">                executors.submit(<span class="keyword">new</span> Worker(record));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (consumer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            consumer.close();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (executors != <span class="keyword">null</span>) &#123;</span><br><span class="line">            executors.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!executors.awaitTermination(<span class="number">10</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Timeout.... Ignore for this case"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Other thread interrupted this shutdown, ignore for this case."</span>);</span><br><span class="line">            Thread.currentThread().interrupt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><em>Main类</em></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String brokerList = <span class="string">"localhost:9092,localhost:9093,localhost:9094"</span>;</span><br><span class="line">        String groupId = <span class="string">"group2"</span>;</span><br><span class="line">        String topic = <span class="string">"test-topic"</span>;</span><br><span class="line">        <span class="keyword">int</span> workerNum = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        ConsumerHandler consumers = <span class="keyword">new</span> ConsumerHandler(brokerList, groupId, topic);</span><br><span class="line">        consumers.execute(workerNum);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">        consumers.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，这两种方法或是模型都有各自的优缺点，在具体使用时需要根据自己实际的业务特点来选取对应的方法。就我个人而言，我比较推崇第二种方法以及背后的思想，即不要将很重的处理逻辑放入消费者的代码中，很多Kafka consumer使用者碰到的各种rebalance超时、coordinator重新选举、心跳无法维持等问题都来源于此。</p><hr><blockquote><p>博主是97年的，在杭州从事Java，如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 互联网架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS问题结合AtomicInteger分析</title>
      <link href="/p/969d9481.html"/>
      <url>/p/969d9481.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>公司业务渐渐要写多线程模块了，因为自己对多线程这块并不是非常了解，所以在bilibili上学习<a href="https://www.bilibili.com/video/BV1xK4y1C7aT?p=2" target="_blank" rel="noopener">马士兵老师的高并发课程</a>,以下也是听完第一节课后做的笔记。</p><hr><h2 id="CAS问题引入"><a href="#CAS问题引入" class="headerlink" title="CAS问题引入"></a>CAS问题引入</h2><p>在多线程环境下当我们使用AtmoicInteger中<code>getAndIncrement()</code>方法的当时候发现我们不需要加锁。他的源码其实时应用了CAS操作，这是一种无锁，也有人称自旋锁，也是乐观锁。</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-08-25/cas.png" alt="CAS"></p><h3 id="CAS图解"><a href="#CAS图解" class="headerlink" title="CAS图解"></a>CAS图解</h3><p>1.当一个线程进来拿到了当前值E(比如当前E是0，并将其存为N)。<br>2.开始计算，计算结果V(计算后当结果V为1)<br>3.计算完成后，比较N和E当值是否相等，如果相等就直接把E(0)值更新为V(1)。<br>如果不相等，就说明，E被其他线程改动过，如果改动之后为1，也就是当前E被改为1了，则重复上述动作，拿到当前值E(为1)，计算结果为V(2),继续比较N(1)和E….</p><h3 id="CAS存在的ABA问题"><a href="#CAS存在的ABA问题" class="headerlink" title="CAS存在的ABA问题"></a>CAS存在的ABA问题</h3><p>CAS存在ABA的问题，即一个线程A进来拿到当前值E(0),但是在修改过程中，同时两个线程进来对E进行了-1和+1的操作，由此当线程A要去比较原始值E的时候发现和当时读到的值是相同的，实际上这个E已经被两个线程修改过了，只不过修改过后的结果和最开始的E是一样的。由此引发了ABA的问题。</p><p>ABA问题的解决，通过加版本号，每次修改值E都需要改变其版本号，当比较原始值是否相同的时候同时也要比较版本号是否相同。版本号可以是多种形式(boolean、时间戳等)。</p><hr><h2 id="CAS问题AtomicInteger源码跟踪"><a href="#CAS问题AtomicInteger源码跟踪" class="headerlink" title="CAS问题AtomicInteger源码跟踪"></a>CAS问题AtomicInteger源码跟踪</h2><p>在AtomicInteger中内部是由一个int域来保存值的，其由volatile关键字修饰，用于保证可见性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><p>其实不只是Atomic类中使用了<code>compareAndSwap</code>方法,像<code>synchronized</code>,<code>volatile</code>底层也是这么实现的，这个等之后在看，现在我们来看看AtmoicInteger的<code>getAndIncrement()</code>的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Atomically increments by one the current value.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the previous value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>如果跟到JDK底层我们会发现他是<code>Unsafe</code>类中的一个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> var5;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var5;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再往下面跟，我们发现一个native修饰的方法,这就意味着这已经不是java代码实现了，是C++或C实现的，再继续跟就要跟到<code>HotSpot</code>也就是JVM的源码中去了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4, <span class="keyword">int</span> var5)</span></span>;</span><br></pre></td></tr></table></figure><p>我们继续跟踪到Hotspot中到<code>unsafe.cpp</code>,中的实现源码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x))</span><br><span class="line">  UnsafeWrapper(<span class="string">"Unsafe_CompareAndSwapInt"</span>);</span><br><span class="line">  oop p = JNIHandles::resolve(obj);</span><br><span class="line">  jint* addr = (jint *) index_oop_from_field_offset_long(p, offset);</span><br><span class="line">  <span class="keyword">return</span> (jint)(Atomic::cmpxchg(x, addr, e)) == e;</span><br><span class="line">UNSAFE_END</span><br></pre></td></tr></table></figure><p>然后继续跟踪<code>Atomic::cmpxchg(x, addr, e)</code>到<code>atomic_linux_x86.inline.hpp</code>,由于这边是linux系统所以由linux自己的实现，不同的操作系统实现不同。其中的汇编源码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inline jint  Atomic::cmpxchg (jint  exchange_value, volatile jint*  dest, jint  compare_value) &#123;</span><br><span class="line">    int mp &#x3D; os::is_MP();</span><br><span class="line">    __asm__ volatile (LOCK_IF_MP(%4) &quot;cmpxchgl %1,(%3)&quot;</span><br><span class="line">                    : &quot;&#x3D;a&quot; (exchange_value)</span><br><span class="line">                    : &quot;r&quot; (exchange_value), &quot;a&quot; (compare_value), &quot;r&quot; (dest), &quot;r&quot; (mp)</span><br><span class="line">                    : &quot;cc&quot;, &quot;memory&quot;);</span><br><span class="line">    return exchange_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>asm</strong>是汇编语言，直接和硬件打交道，我们发现<code>cmpxchg</code>语句硬件直接支持。</p><p><code>LOCK_IF_MP(%4)</code>其中的MP指的是Machine Processprs如果一个CPU是需要用<code>cmpxchg</code>就可以了,但如果多个CPU还要加前面的LOCK指令。</p><p>最终的实现：是<code>lock cmpxchg</code>指令</p><p>硬件：lock指令在执行后面指令的时候锁定一个北桥信号（不采用锁总线的方式）。</p><p><a href="https://blog.csdn.net/prstaxy/article/details/51802220?utm_source=blogxgwz7" target="_blank" rel="noopener">具体实现分析原文链接</a></p><h3 id="CAS是否真的是原子性"><a href="#CAS是否真的是原子性" class="headerlink" title="CAS是否真的是原子性"></a>CAS是否真的是原子性</h3><p>问题：如果在比较的时候，已经比较好了之后，但还没修改值之前，被其他线程修改了，那么其他线程的值会被当前值覆盖。</p><p>如果底层单单是一个<code>cmpxchg</code>指令，有多个CPU，他是不具有原子性的。但是在多个CPU的情况下，<code>LOCK</code>指令起到了关键性的作用，即一个CPU对一个值进行修改的时候，不允许其他CPU修改这个值。也是因为这个lock给cmpxchg提供了原子性。</p><hr><blockquote><p>博主是97年的，在杭州从事Java，如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 多线程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>状态模式实现简单英雄联盟抽皮肤案例</title>
      <link href="/p/cae41fc2.html"/>
      <url>/p/cae41fc2.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在重构这本书中，我接触到了状态模式，重构中把State/Strategy两个模式放在一起说，当时我也不太理解，因为光看类图，这两个模式真的差别不大。之后我会在写一篇博客主要讲诉这两个设计模式的区别。<br>在这篇博客中我学习了一遍状态模式，为了方便理解，写了一个简单的英雄联盟抽皮肤的小案例。案例代码我会放在Github上，在本文最后会附上地址。</p><hr><h2 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h2><p><strong>定义：</strong><br>对有<code>状态</code>的对象，把复杂的判断逻辑提取到不同的状态对象中，允许状态对象在其内部状态改变时改变其行为。主要是解决的这个对象的复杂状态的切换。</p><p><strong>优点：</strong></p><blockquote><p>1.状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。<br>2.减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。<br>3.有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</p></blockquote><p><strong>缺点：</strong></p><blockquote><p>1.状态模式的使用必然会增加系统的类与对象的个数。<br>2.状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</p></blockquote><p>状态模式主要允许一个对象在其内部状态发生改变时同时改变他的行为，看起来似乎修改了它的类。我这里就不总结他的定义与特点了，下面文章总结已经很清楚了。<br><a href="http://c.biancheng.net/view/1388.html" target="_blank" rel="noopener">状态模式定义与特点原文链接</a></p><hr><h2 id="状态模式的结构"><a href="#状态模式的结构" class="headerlink" title="状态模式的结构"></a>状态模式的结构</h2><p>状态模式包含以下主要角色：</p><ol><li>环境（Context）角色：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li><li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，根据业务需求可以写多个方法来改变当前的对象的状态。</li><li>具体状态（Concrete State）角色：实现抽象状态所对应的行为。</li></ol><p>如下是状态模式的结构：<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-08-16/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F.jpg" alt="状态模式结构"></p><hr><h2 id="简单英雄联盟抽皮肤案例"><a href="#简单英雄联盟抽皮肤案例" class="headerlink" title="简单英雄联盟抽皮肤案例"></a>简单英雄联盟抽皮肤案例</h2><h3 id="案例介绍"><a href="#案例介绍" class="headerlink" title="案例介绍"></a>案例介绍</h3><p>以简单英雄联盟抽皮肤为例，当一个用户的操作有（充值、退款、抽奖、获得皮肤）四个状态，根据用户不同的操作状态，会有不同的行为。<br>1.在未充值状态，用户只能选择充值这个动作，另外动作均不可以选择。<br>2.在已充值这个状态，用户可以继续充值，或者选择退款，当退款额度大于用户余额的时候会提示用户，当用户把余额退完会回到未充值状态。当用户账户有余额的时候可以操作抽奖动作。<br>3.在抽奖的时候，如果扣费成功，则会生成皮肤，如果扣费失败，则会提醒用户余额不足，并且根据余额多少回到未充值或者已充值状态。<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-08-16/%E7%AE%80%E5%8D%95%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F%E6%8A%BD%E7%9A%AE%E8%82%A4%E6%B5%81%E7%A8%8B.png" alt="简单英雄联盟抽奖流程图"><br>可以看的出来每个状态的切换都伴随这很多<code>IF-ELSE</code>，如果不采用设计模式，我们在扩展功能的时候会非常麻烦。</p><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><h4 id="环境角色（Context）"><a href="#环境角色（Context）" class="headerlink" title="环境角色（Context）"></a>环境角色（Context）</h4><p>这对应的是状态模式的环境角色（Context），他维护着用户的当前状态<code>currentState</code>，定义了客户的行为方法，还提供了一个设置当前状态的方法<code>setCurrentState(UserState currentState)</code>，来方便后面状态切换时候的使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zyj.domain.UserAccount;</span><br><span class="line"><span class="keyword">import</span> com.zyj.enumeration.RechargeAmountEnum;</span><br><span class="line"><span class="keyword">import</span> com.zyj.state.UserState;</span><br><span class="line"><span class="keyword">import</span> com.zyj.state.ChargedState;</span><br><span class="line"><span class="keyword">import</span> com.zyj.state.LotteryState;</span><br><span class="line"><span class="keyword">import</span> com.zyj.state.NoChargeState;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkinLotteryContext</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前状态</span></span><br><span class="line">    UserState currentState;</span><br><span class="line">    <span class="comment">// 未充值状态</span></span><br><span class="line">    UserState noChargeState;</span><br><span class="line">    <span class="comment">// 已充值状态</span></span><br><span class="line">    UserState chargedState;</span><br><span class="line">    <span class="comment">// 抽奖中状态</span></span><br><span class="line">    UserState lotteryState;</span><br><span class="line"></span><br><span class="line">    UserAccount userAccount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SkinLotteryContext</span><span class="params">(UserAccount userAccount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取客户账户</span></span><br><span class="line">        <span class="keyword">this</span>.userAccount = userAccount;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化当前状态，将当前状态设置为未充值状态</span></span><br><span class="line">        <span class="keyword">this</span>.currentState = <span class="keyword">new</span> NoChargeState(<span class="keyword">this</span>);</span><br><span class="line">        noChargeState = <span class="keyword">new</span> NoChargeState(<span class="keyword">this</span>);</span><br><span class="line">        chargedState = <span class="keyword">new</span> ChargedState(<span class="keyword">this</span>);</span><br><span class="line">        lotteryState = <span class="keyword">new</span> LotteryState(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handler处理者</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toCharge</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span> </span>&#123;</span><br><span class="line">        currentState.toCharge(rechargeAmountEnum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refund</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span> </span>&#123;</span><br><span class="line">        currentState.refund(rechargeAmountEnum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lottery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState.lottery();</span><br><span class="line">        <span class="comment">// 抽奖结束，自动生成皮肤</span></span><br><span class="line">        generateSkin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateSkin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState.generateSkin();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStatus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        currentState.getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前的状态</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(UserState currentState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState = currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">UserState <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">UserState <span class="title">getNoChargeState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> noChargeState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">UserState <span class="title">getChargedState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> chargedState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">UserState <span class="title">getLotteryState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lotteryState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象角色（State）"><a href="#抽象角色（State）" class="headerlink" title="抽象角色（State）"></a>抽象角色（State）</h4><p>这对应的是状态模式的抽象角色，他主要写了对象在不同状态下对应的行为，比如说用户的充值行为<code>toCharge()</code>,用户的退费行为<code>refund()</code>等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zyj.enumeration.RechargeAmountEnum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">UserState</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这是用户的操作动作。</span></span><br><span class="line"><span class="comment">     * 其实状态模式就是多条件判断的替代方案。</span></span><br><span class="line"><span class="comment">     * 在每个状态下，用户都有可能会执行下面的动作</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 默认抽奖一次为5个金币</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SkinLotteryContext skinLotteryContext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserState</span><span class="params">(SkinLotteryContext skinLotteryContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.skinLotteryContext = skinLotteryContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 充值动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">toCharge</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span></span>;</span><br><span class="line">    <span class="comment">// 退款动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">refund</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span></span>;</span><br><span class="line">    <span class="comment">// 抽奖动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">lottery</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 生成皮肤动作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">generateSkin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 获取当前状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">getState</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体状态（Concrete-State）"><a href="#具体状态（Concrete-State）" class="headerlink" title="具体状态（Concrete State）"></a>具体状态（Concrete State）</h4><h5 id="未充值状态"><a href="#未充值状态" class="headerlink" title="未充值状态"></a>未充值状态</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zyj.enumeration.RechargeAmountEnum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未充值状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoChargeState</span> <span class="keyword">extends</span> <span class="title">UserState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NoChargeState</span><span class="params">(SkinLotteryContext skinLotteryContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(skinLotteryContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toCharge</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为客户充值</span></span><br><span class="line">        skinLotteryContext.userAccount.charge(rechargeAmountEnum);</span><br><span class="line">        <span class="comment">// 打印余额</span></span><br><span class="line">        System.out.println(<span class="string">"您当前的余额为："</span> + skinLotteryContext.userAccount.getAmount());</span><br><span class="line">        <span class="comment">// 已经充值，转成已充值状态</span></span><br><span class="line">        skinLotteryContext.setCurrentState(skinLotteryContext.getChargedState());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refund</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对不起，您当前处于未充值状态"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lottery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对不起，未充值不能进行抽奖"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateSkin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对不起，未充值不能生成皮肤"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前状态是：未充值状态"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="已充值状态"><a href="#已充值状态" class="headerlink" title="已充值状态"></a>已充值状态</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zyj.constant.LotteryConstant;</span><br><span class="line"><span class="keyword">import</span> com.zyj.enumeration.RechargeAmountEnum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 已充值状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChargedState</span> <span class="keyword">extends</span> <span class="title">UserState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChargedState</span><span class="params">(SkinLotteryContext skinLotteryContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(skinLotteryContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toCharge</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 为客户充值</span></span><br><span class="line">        skinLotteryContext.userAccount.charge(rechargeAmountEnum);</span><br><span class="line">        <span class="comment">// 打印余额</span></span><br><span class="line">        System.out.println(<span class="string">"您当前的余额为："</span> + skinLotteryContext.userAccount.getAmount());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refund</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 客户退钱动作逻辑，在JavaBean中实现，判断余额是否充足</span></span><br><span class="line">        skinLotteryContext.userAccount.refund(rechargeAmountEnum);</span><br><span class="line">        <span class="comment">// 如果退费后当前余额为0，则返回未充值状态</span></span><br><span class="line">        <span class="keyword">if</span> (skinLotteryContext.userAccount.isEmpty()) &#123;</span><br><span class="line">            skinLotteryContext.setCurrentState(skinLotteryContext.getNoChargeState());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lottery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断用户余额是否足够一次抽奖</span></span><br><span class="line">        <span class="keyword">if</span> (skinLotteryContext.userAccount.isEnough()) &#123;</span><br><span class="line">            <span class="comment">// 减去本次抽奖的费用</span></span><br><span class="line">            skinLotteryContext.userAccount.setAmount(skinLotteryContext.userAccount.getAmount().subtract(LotteryConstant.DEFAULT_COST));</span><br><span class="line">            <span class="comment">// 设置当前状态为抽奖中的状态</span></span><br><span class="line">            skinLotteryContext.setCurrentState(skinLotteryContext.getLotteryState());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"当前账户余额不足，不能进行这次抽奖，当前余额："</span> + skinLotteryContext.userAccount.getAmount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateSkin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"请在抽奖过后在进行操作"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前状态是：已充值状态"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="抽奖状态"><a href="#抽奖状态" class="headerlink" title="抽奖状态"></a>抽奖状态</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cn.hutool.core.util.RandomUtil;</span><br><span class="line"><span class="keyword">import</span> com.zyj.enumeration.RechargeAmountEnum;</span><br><span class="line"><span class="keyword">import</span> com.zyj.enumeration.SkinEnum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽奖中状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LotteryState</span> <span class="keyword">extends</span> <span class="title">UserState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LotteryState</span><span class="params">(SkinLotteryContext skinLotteryContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(skinLotteryContext);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toCharge</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"抽奖中，不支持充值"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refund</span><span class="params">(RechargeAmountEnum rechargeAmountEnum)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"抽奖中，不支持退款"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lottery</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在抽奖中，请稍等之后再点击抽奖"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateSkin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"恭喜获得皮肤："</span> + SkinEnum.getDescriptionByValue(RandomUtil.randomInt(<span class="number">0</span>, <span class="number">10</span>)) + <span class="string">", 当前余额："</span> + skinLotteryContext.userAccount.getAmount());</span><br><span class="line">        <span class="comment">//判断抽完这次之后，用户是否还有余额，如果没有返回未充值状态</span></span><br><span class="line">        <span class="keyword">if</span> (skinLotteryContext.userAccount.isEmpty()) &#123;</span><br><span class="line">            skinLotteryContext.setCurrentState(skinLotteryContext.getNoChargeState());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            skinLotteryContext.setCurrentState(skinLotteryContext.getChargedState());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前状态是：抽奖中状态"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zyj.domain.UserAccount;</span><br><span class="line"><span class="keyword">import</span> com.zyj.enumeration.RechargeAmountEnum;</span><br><span class="line"><span class="keyword">import</span> com.zyj.state.SkinLotteryContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkinLotteryClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SkinLotteryContext skinLotteryContext = <span class="keyword">new</span> SkinLotteryContext(UserAccount.generateAccount(<span class="string">"用户1"</span>));</span><br><span class="line">        skinLotteryContext.getStatus();</span><br><span class="line">        skinLotteryContext.toCharge(RechargeAmountEnum.THIRTY);</span><br><span class="line">        skinLotteryContext.getStatus();</span><br><span class="line">        <span class="comment">// 第一次退费</span></span><br><span class="line">        skinLotteryContext.refund(RechargeAmountEnum.TEN);</span><br><span class="line">        skinLotteryContext.getStatus();</span><br><span class="line">        <span class="comment">// 第二次退费</span></span><br><span class="line">        skinLotteryContext.refund(RechargeAmountEnum.TEN);</span><br><span class="line">        skinLotteryContext.getStatus();</span><br><span class="line">        <span class="comment">// 第一次抽奖</span></span><br><span class="line">        skinLotteryContext.lottery();</span><br><span class="line">        skinLotteryContext.getStatus();</span><br><span class="line">        <span class="comment">// 第二次抽奖</span></span><br><span class="line">        skinLotteryContext.lottery();</span><br><span class="line">        skinLotteryContext.getStatus();</span><br><span class="line">        <span class="comment">// 第三次抽奖</span></span><br><span class="line">        skinLotteryContext.lottery();</span><br><span class="line">        skinLotteryContext.getStatus();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">当前状态是：未充值状态</span><br><span class="line">您当前的余额为：30</span><br><span class="line">当前状态是：已充值状态</span><br><span class="line">退款成功，当前客户余额：20</span><br><span class="line">当前状态是：已充值状态</span><br><span class="line">退款成功，当前客户余额：10</span><br><span class="line">当前状态是：已充值状态</span><br><span class="line">恭喜获得皮肤：脉冲火-锐雯, 当前余额：5</span><br><span class="line">当前状态是：已充值状态</span><br><span class="line">恭喜获得皮肤：霸天异形-卡兹克, 当前余额：0</span><br><span class="line">当前状态是：未充值状态</span><br><span class="line">对不起，未充值不能进行抽奖</span><br><span class="line">对不起，未充值不能生成皮肤</span><br><span class="line">当前状态是：未充值状态</span><br></pre></td></tr></table></figure><p>至于我是怎么生成皮肤的，我添加了皮肤的枚举类作为皮肤池，通过随机数随机抽取皮肤池中的皮肤实现，这样我们每增加一个皮肤只需要新增一个枚举就好了，符合开闭原则。<br>下面是我的皮肤枚举类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.enumeration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> SkinEnum &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 参照国外LOL皮肤翻译</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FRELJORD_ASHE(<span class="number">0</span> ,<span class="string">"弗雷尔卓德-艾希"</span>),</span><br><span class="line">    MEDIEVAL_TWITCH(<span class="number">1</span> ,<span class="string">"中世纪-图奇"</span>),</span><br><span class="line">    ASSASSIN_MASTER_YI(<span class="number">2</span>, <span class="string">"刺客-易大师"</span>),</span><br><span class="line">    RECON_TEEMO(<span class="number">3</span>, <span class="string">"侦察兵-提莫"</span>),</span><br><span class="line">    FORSAKEN_JAYCE(<span class="number">4</span>, <span class="string">"被遗弃者-杰斯"</span>),</span><br><span class="line">    ROYAL_SHACO(<span class="number">5</span>, <span class="string">"皇族-萨科"</span>),</span><br><span class="line">    JAIL_BREAK_GRAVES(<span class="number">6</span>, <span class="string">"越狱-格雷福斯"</span>),</span><br><span class="line">    MIDNIGHT_AHRI(<span class="number">7</span>, <span class="string">"午夜-阿狸"</span>),</span><br><span class="line">    PULSEFIRE_RIVEN(<span class="number">8</span>, <span class="string">"脉冲火-锐雯"</span>),</span><br><span class="line">    MECHA_KHA_ZIX(<span class="number">9</span>, <span class="string">"霸天异形-卡兹克"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer value;</span><br><span class="line">    <span class="keyword">private</span> String description;</span><br><span class="line"></span><br><span class="line">    SkinEnum(Integer value, String description) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(Integer value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getDescriptionByValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(values())</span><br><span class="line">                .filter(x -&gt; x.getValue().equals(value)).findFirst().map(SkinEnum::getDescription).orElse(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;SkinEnum&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(values()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="案例地址"><a href="#案例地址" class="headerlink" title="案例地址"></a>案例地址</h2><p>欢迎大家访问我的Github地址，如果喜欢的话，希望能给个Star，<a href="https://github.com/Normcorer/State-Pattern.git" target="_blank" rel="noopener">点击此处获取本案例源码</a>。</p><hr><blockquote><p>博主是97年的，在杭州从事Java，如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码质量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模版方法模式见解与案例</title>
      <link href="/p/dbee4e79.html"/>
      <url>/p/dbee4e79.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近一直在看《重构–改善既有的代码设计》这本书，书中第三章的第一小节，在讲解Duplicated Code（重复代码）的时候，阐述了一种引起重复代码的情况。</p><blockquote><p>重复代码的另一种常见情况就是“两个互为兄弟的子类内含有相同的表达式”。要避免这种情况需要对两个类使用Extract Method(110)，然后使用Pull Up Method(332)，将他推入超类内。如果代码只是类似，并非完全相同，那么就得应用Extract Method(110)，将其相似和差异的部分割开，单独作为一个函数。然后你可以发现可能可以运用Form Template Method(345)，获得一个Template Method设计模式。</p></blockquote><p>因为对模版方法模式理解不是很深，所以看了一些文章总结一下。</p><h2 id="定义与特点"><a href="#定义与特点" class="headerlink" title="定义与特点"></a>定义与特点</h2><p><strong>定义：</strong><br>一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。本质就是固定算法骨架，让一些步骤延迟加载到子类中。</p><p><strong>优点：</strong><br>1.它将一些公有不变的部分进行封装到超类中进行实现，可变的部分可由子类继承实现，便于扩展。<br>2.提取了公有方法到超类，便于复用。<br>3.部分方法由子类实现，可以通过扩展到方式增加相应的功能，符合开闭原则。</p><p><strong>缺点：</strong><br>1.每个实现都需要定义一个子类，会导致类爆炸，系统更加庞大<br>2.超类中的抽象方法由子类实现，这是一种反向的控制结构，降低了代码的可读性。</p><hr><h2 id="角色与结构"><a href="#角色与结构" class="headerlink" title="角色与结构"></a>角色与结构</h2><h3 id="主要角色"><a href="#主要角色" class="headerlink" title="主要角色"></a>主要角色</h3><p>1.抽象类：负责给一个算法的骨架，它由一个模版方法和若干个基本方法组成。<br>① 模版方法：定义算法骨架，按某种顺序调用其中的方法。<br>② 基本方法：是整个算法一个步骤，包含了(抽象方法，具体方法，钩子方法)。</p><blockquote><p>抽象方法：在抽象类中申明，由具体子类实现。<br>  具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。<br>  钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p></blockquote><p>2.具体子类：实现抽象类中所定义的抽象方法和钩子方法，他们是一个顶级逻辑和一个组成步骤。</p><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-08-12/%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png" alt="模版方法模式类图"></p><hr><h2 id="学生考试案例"><a href="#学生考试案例" class="headerlink" title="学生考试案例"></a>学生考试案例</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Examination</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        GetTheTestPaper();</span><br><span class="line">        answer();</span><br><span class="line">        FinishTheTestPaper();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">GetTheTestPaper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拿到试卷"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">answer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinishTheTestPaper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"完成试卷"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体类"><a href="#具体类" class="headerlink" title="具体类"></a>具体类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentA</span> <span class="keyword">extends</span> <span class="title">Examination</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">answer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学生A的回答是：ABDC"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj.template;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentB</span> <span class="keyword">extends</span> <span class="title">Examination</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">answer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学生B的回答是：ADCA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.zyj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.zyj.template.Examination;</span><br><span class="line"><span class="keyword">import</span> com.zyj.template.StudentA;</span><br><span class="line"><span class="keyword">import</span> com.zyj.template.StudentB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Examination studentA = <span class="keyword">new</span> StudentA();</span><br><span class="line">        Examination studentB = <span class="keyword">new</span> StudentB();</span><br><span class="line"></span><br><span class="line">        studentA.exam();</span><br><span class="line">        studentB.exam();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">拿到试卷</span><br><span class="line">学生A的回答是：ABDC</span><br><span class="line">完成试卷</span><br><span class="line">拿到试卷</span><br><span class="line">学生B的回答是：ADCA</span><br><span class="line">完成试卷</span><br></pre></td></tr></table></figure><p>这里的例子可能举的并不是很好，模版方法模式算是一个比较容易理解的设计模式，该设计模式主要用于定义模版，比如我们写论文的时候，第一步肯定要写开题报告，有一系列的流程，我们可以抽取公有的流程把他定义在模版抽象类中。然后把一些使用者不同的，让使用者自己去实现就好。</p><hr><h2 id="案例地址"><a href="#案例地址" class="headerlink" title="案例地址"></a>案例地址</h2><p>欢迎大家访问我的Github地址，如果喜欢的话，希望能给个Star，<a href="https://github.com/Normcorer/Template-Method.git" target="_blank" rel="noopener">点击此处获取本案例源码</a>。</p><hr><blockquote><p>博主是97年的，在杭州从事Java，如果有小伙伴，想要一起交流学习的，欢迎添加博主微信。</p></blockquote><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/Common/WeChat.png" alt="weChat"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码质量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简单Mockito捕获mock对象方法的入参</title>
      <link href="/p/389ae027.html"/>
      <url>/p/389ae027.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实际项目中写单元测试的过程中，我们会发现需要测试的类有很多依赖，这些依赖又会有依赖，导致想要完成单元测试是一件很难的事情，为了解决这些问题，我们引入了Mock的概念，简单的说就是模拟这些资源或者依赖。<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-08-04/1148190-20171012164125840-513174531.png" alt="Mockito"></p><h2 id="Mock捕获参数的情景"><a href="#Mock捕获参数的情景" class="headerlink" title="Mock捕获参数的情景"></a>Mock捕获参数的情景</h2><p>我们在被mock的方法调用参数明确的情况下，可以无需捕获参数，但是有些情况下，比如方法没有返回值，根据不同的情景，方法需要传入不同的参数，比如说监控的错误日志，针对不同的错误，我们传入的错误日志的参数也是不同，诸多这些例子有很多。</p><h2 id="捕获一次mock方法的调用参数"><a href="#捕获一次mock方法的调用参数" class="headerlink" title="捕获一次mock方法的调用参数"></a>捕获一次mock方法的调用参数</h2><p>下面是一个简单的例子，只捕获一次调用参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    helloWorldController.hello(<span class="keyword">new</span> NullPointerException());</span><br><span class="line"></span><br><span class="line">    ArgumentCaptor&lt;User&gt; argumentCaptor = ArgumentCaptor.forClass(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    verify(helloWorldService, times(<span class="number">1</span>)).save(argumentCaptor.capture());</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="string">"zyj"</span>, argumentCaptor.getValue().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    IHelloWorldService helloWorldService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((cause <span class="keyword">instanceof</span> NullPointerException)) &#123;</span><br><span class="line">            helloWorldService.save(<span class="keyword">new</span> User(<span class="string">"zyj"</span>, <span class="number">18</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            helloWorldService.save(<span class="keyword">new</span> User(<span class="string">"zyj1"</span>, <span class="number">19</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们根据传入的不同异常，可以获取当前传入<code>save()</code>方法的参数，从而实现校验过程。<br>比如我传入NPE异常<code>argumentCaptor.getValue().getName()</code>就应该是zyj，传入<code>Exception</code>,那<code>argumentCaptor.getValue().getName()</code>的结果就是zyj1</p><h2 id="捕获多次mock方法的调用参数"><a href="#捕获多次mock方法的调用参数" class="headerlink" title="捕获多次mock方法的调用参数"></a>捕获多次mock方法的调用参数</h2><p>如果mock方法被调用多次，该如何知道每次调用时的参数呢？<code>argumentCaptor.getValue()</code> 只会返回最后一次调用的参数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    helloWorldController.hello(<span class="keyword">new</span> NullPointerException());</span><br><span class="line">    helloWorldController.hello(<span class="keyword">new</span> Exception());</span><br><span class="line"></span><br><span class="line">    ArgumentCaptor&lt;User&gt; argumentCaptor = ArgumentCaptor.forClass(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    verify(helloWorldService, times(<span class="number">2</span>)).save(argumentCaptor.capture());</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="string">"zyj1"</span>, argumentCaptor.getValue().getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们手动模拟调用两次<code>hellowoldController.hello()</code>的方法，得到的结果却是最后一次的调用的返回结果，说明了<code>argumentCaptor.getValue()</code> 方法只保存最后一次调用结果。</p><p>如果我们需要获得所有的调用参数值，那该怎么做呢，Mockito给我们提供了<code>argumentCaptor.getAllValues()</code>方法，它返回的是一个<code>List&lt;T&gt;</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testHello2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    helloWorldController.hello(<span class="keyword">new</span> NullPointerException());</span><br><span class="line">    helloWorldController.hello(<span class="keyword">new</span> Exception());</span><br><span class="line"></span><br><span class="line">    ArgumentCaptor&lt;User&gt; argumentCaptor = ArgumentCaptor.forClass(User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    verify(helloWorldService, times(<span class="number">2</span>)).save(argumentCaptor.capture());</span><br><span class="line"></span><br><span class="line">    List&lt;User&gt; allValues = argumentCaptor.getAllValues();</span><br><span class="line"></span><br><span class="line">    assertEquals(<span class="number">2</span>, allValues.size());</span><br><span class="line">    assertTrue(allValues.stream().allMatch(user -&gt;</span><br><span class="line">            Arrays.asList(<span class="string">"zyj"</span>, <span class="string">"zyj1"</span>).contains(user.getName()))</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>argumentCaptor.getAllValues()</code>得到的集合，如果mock方法是异步无序调用的，则可以使用Java8的新特性Stream的allMatch(),或者anyMatch()去匹配断言。如果是按顺序则直接断言即可。</p><h2 id="案例Demo"><a href="#案例Demo" class="headerlink" title="案例Demo"></a>案例Demo</h2><p><a href="https://github.com/Normcorer/MockitoDemo.git" target="_blank" rel="noopener">案例Git地址</a><br><a href="https://yanbin.blog/mockito-capture-method-paramters/#more-7737" target="_blank" rel="noopener">参考资料</a></p>]]></content>
      
      
      <categories>
          
          <category> 单元测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mockito </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>策略模式实现简单校验案例</title>
      <link href="/p/13848b8b.html"/>
      <url>/p/13848b8b.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;策略模式(Strategy Pattern)定义了算法族，分别封装起来，让它们之间可以相互替换，此模式让算法的变化独立于使用算法的用户。<br>&nbsp;&nbsp;&nbsp;&nbsp;本文展示了用策略模式实现了简单的登录校验，我会在本文最后附上本次的测试代码，有需要的小伙伴可以运行代码中的单元测试来进行理解。<br>&nbsp;&nbsp;&nbsp;&nbsp;为了校验登录的流程，我们往往需要判断用户名是否存在、密码是否正确、验证码是否正确等一系列操作，这就意味着我们的代码会有很多if-else没有扩展性，也没有复用性，如果我们想要增加一个邮箱的校验就需要，重新改if-else的代码，这意味着很容易影响到之前正确的功能。</p><h2 id="策略模式结构"><a href="#策略模式结构" class="headerlink" title="策略模式结构"></a>策略模式结构</h2><ul><li>策略（Strategy）：策略是一个接口，该接口定义算法标识。</li><li>具体策略（ConcreteStrategy）：具体策略是实现策略接口的类。具体策略实现策略接口所定义的抽象方法，即给出算法标识的具体算法。</li><li>上下文（Context）：上下文是依赖于策略接口的类，即上下文包含有策略声明的变量。上下文中提供了一个方法，该方法委托策略变量调用具体策略所实现的策略接口中的方法。</li></ul><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-07-20/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%B1%BB%E5%9B%BE.png" alt="策略模式类图"></p><h2 id="适合策略模式的情景"><a href="#适合策略模式的情景" class="headerlink" title="适合策略模式的情景"></a>适合策略模式的情景</h2><ul><li>一个类定义了多种行为，并且这些行为在这个类的方法中以多个条件语句的形式出现，那么可以使用策略模式在类中使用大量的条件语句。</li><li>程序不希望暴露复杂的、与算法有关的数据结构，可以使用策略模式来封装算法。</li></ul><h2 id="简单登录检验案例"><a href="#简单登录检验案例" class="headerlink" title="简单登录检验案例"></a>简单登录检验案例</h2><p>由于是简单实现，所以一些校验我直接写死了，需要的话可以通过查询数据库来进行替换写死的代码。</p><h3 id="策略接口"><a href="#策略接口" class="headerlink" title="策略接口"></a>策略接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVerify</span> </span>&#123;</span><br><span class="line">    <span class="function">Result <span class="title">exec</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="具体策略"><a href="#具体策略" class="headerlink" title="具体策略"></a>具体策略</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> domain.Result;</span><br><span class="line"><span class="keyword">import</span> enumeration.ResultEnum;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 密码校验策略：这边简易校验一下密码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordVerify</span> <span class="keyword">implements</span> <span class="title">IVerify</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String access = <span class="string">"123456"</span>;</span><br><span class="line">    <span class="keyword">private</span> String passWord;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PasswordVerify</span><span class="params">(String passWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.passWord = passWord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> passWord.equals(access) ? Result.sucess() : <span class="keyword">new</span> Result(ResultEnum.PASSWORD_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="策略上下文"><a href="#策略上下文" class="headerlink" title="策略上下文"></a>策略上下文</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IVerify&gt; verifyList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        verifyList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 链式调用</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">addStrategy</span><span class="params">(IVerify verify)</span> </span>&#123;</span><br><span class="line">        verifyList.add(verify);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        verifyList.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> verifyList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Result <span class="title">exec</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> verifyList.stream().map(IVerify::exec).filter(x -&gt; x.getCode() &gt;= <span class="number">400</span>).findFirst().orElse(Result.sucess());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【说明】这边我对策略的上下文进行了一些自定义，一般网上的策略都是单个校验，我这边通过<code>LinkedList&lt;&gt;()</code>存储策略，同时也保证了校验策略的顺序，通过java8新特性流式计算<code>stream().filter().findFirst()</code>方法来进行获取第一个检验失败的情况并返回相应的结果。</p><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Case1: 密码不正确</span></span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        Context context = <span class="keyword">new</span> Context();</span><br><span class="line">        context.addStrategy(<span class="keyword">new</span> PasswordVerify(<span class="string">"zyj"</span>))</span><br><span class="line">                .addStrategy(<span class="keyword">new</span> ValidateVerify(<span class="string">"123456"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act</span></span><br><span class="line">        Result exec = context.exec();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert</span></span><br><span class="line">        assertEquals(ResultEnum.PASSWORD_ERROR.getValue(), exec.getCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case2：验证码不正确</span></span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        context.removeAll();</span><br><span class="line">        context.addStrategy(<span class="keyword">new</span> PasswordVerify(<span class="string">"123456"</span>))</span><br><span class="line">                .addStrategy(<span class="keyword">new</span> ValidateVerify(<span class="string">"zyj"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act</span></span><br><span class="line">        exec = context.exec();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert</span></span><br><span class="line">        assertEquals(ResultEnum.VALIDATE_ERROR.getValue(), exec.getCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case3：全部不正确,取第一个不正确的</span></span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        context.removeAll();</span><br><span class="line">        context.addStrategy(<span class="keyword">new</span> PasswordVerify(<span class="string">"zyj"</span>))</span><br><span class="line">                .addStrategy(<span class="keyword">new</span> ValidateVerify(<span class="string">"zyj"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act</span></span><br><span class="line">        exec = context.exec();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert</span></span><br><span class="line">        assertEquals(ResultEnum.PASSWORD_ERROR.getValue(), exec.getCode());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case4：全部正确</span></span><br><span class="line">        <span class="comment">// Arrange</span></span><br><span class="line">        context.removeAll();</span><br><span class="line">        context.addStrategy(<span class="keyword">new</span> PasswordVerify(<span class="string">"123456"</span>))</span><br><span class="line">                .addStrategy(<span class="keyword">new</span> ValidateVerify(<span class="string">"123456"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Act</span></span><br><span class="line">        exec = context.exec();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Assert</span></span><br><span class="line">        assertEquals(ResultEnum.SUCCESS.getValue(), exec.getCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="高并发下策略模式的问题"><a href="#高并发下策略模式的问题" class="headerlink" title="高并发下策略模式的问题"></a>高并发下策略模式的问题</h2><p>这是我在生产环境下遇到的问题，首先说明一下，我们的项目是高并发环境，差不多每秒至少三四千的qps，随着业务发展这个量还会上去。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">context.addStrategy(<span class="keyword">new</span> PasswordVerify(<span class="string">"123456"</span>))</span><br><span class="line">.addStrategy(<span class="keyword">new</span> ValidateVerify(<span class="string">"zyj"</span>));</span><br></pre></td></tr></table></figure><p>策略模式这么使用，我们会发现随着策略的增多，我们在不停的new对象，这个过程是十分影响性能，也增大了JVM的内存压力。<br>最后我们通过将策略变量set进一个类中，并在外层创建一个list保存结果（保证线程安全，让每个线程的结果都在栈中）。<br>避免过多创建对象的方法有很多，需要根据不同环境。不同使用。</p><h2 id="案例Demo"><a href="#案例Demo" class="headerlink" title="案例Demo"></a>案例Demo</h2><p><strong><a href="https://github.com/Normcorer/StrategyValidate.git" target="_blank" rel="noopener">策略模式简单登录校验案例</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 代码质量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库批量新增及更新效率测试</title>
      <link href="/p/255903b5.html"/>
      <url>/p/255903b5.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于最近公司业务需求，我们需要重新开发一套系统，其中需求就是需要高TPS，高性能数据库读写能力，由此我测试了Mysql，JDBC、MyBatis并且集成Kafka来做一个性能测试。由于在框架测试上的代码不能公开，这里我自己重新快速写了个Demo，具体代码和完整的测试文档我也会上传至我的Github上。</p><h2 id="JDBC效率测试"><a href="#JDBC效率测试" class="headerlink" title="JDBC效率测试"></a>JDBC效率测试</h2><h3 id="单条新增及更新"><a href="#单条新增及更新" class="headerlink" title="单条新增及更新"></a>单条新增及更新</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(driverClass);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//插入sql语句</span></span><br><span class="line">        StringBuilder sql = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sql.append(<span class="string">" insert into batch_test"</span> +</span><br><span class="line">                <span class="string">"(id, test_name, create_time, update_time)values(?,?,?,?)"</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> (Connection conn = DriverManager.getConnection(jdbcUrl, username, password);</span><br><span class="line">             PreparedStatement ps = conn.prepareStatement(sql.toString())) &#123;</span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">                ps.setInt(<span class="number">1</span>, i);</span><br><span class="line">                ps.setString(<span class="number">2</span>, <span class="string">"name"</span> + i);</span><br><span class="line">                ps.setDate(<span class="number">3</span>, <span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">                ps.setDate(<span class="number">4</span>, <span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">                count = count + ps.executeUpdate();</span><br><span class="line">            &#125;</span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        Long end = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 耗时</span></span><br><span class="line">        System.out.println(<span class="string">"总计插入"</span> + count + <span class="string">"条，共计耗时"</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>最后结果</strong><br>注意代码中的conn.setAutoCommit(false)，下面分别时开启自动提交和关闭自动提交的结果：</p><ul><li>开启自动提交最后结果：总计插入50000条，共计耗时61秒</li><li>关闭自动提交最后结果：总计插入50000条，共计耗时19秒</li></ul><p>同样测试单条更新的结果，由于更新和新增只是单纯的sql语句不一样，这里代码就不贴了，如有需求可以去Git上下载完整代码</p><ul><li>开启自动提交最后结果：总计单条循环更新50000条，共计耗时96秒</li><li>关闭自动提交最后结果：总计单条循环更新50000条，共计耗时26秒</li></ul><h3 id="批量新增及更新"><a href="#批量新增及更新" class="headerlink" title="批量新增及更新"></a>批量新增及更新</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batchUpdate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(driverClass);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//插入sql语句</span></span><br><span class="line">        StringBuilder sql = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        sql.append(<span class="string">"update batch_test set test_name = ?, create_time = ?, update_time = ? where id = ?"</span>);</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> (Connection conn = DriverManager.getConnection(jdbcUrl, username, password);</span><br><span class="line">             PreparedStatement ps = conn.prepareStatement(sql.toString())) &#123;</span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">                ps.setString(<span class="number">1</span>, <span class="string">"name"</span> + (i));</span><br><span class="line">                ps.setDate(<span class="number">2</span>, <span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">                ps.setDate(<span class="number">3</span>, <span class="keyword">new</span> Date(System.currentTimeMillis()));</span><br><span class="line">                ps.setInt(<span class="number">4</span>, i);</span><br><span class="line">                ps.addBatch();</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">if</span> ((i + <span class="number">1</span>) % <span class="number">5000</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                    ps.executeBatch();</span><br><span class="line">                    conn.commit();</span><br><span class="line">                    ps.clearBatch();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ps.executeBatch();</span><br><span class="line">            conn.commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结束时间</span></span><br><span class="line">        Long end = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">// 耗时</span></span><br><span class="line">        System.out.println(<span class="string">"总计单条循环更新"</span> + count + <span class="string">"条，共计耗时"</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>想要让批量更新的效率提高，网上也有很多答案，我这里整理了一下，大多是在jdbcUrl上做操作:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;allowMultiQueries&#x3D;true&amp;rewriteBatchedStatements&#x3D;true</span><br></pre></td></tr></table></figure><p>经过我一番测试&amp;rewriteBatchedStatements=true这行参数加了是真的起了效果，如下是对这个参数的介绍：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MySQL的JDBC连接的url中要加rewriteBatchedStatements参数，并保证5.1.13以上版本的驱动，才能实现高性能的批量插入。</span><br><span class="line">MySQL的JDBC驱动在默认情况下会无视executeBatch()语句，把我们期望批量执行的一组sql语句拆散，一条一条地发给MySQL数据库，批量插入实际上是单条插入，直接造成较低的性能。</span><br><span class="line">只有把rewriteBatchedStatements参数置为true, 驱动才会帮你批量执行SQL</span><br><span class="line">另外这个选项对INSERT&#x2F;UPDATE&#x2F;DELETE都有效</span><br></pre></td></tr></table></figure><p>&amp;allowMultiQueries=true这个参数加与不加对JDBC批量更新基本无影响，他只是支持可以一次发送多条sql语句，如果不加这个参数当我们发送多条并以<code>；</code>隔开会报错，如下是官方的解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">allowMultiQueries</span><br><span class="line">Allow the use of &#39;;&#39; to delimit multiple queries during one statement (true&#x2F;false), defaults to &#39;false&#39;, and does not affect the addBatch() and executeBatch() methods, which instead rely on rewriteBatchStatements.</span><br><span class="line">Default: false</span><br><span class="line">Since version: 3.1.1</span><br></pre></td></tr></table></figure><p><strong>最后结果</strong></p><ul><li>JdbcUrl不加任何配置，总计批量循环更新50000条，共计耗时27秒</li><li>Jdbcurl加&amp;rewriteBatchedStatements=true，总计批量循环更新50000条，共计耗时3秒</li><li>jdbcurl加&amp;allowMultiQueries=true，总计批量循环更新50000条，共计耗时24秒</li><li>jdbcurl加&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true，总计批量循环更新50000条，共计耗时3秒</li></ul><hr><h2 id="Mybatis效率测试"><a href="#Mybatis效率测试" class="headerlink" title="Mybatis效率测试"></a>Mybatis效率测试</h2><h3 id="Mybatis单条更新"><a href="#Mybatis单条更新" class="headerlink" title="Mybatis单条更新"></a>Mybatis单条更新</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">single</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50000</span>; i++) &#123;</span><br><span class="line">            BatchTest batchTest = <span class="keyword">new</span> BatchTest(i, <span class="string">"name"</span> + i + <span class="number">4</span>, <span class="keyword">new</span> Date(), <span class="keyword">new</span> Date());</span><br><span class="line">            count = count + batchTestMapper.update(batchTest);</span><br><span class="line">        &#125;</span><br><span class="line">        Long end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"总计MyBatis单条更新"</span> + count + <span class="string">"条，共计耗时"</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此处测试的是整合Mybatis测试单条更新效率，和JDBC一样我们针对不同jdbcUrl参数来进行测试<br><strong>最后结果</strong></p><ul><li>不配置JdbcUrl，最后结果：总计MyBatis单条更新50000条，共计耗时234秒。</li><li>配置&amp;rewriteBatchedStatements=true，最后结果：总计MyBatis单条更新50000条，共计耗时224秒</li><li>配置&amp;allowMultiQueries=true，最后结果：总计MyBatis单条更新50000条，共计耗时222秒</li><li>配置&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true，最后结果：总计MyBatis单条更新50000条，共计耗时228秒</li></ul><h3 id="Mybatis批量更新"><a href="#Mybatis批量更新" class="headerlink" title="Mybatis批量更新"></a>Mybatis批量更新</h3><h4 id="CASEWHEN实现批量更新"><a href="#CASEWHEN实现批量更新" class="headerlink" title="CASEWHEN实现批量更新"></a>CASEWHEN实现批量更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;BatchTest&gt; batchTestList = generateTestDate(<span class="number">50000</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            batchTestMapper.updateBatch(batchTestList);</span><br><span class="line">            Long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"总计MyBatis批量更新"</span> + <span class="number">50000</span> + <span class="string">"条，共计耗时"</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;BatchTest&gt; <span class="title">generateTestDate</span><span class="params">(<span class="keyword">int</span> num, <span class="keyword">int</span> offset)</span> </span>&#123;</span><br><span class="line">        List&lt;BatchTest&gt; batchTestList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">            BatchTest batchTest = <span class="keyword">new</span> BatchTest(i, <span class="string">"name"</span> + i + offset, <span class="keyword">new</span> Date(), <span class="keyword">new</span> Date());</span><br><span class="line">            batchTestList.add(batchTest);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> batchTestList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateBatch"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span>&gt;</span></span><br><span class="line">        update batch_test</span><br><span class="line">        SET test_name =</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">separator</span>=<span class="string">" "</span> <span class="attr">open</span>=<span class="string">"case id"</span> <span class="attr">close</span>=<span class="string">"end"</span>&gt;</span></span><br><span class="line">            when #&#123;item.id&#125; then #&#123;item.testName&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        , create_time =</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">separator</span>=<span class="string">" "</span> <span class="attr">open</span>=<span class="string">"case id"</span> <span class="attr">close</span>=<span class="string">"end"</span>&gt;</span></span><br><span class="line">            when #&#123;item.id&#125; then #&#123;item.createTime&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        , update_time =</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">separator</span>=<span class="string">" "</span> <span class="attr">open</span>=<span class="string">"case id"</span> <span class="attr">close</span>=<span class="string">"end"</span>&gt;</span></span><br><span class="line">            when #&#123;item.id&#125; then #&#123;item.updateTime&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        where id in (</span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">            #&#123;item.id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">        )</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CASEWHEN方法实际上是把，众多更新拼接成一条sql语句，一次性提交，如果语句很长的话，效率并不理想<br><strong>最后结果</strong></p><ul><li>不配置JdbcUrl，最后结果：总计MyBatis批量更新50000条，共计耗时146秒</li><li>配置&amp;rewriteBatchedStatements=true，最后结果：总计MyBatis批量更新50000条，共计耗时144秒</li><li>配置&amp;allowMultiQueries=true，最后结果：总计MyBatis批量更新50000条，共计耗时142秒</li><li>配置&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true，最后结果：总计MyBatis批量更新50000条，共计耗时143秒</li></ul><h4 id="拼接多条SQL实现批量更新"><a href="#拼接多条SQL实现批量更新" class="headerlink" title="拼接多条SQL实现批量更新"></a>拼接多条SQL实现批量更新</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateBatchList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;BatchTest&gt; batchTestList = generateTestDate(<span class="number">50000</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            batchTestMapper.updateBatchList(batchTestList);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            Long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"总计MyBatis批量更新"</span> + <span class="number">50000</span> + <span class="string">"条，共计耗时"</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateBatchList"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">open</span>=<span class="string">""</span> <span class="attr">close</span>=<span class="string">""</span> <span class="attr">separator</span>=<span class="string">";"</span>&gt;</span></span><br><span class="line">            update batch_test</span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"item.testName != null"</span>&gt;</span></span><br><span class="line">                test_name = #&#123;item.testName&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"item.createTime != null"</span>&gt;</span></span><br><span class="line">                create_time = #&#123;item.createTime&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"item.updateTime != null"</span>&gt;</span></span><br><span class="line">                update_time = #&#123;item.updateTime&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">            where id = #&#123;item.id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用该方法，必须在JdbcUrl后面拼接参数&amp;allowMultiQueries=true，否则将会无法运行。<br>该方法主要是将众多更新语句，用“；”隔开，拼接成多条SQL语句进行批量提交，该方法在要更新大量数据的情况下，效率客观，但是数量越多，服务卡住可能性比较高。<br><strong>最后结果</strong></p><ul><li>配置&amp;rewriteBatchedStatements=true，最后结果：总计MyBatis批量更新50000条，共计耗时25秒</li><li>配置&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true，总计MyBatis批量更新50000条，共计耗时26秒</li></ul><h4 id="开启Mybatis批处理多条SQL"><a href="#开启Mybatis批处理多条SQL" class="headerlink" title="开启Mybatis批处理多条SQL"></a>开启Mybatis批处理多条SQL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executorTypeBatchList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession(ExecutorType.BATCH, <span class="keyword">false</span>);</span><br><span class="line">        BatchTestMapper mapper = sqlSession.getMapper(BatchTestMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        List&lt;BatchTest&gt; batchTestList = generateTestDate(<span class="number">50000</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            mapper.updateBatchList(batchTestList);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            sqlSession.commit();</span><br><span class="line">            sqlSession.close();</span><br><span class="line">            Long end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">"总计MyBatis批量更新"</span> + <span class="number">50000</span> + <span class="string">"条，共计耗时"</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateBatchList"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">open</span>=<span class="string">""</span> <span class="attr">close</span>=<span class="string">""</span> <span class="attr">separator</span>=<span class="string">";"</span>&gt;</span></span><br><span class="line">            update batch_test</span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"item.testName != null"</span>&gt;</span></span><br><span class="line">                test_name = #&#123;item.testName&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"item.createTime != null"</span>&gt;</span></span><br><span class="line">                create_time = #&#123;item.createTime&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"item.updateTime != null"</span>&gt;</span></span><br><span class="line">                update_time = #&#123;item.updateTime&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">            where id = #&#123;item.id&#125;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>最后结果</strong></p><ul><li>配置&amp;rewriteBatchedStatements=true，最后结果：总计MyBatis批量更新50000条，共计耗时23秒</li><li>配置&amp;allowMultiQueries=true&amp;rewriteBatchedStatements=true，总计MyBatis批量更新50000条，共计耗时25秒</li></ul><hr><h2 id="多线程批量更新效率测试"><a href="#多线程批量更新效率测试" class="headerlink" title="多线程批量更新效率测试"></a>多线程批量更新效率测试</h2><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-07-05/%E5%A4%9A%E7%BA%BF%E7%A8%8B1.png" alt="多线程批量测试1"><br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-07-05/%E5%A4%9A%E7%BA%BF%E7%A8%8B2.png" alt="多线程批量测试2"><br>测试发现多线程并不是越多效率越高，多线程之所以快是因为能提高CPU的使用率，但是多线程数量多了，会导致频繁切换CPU上下文，最后就得不偿失了。<br><strong>最后结果</strong></p><ul><li>开启3个线程更新5W条，最后结果：共计耗时22秒</li><li>开启4个线程更新5W条，最后结果：共计耗时65秒</li><li>开启5个线程更新5W条，最后结果：共计耗时65秒</li><li>开启10个线程更新5W条，最后结果：共计耗时98秒</li></ul><hr><h2 id="kafka批量消费更新入库效率测试"><a href="#kafka批量消费更新入库效率测试" class="headerlink" title="kafka批量消费更新入库效率测试"></a>kafka批量消费更新入库效率测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(BatchListener<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcBatchService jdbcBatchService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@KafkaListener</span>(containerFactory = <span class="string">"kafkaBatchListener8"</span>, id = GlobalConstant.KAFKA_LISTENER_ID, topics = GlobalConstant.BENCHMARK_TEST_TOPIC)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onMessage</span><span class="params">(List&lt;ConsumerRecord&lt;?, ?&gt;&gt; records, Acknowledgment ack)</span> </span>&#123;</span><br><span class="line">        logger.warn(<span class="string">"开始时间&#123;&#125;"</span>, System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        List&lt;BatchTest&gt; batchTestList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            records.forEach(record -&gt; &#123;</span><br><span class="line">                BatchTest batchTest = JSON.parseObject(record.value().toString(), BatchTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">                batchTestList.add(batchTest);</span><br><span class="line">            &#125;);</span><br><span class="line">            logger.warn(jdbcBatchService.updateBatchJdbc(batchTestList) + <span class="string">"\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Kafka监听异常"</span> + e.getMessage(), e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            ack.acknowledge();<span class="comment">//手动提交偏移量</span></span><br><span class="line">        &#125;</span><br><span class="line">        logger.warn(<span class="string">"结束时间&#123;&#125;"</span>, System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>kafka配置文件</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">producer:</span></span><br><span class="line">      <span class="attr">bootstrap-servers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span></span><br><span class="line">      <span class="attr">batch-size:</span> <span class="number">16785</span>                                   <span class="comment">#一次最多发送数据量</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">1</span>                                          <span class="comment">#发送失败后的重复发送次数</span></span><br><span class="line">      <span class="attr">buffer-memory:</span> <span class="number">33554432</span>                             <span class="comment">#32M批处理缓冲区</span></span><br><span class="line">      <span class="attr">linger:</span> <span class="number">1</span>                                           <span class="comment">#如果不设置linger.ms，其默认值就是0，也就说即使batch不满也会发送出去。可现在设置了linger.ms，这样这些本该早就发出去的消息被迫至少等待了linger.ms时间，所以说增加了发送方的延迟</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="attr">bootstrap-servers:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:9092</span></span><br><span class="line">      <span class="attr">auto-offset-reset:</span> <span class="string">earliest</span>                           <span class="comment">#最早未被消费的offset earliest</span></span><br><span class="line">      <span class="attr">max-poll-records:</span> <span class="number">10000</span>                              <span class="comment">#批量消费一次最大拉取的数据量</span></span><br><span class="line">      <span class="attr">enable-auto-commit:</span> <span class="literal">false</span>                           <span class="comment">#是否开启自动提交</span></span><br><span class="line">      <span class="attr">auto-commit-interval:</span> <span class="number">1000</span>                          <span class="comment">#自动提交的间隔时间</span></span><br><span class="line">      <span class="attr">session-timeout:</span> <span class="number">20000</span>                              <span class="comment">#连接超时时间</span></span><br><span class="line">      <span class="attr">max-poll-interval:</span> <span class="number">15000</span>                            <span class="comment">#手动提交设置与poll的心跳数,如果消息队列中没有消息，等待毫秒后，调用poll()方法。如果队列中有消息，立即消费消息，每次消费的消息的多少可以通过max.poll.records配置。</span></span><br><span class="line">      <span class="attr">max-partition-fetch-bytes:</span> <span class="number">15728640</span>                 <span class="comment">#设置拉取数据的大小,15M</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">batch-listener:</span> <span class="literal">true</span>                                <span class="comment">#是否开启批量消费，true表示批量消费</span></span><br><span class="line">      <span class="attr">concurrencys:</span> <span class="number">1</span><span class="string">,3,4,6,8</span>                                   <span class="comment">#设置消费的线程数</span></span><br><span class="line">      <span class="attr">poll-timeout:</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure><p>注意：要使用kafk批量消费，必须开启<code>batch-listener</code>属性,kafka的线程数，和他的分区数对应，有多少分区数，就能开启多少线程去消费。<br><strong>最后结果</strong><br><strong>一个Topic 4个分区 副本1</strong></p><ul><li><p>5W条 5000条为一批 单线程 4145ms </p></li><li><p>5W条 5000条为一批 三线程 1934ms </p></li><li><p>5W条 5000条为一批 四线程 2187ms </p></li><li><p>5W条 1W条为一批 单线程 5746ms </p></li><li><p>5W条 1W条为一批 三线程 3372ms </p></li><li><p>5W条 1W条为一批 四线程 2149ms </p></li><li><p>10W条 1W条为一批 单线程 14039ms</p></li><li><p>10W条 1W条为一批 三线程 6249ms </p></li><li><p>10W条 1W条为一批 四线程 4335ms </p></li></ul><p><strong>一个Topic 8个分区 副本1</strong></p><ul><li>10W条 1W条为一批 单线程 11180ms </li><li>10W条 1W条为一批 四线程 4303ms </li><li>10W条 1W条为一批 六线程 3976ms </li><li>10W条 1W条为一批 八线程 3590ms </li></ul><hr><h2 id="测试Demo地址"><a href="#测试Demo地址" class="headerlink" title="测试Demo地址"></a>测试Demo地址</h2><p><strong><a href="https://github.com/Normcorer/BenchmarkTest.git" target="_blank" rel="noopener">BenchmarkTest</a></strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> 性能测试 </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS定时任务</title>
      <link href="/p/e3889fed.html"/>
      <url>/p/e3889fed.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>crontab命令常见于Unix和类Unix的操作系统之中，用于设置周期性被执行的指令。该命令从标准输入设备读取指令，并将其存放于“crontab”文件中，以供之后读取和执行。该词来源于希腊语 chronos(χρνο)，原意是时间。通常，crontab储存的指令被守护进程激活， crond常常在后台运行，每一分钟检查是否有预定的作业需要执行。这类作业一般称为cron jobs。</p><p>Linux crontab是用来定期执行程序的命令。<br>当安装完成操作系统之后，默认便会启动此任务调度命令。<br>crond 命令每分锺会定期检查是否有要执行的工作，如果有要执行的工作便会自动执行该工作。</p><h2 id="crontab使用"><a href="#crontab使用" class="headerlink" title="crontab使用"></a>crontab使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Options:</span><br><span class="line"> -u &lt;user&gt;  define user</span><br><span class="line"> -e         edit user&#39;s crontab</span><br><span class="line"> -l         list user&#39;s crontab</span><br><span class="line"> -r         delete user&#39;s crontab</span><br><span class="line"> -i         prompt before deleting</span><br><span class="line"> -n &lt;host&gt;  set host in cluster to run users&#39; crontabs</span><br><span class="line"> -c         get host in cluster to run users&#39; crontabs</span><br><span class="line"> -s         selinux context</span><br><span class="line"> -x &lt;mask&gt;  enable debugging</span><br></pre></td></tr></table></figure><ul><li>我们使用service crond status命令来查看当前定时服务是否开启</li></ul><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-30/%E6%9F%A5%E7%9C%8B%E5%AE%9A%E6%97%B6%E6%9C%8D%E5%8A%A1%E7%8A%B6%E6%80%81.png" alt="查看定时服务状态"></p><ul><li>使用crontab -e来创建一个定时任务<br>首先我们简单的创建一个shell脚本,输出一个hello world</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;hello world!&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;crontab</span><br></pre></td></tr></table></figure><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-30/crontab%E5%86%99%E6%B3%95.png" alt="cron写法"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#然后输入来创建当前用户下的定时任务</span><br><span class="line">crontab -e</span><br><span class="line">#在该定时任务文件下，写入任务脚本，该任务表示每5分钟跑一次</span><br><span class="line">5 * * * * sh&#x2F;home&#x2F;sh&#x2F;helloworld.sh</span><br></pre></td></tr></table></figure><ul><li>使用crontab -l来查看当前用户下的定时任务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@zyj sh]# crontab -l</span><br><span class="line">*&#x2F;3 * * * * sh &#x2F;home&#x2F;admin&#x2F;edas-agent&#x2F;bin&#x2F;monitor.sh</span><br><span class="line">5 * * * * sh&#x2F;home&#x2F;sh&#x2F;helloworld.sh </span><br><span class="line">[root@zyj sh]#</span><br></pre></td></tr></table></figure><p>发现我们的定时任务，已经在当前用户下了</p><ul><li>具体各个用户的定时任务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@zyj sh]# cd &#x2F;var&#x2F;spool&#x2F;cron&#x2F;</span><br><span class="line">[root@zyj cron]# ls</span><br><span class="line">admin  root</span><br><span class="line">[root@zyj cron]# cat root</span><br><span class="line">*&#x2F;3 * * * * sh &#x2F;home&#x2F;admin&#x2F;edas-agent&#x2F;bin&#x2F;monitor.sh</span><br><span class="line">5 * * * * sh &#x2F;home&#x2F;sh&#x2F;helloworld.sh </span><br><span class="line">[root@zyj cron]#</span><br></pre></td></tr></table></figure><p>可以看到当前root用户下的所有定时任务，同样道理也可以看到admin的</p><ul><li>通过定时任务日志来确定定时任务是否生效</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#因为我们刚配置定时任务，需要重启服务生效</span><br><span class="line">systemctl restart crond</span><br><span class="line">#查看定时任务日志</span><br><span class="line">tail -f &#x2F;var&#x2F;log&#x2F;cron</span><br></pre></td></tr></table></figure><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-30/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%97%A5%E5%BF%97.png" alt="定时任务日志"></p><ul><li>删除定时任务</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#删除当前用户下所有的定时任务,慎用</span><br><span class="line">crontab -r</span><br><span class="line">#删除指定定时任务，删除我们不需要的定时任务即可</span><br><span class="line">crontab -e</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> 定时任务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步阻塞IO---BIO</title>
      <link href="/p/9a526a8e.html"/>
      <url>/p/9a526a8e.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>JavaBIO：同步阻塞（传统阻塞型），服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，可以通过线程池机制改善（实现多个客户连接服务器）<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-21/BIO%E7%AE%80%E5%8D%95%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="简单示意图"></p><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序简单易理解。<br><b>对BIO编程流程的梳理</b></p><ol><li>服务器点启动一个ServerSocket</li><li>客户端启动Socket对服务器进行通信，默认情况下服务器端需要对每个客户建立一个线程与之通讯</li><li>客户端发出请求后，先咨询服务器是否有线程响应，如果没有则会等待，或者被拒绝</li><li>如果有相应，客户端线程会等待请求结束后，再继续执行</li></ol><h2 id="BIO应用实例"><a href="#BIO应用实例" class="headerlink" title="BIO应用实例"></a>BIO应用实例</h2><p>实例说明：</p><ol><li>使用BIO模型编写一个服务器端，监听8888端口，当有客户端连接时，就启动一个线程与之通讯。</li><li>要求使用线程池机制改善，可以连接多个客户端</li><li>服务器端可以接受客户端发送的数据（telnet 方式即可）。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.molzhao.bio;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BIOServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ExecutorService executors = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//创建ServerSocket</span></span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        System.out.println(<span class="string">"服务器启动了"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程信息ID="</span> + Thread.currentThread().getId() + <span class="string">"名字="</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="comment">//监听等待客户端连接</span></span><br><span class="line">            System.out.println(<span class="string">"等待连接....."</span>);</span><br><span class="line">            Socket accept = serverSocket.accept();</span><br><span class="line">            System.out.println(<span class="string">"连接到一个客户端"</span>);</span><br><span class="line">            <span class="comment">//创建一个线程</span></span><br><span class="line">            executors.execute(() -&gt; &#123;</span><br><span class="line">                hanlder(accept);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编写一个Hanlder和客户端通信</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">hanlder</span><span class="params">(Socket socket)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程信息ID="</span> + Thread.currentThread().getId() + <span class="string">"名字="</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="comment">//通过socket 获取一个输入流</span></span><br><span class="line">            InputStream inputStream = socket.getInputStream();</span><br><span class="line">            <span class="comment">//循环读取客户端发送的数</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程信息ID="</span> + Thread.currentThread().getId() + <span class="string">"名字="</span> + Thread.currentThread().getName());</span><br><span class="line">                System.out.println(<span class="string">"read......."</span>);</span><br><span class="line">                <span class="keyword">int</span> read = inputStream.read(bytes);</span><br><span class="line">                <span class="keyword">if</span> (read != -<span class="number">1</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="keyword">new</span> String(bytes, <span class="number">0</span>, read)); <span class="comment">//输出客户端发送的数据</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"关闭和Client的连接"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用WIN + R打开终端界面，开始连接我们写好的服务器<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-21/telnet%E8%BF%9E%E6%8E%A5.png" alt="telnet连接服务器"></p><p>连接好之后，按CTRL + ]进入发送字符串模式<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-21/sendmsg1.png" alt="sendMsg"></p><p>由于我们使用的是线程池，我们可以连接多个客户端，继续按上面的步骤在建立一个telnet的连接<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-21/sendmsg.png" alt="sendMsg2"><br>如下是我们的执行结果，我们可以一步骤一步骤的操作，我们可以发现线程在什么时候阻塞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;结果</span><br><span class="line">等待连接.....</span><br><span class="line">线程信息ID&#x3D;11名字&#x3D;pool-1-thread-1</span><br><span class="line">线程信息ID&#x3D;11名字&#x3D;pool-1-thread-1</span><br><span class="line">read.......</span><br><span class="line">hello world</span><br><span class="line">线程信息ID&#x3D;11名字&#x3D;pool-1-thread-1</span><br><span class="line">read.......</span><br><span class="line">连接到一个客户端</span><br><span class="line">线程信息ID&#x3D;1名字&#x3D;main</span><br><span class="line">等待连接.....</span><br><span class="line">线程信息ID&#x3D;12名字&#x3D;pool-1-thread-2</span><br><span class="line">线程信息ID&#x3D;12名字&#x3D;pool-1-thread-2</span><br><span class="line">read.......</span><br><span class="line">hello world 2</span><br><span class="line">线程信息ID&#x3D;12名字&#x3D;pool-1-thread-2</span><br><span class="line">read.......</span><br></pre></td></tr></table></figure><h2 id="BIO问题分析"><a href="#BIO问题分析" class="headerlink" title="BIO问题分析"></a>BIO问题分析</h2><ol><li>每个请求都需要建立独立的线程，与对应的客户端进行数据的Read -&gt;业务处理 -&gt; 数据Write。</li><li>当并发数较大时，需要创建大量的线程来处理连接，系统资源占用较大。</li><li>连接建立后，如果当前线程暂时没有数据可读就阻塞在Read操作上，造成线程资源的浪费</li></ol>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2020-06-21</title>
      <link href="/p/8d5e8318.html"/>
      <url>/p/8d5e8318.html</url>
      
        <content type="html"><![CDATA[<p>这天我们说了二十句话<br>十年来的五分之一<br>剩下没有几个十年了，我和他<br>此后余生还会突然聊起天来么</p><p>想到这里我就打开了他的朋友圈。<br>只有孤零零的一条，发于一年前的今日<br>是我入围某个文学奖的新闻<br>无人点赞。没有任何共同朋友<br>因为他是我的父亲</p><p>–文珍《鲸鱼破冰》</p><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-21/%E9%92%B1%E5%A1%98%E6%B1%9F.jpg" alt="生日快乐小赵"></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>网络通信框架（2）---Mina</title>
      <link href="/p/999bcd34.html"/>
      <url>/p/999bcd34.html</url>
      
        <content type="html"><![CDATA[<p><strong><a href="https://github.com/Normcorer/MinaDemo.git" target="_blank" rel="noopener">Mina案例源码</a></strong></p><h2 id="简单的TCPServer"><a href="#简单的TCPServer" class="headerlink" title="简单的TCPServer"></a>简单的TCPServer</h2><h3 id="第一步：编写IoService"><a href="#第一步：编写IoService" class="headerlink" title="第一步：编写IoService"></a>第一步：编写IoService</h3><p>编写IoService，按照上面的执行流程，我们首先需要编写IoService，IoService 本身既是服务端，又是客户端，我们这里编写服务端，所以使用IoAcceptor 实现，由于IoAcceptor 是与协议无关的，因为我们要编写TCPServer，所以我们使用IoAcceptor 的实现NioSocketAcceptor，实际上底层就是调用java.nio.channels.ServerSocketChannel 类。当然，如果你使用了Apache 的APR 库，那么你可以选择使AprSocketAcceptor 作为TCPServer 的实现，据传说Apache APR库的性能比JVM 自带的本地库高出很多。那么IoProcessor 是由指定的IoService 内部创建并调用的，我们并不需要关心。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">IoAcceptor acceptor &#x3D; new NioSocketAcceptor();</span><br><span class="line">        acceptor.getSessionConfig().setReadBufferSize(2048);</span><br><span class="line">        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, 10);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置过滤器</span><br><span class="line">&#x2F;&#x2F;...</span><br><span class="line">&#x2F;&#x2F;设置handler</span><br><span class="line">&#x2F;&#x2F;绑定端口</span><br><span class="line">acceptor.bind(new InetSocketAddress(9124));</span><br></pre></td></tr></table></figure><p>这段代码我们初始化了服务端的TCP/IP 的基于NIO 的套接字，然后调用IoSessionConfig设置读取数据的缓冲区大小、读写通道均在10 秒内无任何操作就进入空闲状态。</p><h3 id="第二步：编写过滤器"><a href="#第二步：编写过滤器" class="headerlink" title="第二步：编写过滤器"></a>第二步：编写过滤器</h3><p>这里我们处理最简单的字符串传输，Mina 已经为我们提供了TextLineCodecFactory 编解码器工厂来对字符串进行编解码处理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 编写过滤器</span><br><span class="line">acceptor.getFilterChain().addLast(&quot;codec&quot;,</span><br><span class="line">        new ProtocolCodecFilter(new TextLineCodecFactory(Charset.forName(&quot;UTF-8&quot;),</span><br><span class="line">        LineDelimiter.WINDOWS.getValue(), </span><br><span class="line">        LineDelimiter.WINDOWS.getValue())));</span><br></pre></td></tr></table></figure><p>这段代码要在acceptor.bind()方法之前执行，因为绑定套接字之后就不能再做这些准备工作了。这里先不用清楚编解码器是如何工作的，这个是后面重点说明的内容，这里你只需要清楚，我们传输的以换行符为标识的数据，所以使用了Mina 自带的换行符编解码器工厂。</p><h3 id="第三步：编写IoHandler"><a href="#第三步：编写IoHandler" class="headerlink" title="第三步：编写IoHandler"></a>第三步：编写IoHandler</h3><p>这里我们只是简单的打印Client 传说过来的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServerHandler</span> <span class="keyword">extends</span> <span class="title">IoHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里我们使用的SLF4J作为日志门面，至于为什么在后面说明。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(TCPServerHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String str = message.toString();</span><br><span class="line">        System.out.println(<span class="string">"The message received is ["</span> + str + <span class="string">"]"</span>);</span><br><span class="line">        <span class="keyword">if</span> (str.endsWith(<span class="string">"quit"</span>)) &#123;</span><br><span class="line">            session.close(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server session created"</span>);</span><br><span class="line">        <span class="keyword">super</span>.sessionCreated(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server session Opened"</span>);</span><br><span class="line">        <span class="keyword">super</span>.sessionOpened(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionClosed</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server session Closed"</span>);</span><br><span class="line">        <span class="keyword">super</span>.sessionClosed(session);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们把这个IoHandler 注册到IoService：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;设置handler</span><br><span class="line">acceptor.setHandler(new TCPServerHandler());</span><br></pre></td></tr></table></figure><p>当然这段代码也要在acceptor.bind()方法之前执行。然后我们运行MyServer 中的main 方法，你可以看到控制台一直处于阻塞状态，等待客户端连接。<br>完成的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoAcceptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IdleStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.LineDelimiter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.TextLineCodecFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.transport.socket.nio.NioSocketAcceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        IoAcceptor acceptor = <span class="keyword">new</span> NioSocketAcceptor();</span><br><span class="line">        acceptor.getSessionConfig().setReadBufferSize(<span class="number">2048</span>);</span><br><span class="line">        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, <span class="number">10</span>);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编写过滤器</span></span><br><span class="line">        acceptor.getFilterChain().addLast(<span class="string">"codec"</span>,</span><br><span class="line">                <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> TextLineCodecFactory(Charset.forName(<span class="string">"UTF-8"</span>),</span><br><span class="line">                        LineDelimiter.WINDOWS.getValue(), </span><br><span class="line">                        LineDelimiter.WINDOWS.getValue()))</span><br><span class="line">                );</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设置handler</span></span><br><span class="line">        acceptor.setHandler(<span class="keyword">new</span> TCPServerHandler());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//绑定端口</span></span><br><span class="line">        acceptor.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9124</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：<br>此时，我们用telnet 127.0.0.1 9123 访问，然后输入一些内容，当按下回车键，你会发现数据在Server 端被输出，但要注意不要输入中文，因为Windows 的命令行窗口不会对传输的数据进行UTF-8 编码。当输入quit 结尾的字符串时，连接被断开。这里注意你如果使用的操作系统，或者使用的Telnet 软件的换行符是什么，如果不清楚，可以删掉第二步中的两个红色的参数，使用TextLineCodec 内部的自动识别机制。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- MINA集成 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.mina<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mina-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.mina<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mina-integration-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="简单的TCPClient"><a href="#简单的TCPClient" class="headerlink" title="简单的TCPClient"></a>简单的TCPClient</h2><p>这里我们实现Mina 中的TCPClient，因为前面说过无论是Server 端还是Client 端，在Mina中的执行流程都是一样的。唯一不同的就是IoService 的Client 端实现是IoConnector。</p><h3 id="第一步编写IoService并注册过滤器"><a href="#第一步编写IoService并注册过滤器" class="headerlink" title="第一步编写IoService并注册过滤器"></a>第一步编写IoService并注册过滤器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoConnector;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.LineDelimiter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.TextLineCodecFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.transport.socket.nio.NioSocketConnector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IoConnector connector = <span class="keyword">new</span> NioSocketConnector();</span><br><span class="line">        connector.setConnectTimeoutMillis(<span class="number">30000</span>);</span><br><span class="line">        connector.getFilterChain().addLast(<span class="string">"codec"</span>,</span><br><span class="line">                <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> TextLineCodecFactory(Charset.forName(<span class="string">"UTF-8"</span>),</span><br><span class="line">                        LineDelimiter.WINDOWS.getValue(), </span><br><span class="line">                        LineDelimiter.WINDOWS.getValue())));</span><br><span class="line">        </span><br><span class="line">        connector.setHandler(<span class="keyword">new</span> TCPClientHandler(<span class="string">"你好！\r\n 大家好！"</span>));</span><br><span class="line">        connector.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">9124</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第二步：编写IoHandler"><a href="#第二步：编写IoHandler" class="headerlink" title="第二步：编写IoHandler"></a>第二步：编写IoHandler</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClientHandler</span> <span class="keyword">extends</span> <span class="title">IoHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(TCPClientHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String values;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TCPClientHandler</span><span class="params">(String values)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.values = values;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(IoSession session)</span> </span>&#123;</span><br><span class="line">        session.write(values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册IoHandler：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connector.setHandler(new ClientHandler(&quot;你好！\r\n 大家好！&quot;));</span><br></pre></td></tr></table></figure><p>然后我们运行MyClient，你会发现MyServer 输出如下语句：<br>The message received is [你好！]<br>The message received is [大家好！]<br>我们看到服务端是按照收到两条消息输出的，因为我们用的编解码器是以换行符判断数据是否读取完毕的。</p><h2 id="介绍Mina的TCP的主要接口"><a href="#介绍Mina的TCP的主要接口" class="headerlink" title="介绍Mina的TCP的主要接口"></a>介绍Mina的TCP的主要接口</h2><p>通过上面的两个示例，你应该对Mina 如何编写TCP/IP 协议栈的网络通信有了一些感性的认识。</p><ol><li><p>IoService：<br>这个接口是服务端IoAcceptor、客户端IoConnector 的抽象，提供IO 服务和管理IoSession的功能，它有如下几个常用的方法：</p><p> A. TransportMetadata getTransportMetadata()：<br>这个方法获取传输方式的元数据描述信息，也就是底层到底基于什么的实现，譬如：nio、apr 等。</p><p> B. void addListener(IoServiceListener listener)：<br>这个方法可以为IoService 增加一个监听器，用于监听IoService 的创建、活动、失效、空闲、销毁，具体可以参考IoServiceListener 接口中的方法，这为你参与IoService 的生命周期提供了机会。</p><p> C. void removeListener(IoServiceListener listener)：<br>这个方法用于移除上面的方法添加的监听器。</p><p> D. void setHandler(IoHandler handler)：<br>这个方法用于向IoService 注册IoHandler，同时有getHandler()方法获取Handler。</p><p> E. Map&lt;Long,IoSession&gt; getManagedSessions()：<br>这个方法获取IoService 上管理的所有IoSession，Map 的key 是IoSession 的id。</p><p> F. IoSessionConfig getSessionConfig()：<br>这个方法用于获取IoSession 的配置对象，通过IoSessionConfig 对象可以设置Socket 连接的一些选项。</p></li><li><p>IoAcceptor：<br>这个接口是TCPServer 的接口，主要增加了void bind()监听端口、void unbind()解除对套接字的监听等方法。这里与传统的JAVA 中的ServerSocket 不同的是IoAcceptor 可以多次调用bind()方法（或者在一个方法中传入多个SocketAddress 参数）同时监听多个端口。 </p></li><li><p>IoConnector：<br>这个接口是TCPClient 的接口,主要增加了ConnectFuture connect(SocketAddressremoteAddress,SocketAddress localAddress)方法，用于与Server 端建立连接，第二个参数如果不传递则使用本地的一个随机端口访问Server 端。这个方法是异步执行的，同样的，也可以同时连接多个服务端。</p></li><li><p>IoSession：<br>这个接口用于表示Server 端与Client 端的连接，IoAcceptor.accept()的时候返回实例。<br>这个接口有如下常用的方法：</p><p> A. WriteFuture write(Object message)：<br>这个方法用于写数据，该操作是异步的。</p><p> B. CloseFuture close(boolean immediately)：<br>这个方法用于关闭IoSession，该操作也是异步的，参数指定true 表示立即关闭，否则就在所有的写操作都flush 之后再关闭。</p><p> C. Object setAttribute(Object key,Object value)：<br>这个方法用于给我们向会话中添加一些属性，这样可以在会话过程中都可以使用，类似于HttpSession 的setAttrbute()方法。IoSession 内部使用同步的HashMap 存储你添加的自定义属性</p><p> D. SocketAddress getRemoteAddress()：<br>这个方法获取远端连接的套接字地址。</p><p> E. void suspendWrite()：<br>这个方法用于挂起写操作，那么有void resumeWrite()方法与之配对。对于read()方法同样适用。</p><p> F. ReadFuture read()：<br>这个方法用于读取数据， 但默认是不能使用的， 你需要调用IoSessionConfig 的setUseReadOperation(true)才可以使用这个异步读取的方法。一般我们不会用到这个方法，因为这个方法的内部实现是将数据保存到一个BlockingQueue，假如是Server 端，因为大量的Client 端发送的数据在Server 端都这么读取，那么可能会导致内存泄漏，但对于Client，可能有的时候会比较便利。</p><p> G. IoService getService()：<br>这个方法返回与当前会话对象关联的IoService 实例。<br>关于TCP连接的关闭：<br>无论在客户端还是服务端，IoSession 都用于表示底层的一个TCP 连接，那么你会发现无论是Server 端还是Client 端的IoSession 调用close()方法之后，TCP 连接虽然显示关闭， 但主线程仍然在运行，也就是JVM 并未退出，这是因为IoSession 的close()仅仅是关闭了TCP的连接通道，并没有关闭Server 端、Client 端的程序。你需要调用IoService 的dispose()方法停止Server 端、Client 端。</p></li><li><p>IoSessionConfig：<br>这个方法用于指定此次会话的配置，它有如下常用的方法：</p><p> A. void setReadBufferSize(int size)：<br>这个方法设置读取缓冲的字节数，但一般不需要调用这个方法，因为IoProcessor 会自动调整缓冲的大小。你可以调用setMinReadBufferSize()、setMaxReadBufferSize()方法，这样无论IoProcessor 无论如何自动调整，都会在你指定的区间。</p><p> B. void setIdleTime(IdleStatus status,int idleTime)：<br>这个方法设置关联在通道上的读、写或者是读写事件在指定时间内未发生，该通道就进入空闲状态。一旦调用这个方法，则每隔idleTime 都会回调过滤器、IoHandler 中的sessionIdle()方法。</p><p> C. void setWriteTimeout(int time)：<br>这个方法设置写操作的超时时间</p><p> D. void setUseReadOperation(boolean useReadOperation)：<br>这个方法设置IoSession 的read()方法是否可用，默认是false。</p></li><li><p>IoHandler：<br>这个接口是你编写业务逻辑的地方，从上面的示例代码可以看出，读取数据、发送数据基本都在这个接口总完成，这个实例是绑定到IoService 上的，有且只有一个实例（没有给一个IoService 注入一个IoHandler 实例会抛出异常）。它有如下几个方法：</p><p> A. void sessionCreated(IoSession session)：<br>这个方法当一个Session 对象被创建的时候被调用。对于TCP 连接来说，连接被接受的时候调用，但要注意此时TCP 连接并未建立，此方法仅代表字面含义，也就是连接的对象IoSession 被创建完毕的时候，回调这个方法。对于UDP 来说，当有数据包收到的时候回调这个方法，因为UDP 是无连接的。</p><p> B. void sessionOpened(IoSession session)：<br>这个方法在连接被打开时调用，它总是在sessionCreated()方法之后被调用。对于TCP 来说，它是在连接被建立之后调用，你可以在这里执行一些认证操作、发送数据等。对于UDP 来说，这个方法与sessionCreated()没什么区别，但是紧跟其后执行。如果你每隔一段时间，发送一些数据，那么sessionCreated()方法只会在第一次调用，但是sessionOpened()方法每次都会调用。</p><p> C. void sessionClosed(IoSession session) ：<br>对于TCP 来说，连接被关闭时，调用这个方法。对于UDP 来说，IoSession 的close()方法被调用时才会毁掉这个方法。</p><p> D. void sessionIdle(IoSession session, IdleStatus status) ：<br>这个方法在IoSession 的通道进入空闲状态时调用，对于UDP 协议来说，这个方法始终不会被调用。</p><p> E. void exceptionCaught(IoSession session, Throwable cause) ：<br>这个方法在你的程序、Mina 自身出现异常时回调，一般这里是关闭IoSession。</p><p> F. void messageReceived(IoSession session, Object message) ：<br>接收到消息时调用的方法，也就是用于接收消息的方法，一般情况下，message 是一个IoBuffer 类，如果你使用了协议编解码器，那么可以强制转换为你需要的类型。通常我们都是会使用协议编解码器的， 就像上面的例子， 因为协议编解码器是<br>TextLineCodecFactory，所以我们可以强制转message 为String 类型。</p><p> G. void messageSent(IoSession session, Object message) ：<br>当发送消息成功时调用这个方法，注意这里的措辞，发送成功之后，也就是说发送消息是不能用这个方法的。<br>发送消息的时机：<br>发送消息应该在sessionOpened()、messageReceived()方法中调用IoSession.write()方法完成。因为在sessionOpened()方法中，TCP 连接已经真正打开，同样的在messageReceived()方法TCP 连接也是打开状态，只不过两者的时机不同。sessionOpened()方法是在TCP 连接建立之后，接收到数据之前发送；messageReceived()方法是在接收到数据之后发送，你可以完成依据收到的内容是什么样子，决定发送什么样的数据。因为这个接口中的方法太多，因此通常使用适配器模式IoHandlerAdapter，覆盖你所感兴趣的方法即可。</p></li><li><p>IoBuffer：<br>这个接口是对JAVA NIO 的ByteBuffer 的封装，这主要是因为ByteBuffer 只提供了对基本数据类型的读写操作，没有提供对字符串等对象类型的读写方法，使用起来更为方便，另外，ByteBuffer 是定长的，如果想要可变，将很麻烦。IoBuffer 的可变长度的实现类似于StringBuffer。IoBuffer 与ByteBuffer 一样，都是非线程安全的。本节的一些内容如果不清楚，可以参考java.nio.ByteBuffer 接口。这个接口有如下常用的方法：</p><p> A. static IoBuffer allocate(int capacity,boolean useDirectBuffer)：<br>这个方法内部通过SimpleBufferAllocator 创建一个实例，第一个参数指定初始化容量，第二个参数指定使用直接缓冲区还是JAVA 内存堆的缓存区，默认为false。</p><p> B. void free()：<br>释放缓冲区，以便被一些IoBufferAllocator 的实现重用，一般没有必要调用这个方法，除非你想提升性能（但可能未必效果明显。</p><p> C. IoBuffer setAutoExpand(boolean autoExpand)：<br>这个方法设置IoBuffer 为自动扩展容量，也就是前面所说的长度可变，那么可以看出长度可变这个特性默认是不开启的。</p><p> D. IoBuffer setAutoShrink(boolean autoShrink)：<br>这个方法设置IoBuffer 为自动收缩，这样在compact()方法调用之后，可以裁减掉一些没有使用的空间。如果这个方法没有被调用或者设置为false，你也可以通过调用shrink()方法手动收缩空间。</p><p> E. IoBuffer order(ByteOrder bo)：<br>这个方法设置是Big Endian 还是Little Endian，JAVA 中默认是Big Endian，C++和其他语言一般是Little Endian。</p><p> F. IoBuffer asReadOnlyBuffer()：<br>这个方法设置IoBuffer 为只读的。</p><p> G. Boolean prefixedDataAvailable(int prefixLength,int maxDataLength)：<br>这个方法用于数据的最开始的1、2、4 个字节表示的是数据的长度的情况，<br>prefixLentgh表示这段数据的前几个字节（只能是1、2、4 的其中一个），代表的是这段数据的长度，<br>maxDataLength 表示最多要读取的字节数。返回结果依赖于等式<br>remaining()-prefixLength&gt;=maxDataLength，也就是总的数据-表示长度的字节，剩下的字节数要比打算读取的字节数大或者相等。</p><p> H. String getPrefixedString(int prefixLength,CharsetDecoder decoder)：<br>如果上面的方法返回true，那么这个方法将开始读取表示长度的字节之后的数据，注意要保持这两个方法的prefixLength 的值是一样的。</p><p> G、H 两个方法在后面讲到的PrefixedStringDecoder 中的内部实现使用。<br>IoBuffer 剩余的方法与ByteBuffer 都是差不多的，额外增加了一些便利的操作方法，例如：<br>IoBuffer putString(String value,CharsetEncoder encoder)可以方便的以指定的编码方式存储字符串、InputStream asInputStream()方法从IoBuffer 剩余的未读的数据中转为输入流等。</p></li><li><p>IoFuture：<br>在Mina 的很多操作中，你会看到返回值是XXXFuture，实际上他们都是IoFuture 的子类，看到这样的返回值，这个方法就说明是异步执行的，主要的子类有ConnectFuture、CloseFuture 、ReadFuture 、WriteFuture 。这个接口的大部分操作都和<br>java.util.concurrent.Future 接口是类似的，譬如：await()、awaitUninterruptibly()等，一般我们常用awaitUninterruptibly()方法可以等待异步执行的结果返回。这个接口有如下常用的方法：</p><p> A. IoFuture addListener(IoFutureListener<?> listener)：`这个方法用于添加一个监听器， 在异步执行的结果返回时监听器中的回调方法operationComplete(IoFuture future)，也就是说，这是替代awaitUninterruptibly()方法另一种等待异步执行结果的方法，它的好处是不会产生阻塞。` B. IoFuture removeListener(IoFutureListener<?> listener)：<br>这个方法用于移除指定的监听器。</p><p> C. IoSession getSession()：<br>这个方法返回当前的IoSession。举个例子，我们在客户端调用connect()方法访问Server 端的时候，实际上这就是一个异步执行的方法，也就是调用connect()方法之后立即返回，执行下面的代码，而不管是否连接成功。那么如果我想在连接成功之后执行一些事情（譬如：获取连接成功后的IoSession对象），该怎么办呢？按照上面的说明，你有如下两种办法：</p></li></ol><ul><li>第一种 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.future.ConnectFuture;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoConnector;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.LineDelimiter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.TextLineCodecFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.transport.socket.nio.NioSocketConnector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dxz.minademo2.TCPClientHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IoConnector connector = <span class="keyword">new</span> NioSocketConnector();</span><br><span class="line">        connector.setConnectTimeoutMillis(<span class="number">30000</span>);</span><br><span class="line">        connector.getFilterChain().addLast(<span class="string">"codec"</span>,</span><br><span class="line">                <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> TextLineCodecFactory(Charset.forName(<span class="string">"UTF-8"</span>),</span><br><span class="line">                        LineDelimiter.WINDOWS.getValue(), </span><br><span class="line">                        LineDelimiter.WINDOWS.getValue())));</span><br><span class="line">        </span><br><span class="line">        connector.setHandler(<span class="keyword">new</span> TCPClientHandler(<span class="string">"你好！\r\n 大家好！"</span>));    </span><br><span class="line">        </span><br><span class="line">        ConnectFuture future = connector.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">9124</span>));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 等待是否连接成功，相当于是转异步执行为同步执行。    </span></span><br><span class="line">        future.awaitUninterruptibly();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 连接成功后获取会话对象。如果没有上面的等待，由于connect()方法是异步的，session可能会无法获取。    </span></span><br><span class="line">        IoSession session = future.getSession(); </span><br><span class="line">        System.out.println(session);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>第二种 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.future.ConnectFuture;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.future.IoFutureListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoConnector;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.LineDelimiter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.TextLineCodecFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.transport.socket.nio.NioSocketConnector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dxz.minademo2.TCPClientHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IoConnector connector = <span class="keyword">new</span> NioSocketConnector();</span><br><span class="line">        connector.setConnectTimeoutMillis(<span class="number">30000</span>);</span><br><span class="line">        connector.getFilterChain().addLast(<span class="string">"codec"</span>,</span><br><span class="line">                <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> TextLineCodecFactory(Charset.forName(<span class="string">"UTF-8"</span>),</span><br><span class="line">                        LineDelimiter.WINDOWS.getValue(), LineDelimiter.WINDOWS.getValue())));</span><br><span class="line"></span><br><span class="line">        connector.setHandler(<span class="keyword">new</span> TCPClientHandler(<span class="string">"你好！\r\n 大家好！"</span>));</span><br><span class="line">        ConnectFuture future = connector.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">9124</span>));</span><br><span class="line">        future.addListener(<span class="keyword">new</span> IoFutureListener&lt;ConnectFuture&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ConnectFuture future)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                IoSession session = future.getSession();</span><br><span class="line">                System.out.println(<span class="string">"++++++++++++++++++++++++++++"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>结果<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*************</span><br><span class="line">++++++++++++++++++++++++++++</span><br></pre></td></tr></table></figure></li></ul><h2 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h2><p>前面的示例代码中提到了使用SLF4J 作为日志门面，这是<code>因为Mina 内部使用的就是SLF4J</code>，你也使用SLF4J 可以与之保持一致性。Mina 如果想启用日志跟踪Mina 的运行细节，你可以配置LoggingFilter 过滤器，这样你可以看到Session 建立、打开、空闲等一系列细节在日志中输出，默认SJF4J 是按照DEBUG级别输出跟踪信息的，如果你想给某一类别的Mina 运行信息输出指定日志输出级别，可以调用LoggingFilter 的setXXXLogLevel(LogLevel.XXX)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LoggingFilter lf &#x3D; new LoggingFilter();    </span><br><span class="line">lf.setSessionOpenedLogLevel(LogLevel.ERROR);    </span><br><span class="line">acceptor.getFilterChain().addLast(&quot;logger&quot;, lf);</span><br></pre></td></tr></table></figure><p>这里IoSession 被打开的跟踪信息将以ERROR 级别输出到日志。</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>前面我们看到了LoggingFilter、ProtocolCodecFilter 两个过滤器，一个负责日志输出，一个负责数据的编解码，通过最前面的Mina 执行流程图，在IoProcessor 与IoHandler 之间可以有很多的过滤器，这种设计方式为你提供可插拔似的扩展功能提供了非常便利的方式，目前的Apache CXF、Apache Struts2 中的拦截器也都是一样的设计思路。Mina 中的IoFilter 是单例的，这与CXF、Apache Struts2 没什么区别。IoService 实例上会绑定一个DefaultIoFilterChainBuilder 实例，DefaultIoFilterChainBuilder 会把使用内部的EntryImpl 类把所有的过滤器按照顺序连在一起，组成一个过滤器链。<br>DefaultIoFilterChainBuilder 类如下常用的方法：</p><p>A. void addFirst(String name,IoFilter filter)：<br>这个方法把过滤器添加到过滤器链的头部，头部就是IoProcessor 之后的第一个过滤器。同样的addLast()方法把过滤器添加到过滤器链的尾部。</p><p>B. void addBefore(String baseName,String name,IoFilter filter)：<br>这个方法将过滤器添加到baseName 指定的过滤器的前面，同样的addAfter()方法把过滤器添加到baseName 指定的过滤器的后面。这里要注意无论是那种添加方法，每个过滤器的名字（参数name）必须是唯一的。</p><p>C. IoFilter remove(Stirng name)：<br>这个方法移除指定名称的过滤器，你也可以调用另一个重载的remove()方法，指定要移除的IoFilter 的类型。</p><p>D. List<Entry> getAll()：<br>这个方法返回当前IoService 上注册的所有过滤器。默认情况下，过滤器链中是空的，也就是getAll()方法返回长度为0 的List，但实际Mina内部有两个隐藏的过滤器：HeadFilter、TailFilter，分别在List 的最开始和最末端，很明显，TailFilter 在最末端是为了调用过滤器链之后，调用IoHandler。但这两个过滤器对你来说是透明的，可以忽略它们的存在。编写一个过滤器很简单，你需要实现IoFilter 接口，如果你只关注某几个方法，可以继承IoFilterAdapter 适配器类。IoFilter 接口中主要包含两类方法，一类是与IoHandler 中的方法名一致的方法，相当于拦截IoHandler 中的方法，另一类是IoFilter 的生命周期回调方法，这些回调方法的执行顺序和解释如下所示：</p><ol><li>init()在首次添加到链中的时候被调用，但你必须将这个IoFilter 用<br>ReferenceCountingFilter 包装起来，否则init()方法永远不会被调用。</li><li>onPreAdd()在调用添加到链中的方法时被调用，但此时还未真正的加入到链。</li><li>onPostAdd()在调用添加到链中的方法后被调，如果在这个方法中有异常抛出，则过滤器会立即被移除，同时destroy()方法也会被调用（前提是使用ReferenceCountingFilter包装）。</li><li>onPreRemove()在从链中移除之前调用。</li><li>onPostRemove()在从链中移除之后调用。</li><li>destory()在从链中移除时被调用，使用方法与init()要求相同。<br>无论是哪个方法，要注意必须在实现时调用参数nextFilter 的同名方法，否则，过滤器链的执行将被中断，IoHandler 中的同名方法一样也不会被执行，这就相当于Servlet 中的Filter 必须调用filterChain.doFilter(request,response)才能继续前进是一样的道理。<br>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.filterchain.IoFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.filterchain.IoFilterChain;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IdleStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.write.WriteRequest;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIoFilter</span> <span class="keyword">implements</span> <span class="title">IoFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%�stroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(NextFilter nextFilter, IoSession session, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%exceptionCaught"</span>);</span><br><span class="line">        nextFilter.exceptionCaught(session, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filterClose</span><span class="params">(NextFilter nextFilter, IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%filterClose"</span>);</span><br><span class="line">        nextFilter.filterClose(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">filterWrite</span><span class="params">(NextFilter nextFilter, IoSession session, WriteRequest writeRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%filterWrite"</span>);</span><br><span class="line">        nextFilter.filterWrite(session, writeRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%init"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(NextFilter nextFilter, IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%messageReceived"</span>);</span><br><span class="line">        nextFilter.messageReceived(session, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageSent</span><span class="params">(NextFilter nextFilter, IoSession session, WriteRequest writeRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%messageSent"</span>);</span><br><span class="line">        nextFilter.messageSent(session, writeRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostAdd</span><span class="params">(IoFilterChain parent, String name, NextFilter nextFilter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%onPostAdd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPostRemove</span><span class="params">(IoFilterChain parent, String name, NextFilter nextFilter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%onPostRemove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreAdd</span><span class="params">(IoFilterChain parent, String name, NextFilter nextFilter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%onPreAdd"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPreRemove</span><span class="params">(IoFilterChain parent, String name, NextFilter nextFilter)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%onPreRemove"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionClosed</span><span class="params">(NextFilter nextFilter, IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%sessionClosed"</span>);</span><br><span class="line">        nextFilter.sessionClosed(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionCreated</span><span class="params">(NextFilter nextFilter, IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%sessionCreated"</span>);</span><br><span class="line">        nextFilter.sessionCreated(session);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionIdle</span><span class="params">(NextFilter nextFilter, IoSession session, IdleStatus status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%sessionIdle"</span>);</span><br><span class="line">        nextFilter.sessionIdle(session, status);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(NextFilter nextFilter, IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"%%%%%%%%%%%%%%%%%%%%%%%%%%%sessionOpened"</span>);</span><br><span class="line">        nextFilter.sessionOpened(session);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>我们将这个拦截器注册到上面的TCPServer 的IoAcceptor 的过滤器链中的最后一个：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">acceptor.getFilterChain().addLast(&quot;myIoFilter&quot;, new ReferenceCountingFilter(new MyIoFilter()));</span><br></pre></td></tr></table></figure>这里我们将MyIoFilter 用ReferenceCountingFilter 包装起来，这样你可以看到init()、destroy()方法调用。我们启动客户端访问，然后关闭客户端，你会看到执行顺序如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%init</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%onPreAdd</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%onPostAdd</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%sessionCreated</span><br><span class="line">server session created</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%sessionOpened</span><br><span class="line">server session Opened</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%messageReceived</span><br><span class="line">The message received is [你好！]</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%messageReceived</span><br><span class="line">The message received is [ 大家好！]</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%sessionIdle</span><br></pre></td></tr></table></figure>IoHandler 的对应方法会跟在上面的对应方法之后执行，这也就是说从横向（单独的看一个过滤器中的所有方法的执行顺序）上看，每个过滤器的执行顺序是上面所示的顺序；从纵向（方法链的调用）上看，如果有filter1、filter2 两个过滤器，sessionCreated()方法的执行顺序如下所示：</li></ol><p>filter1-sessionCreated filter2-sessionCreated IoHandler-sessionCreated。<br>这里你要注意init、onPreAdd、onPostAdd 三个方法并不是在Server 启动时调用的，而是IoSession 对象创建之前调用的，也就是说IoFilterChain.addXXX()方法仅仅负责初始化过滤器并注册过滤器，但并不调用任何方法，包括init()初始化方法也是在IoProcessor 开始工作的时候被调用。IoFilter 是单例的，那么init()方法是否只被执行一次呢？这个是不一定的，因为IoFilter是被IoProcessor 调用的，而每个IoService 通常是关联多个IoProcessor，所以IoFilter的init()方法是在每个IoProcessor 线程上只执行一次。关于Mina 的线程问题，我们后面会详细讨论，这里你只需要清楚，init()与destroy()的调用次数与IoProceesor 的个数有关，假如一个IoService 关联了3 个IoProcessor，有五个并发的客户端请求，那么你会看到三次init()方法被调用，以后将不再会调用。Mina中自带的过滤器：<br>过滤器 说明<br>BlacklistFilter 设置一些IP 地址为黑名单，不允许访问。<br>BufferedWriteFilter 设置输出时像BufferedOutputStream 一样进行缓冲。<br>CompressionFilter 设置在输入、输出流时启用JZlib 压缩。<br>ConnectionThrottleFilter 这个过滤器指定同一个IP 地址（不含端口号）上的请求在多长的毫秒值内可以有一个请求，如果小于指定的时间间隔就有连续两个请求，那么第二个请求将被忽略（IoSession.close()）。正如Throttle 的名字一样，调节访问的频率这个过滤器最好放在过滤器链的前面。<br>FileRegionWriteFilter 如果你想使用File 对象进行输出，请使用这个过滤器。要注意，你需要使用WriteFuture 或者在<br>messageSent() 方法中关闭File 所关联的FileChannel 通道。<br>StreamWriteFilter 如果你想使用InputStream 对象进行输出，请使用这个过滤器。要注意，你需要使用WriteFuture或者在messageSent()方法中关闭File 所关联的<br>FileChannel 通道。NoopFilter 这个过滤器什么也不做，如果你想测试过滤器链是否起作用，可以用它来测试。<br>ProfilerTimerFilter 这个过滤器用于检测每个事件方法执行的时间，所以最好放在过滤器链的前面。<br>ProxyFilter 这个过滤器在客户端使用ProxyConnector 作为实现时，会自动加入到过滤器链中，用于完成代理功能。<br>RequestResponseFilter 暂不知晓。</p><p>SessionAttributeInitializingFilter 这个过滤器在IoSession 中放入一些属性（Map），通常放在过滤器的前面，用于放置一些初始化的信息。<br>MdcInjectionFilter 针对日志输出做MDC 操作，可以参考LOG4J 的MDC、NDC 的文档。<br>WriteRequestFilter CompressionFilter、RequestResponseFilter 的基类，用于包装写请求的过滤器。<br>还有一些过滤器，会在各节中详细讨论，这里没有列出，譬如：前面的LoggingFilger 日志过滤器。</p><h2 id="协议编解码器"><a href="#协议编解码器" class="headerlink" title="协议编解码器"></a>协议编解码器</h2><p>multiplex：英 [ˈmʌltɪpleks] 美 [ˈmʌltəˌplɛks] adj.多元的，多倍的，复式的;多部的，复合的，多样的，多重的;；[电讯]多路传输的n.多路;多厅影院，多剧场影剧院v.多路传输，多路复用;多重发讯<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-20/%E5%8D%8F%E8%AE%AE%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8.png" alt="协议编解码器"></p><p>前面说过，协议编解码器是在使用Mina 的时候你最需要关注的对象，因为在网络传输的数据都是二进制数据（byte），而你在程序中面向的是JAVA 对象，这就需要你实现在发送数据时将JAVA 对象编码二进制数据，而接收数据时将二进制数据解码为JAVA 对象（这个可不是JAVA 对象的序列化、反序列化那么简单的事情）。Mina 中的协议编解码器通过过滤器ProtocolCodecFilter 构造，这个过滤器的构造方法需要一个ProtocolCodecFactory，这从前面注册TextLineCodecFactory 的代码就可以看出来。<br>ProtocolCodecFactory 中有如下两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProtocolCodecFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">ProtocolEncoder <span class="title">getEncoder</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function">ProtocolDecoder <span class="title">getDecoder</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，构建一个ProtocolCodecFactory 需要ProtocolEncoder、ProtocolDecoder 两个实例。你可能要问JAVA 对象和二进制数据之间如何转换呢？这个要依据具体的通信协议，也就是Server 端要和Client 端约定网络传输的数据是什么样的格式，譬如：第一个字节表示数据长度，第二个字节是数据类型，后面的就是真正的数据（有可能是文字、有可能是图片等等），然后你可以依据长度从第三个字节向后读，直到读取到指定第一个字节指定长度的数据。<br>简单的说，HTTP 协议就是一种浏览器与Web 服务器之间约定好的通信协议，双方按照指定的协议编解码数据。我们再直观一点儿说，前面一直使用的TextLine 编解码器就是在读取网络上传递过来的数据时，只要发现哪个字节里存放的是ASCII 的10、13 字符（/r、/n），就认为之前的字节就是一个字符串（默认使用UTF-8 编码）。以上所说的就是各种协议实际上就是网络七层结构中的应用层协议，它位于网络层（IP）、传输层（TCP）之上，Mina 的协议编解码器就是让你实现一套自己的应用层协议栈。</p><h3 id="简单编解码器示例"><a href="#简单编解码器示例" class="headerlink" title="简单编解码器示例"></a>简单编解码器示例</h3><p>下面我们举一个模拟电信运营商短信协议的编解码器实现，假设通信协议如下所示：<br>M sip:wap.fetion.com.cn SIP-C/2.0<br>S: 1580101xxxx<br>R: 1889020xxxx</p><p>L: 21<br>Hello World!<br>这里的第一行表示状态行，一般表示协议的名字、版本号等，第二行表示短信的发送号码，第三行表示短信接收的号码，第四行表示短信的字节数，最后的内容就是短信的内容。上面的每一行的末尾使用ASC II 的10（/n）作为换行符，因为这是纯文本数据，协议要<br>求双方使用UTF-8 对字符串编解码。实际上如果你熟悉HTTP 协议，上面的这个精简的短信协议和HTTP 协议的组成是非常像的，第一行是状态行，中间的是消息报头，最后面的是消息正文。在解析这个短信协议之前，你需要知晓TCP 的一个事项，那就是数据的发送没有规模性，所谓的规模性就是作为数据的接收端，不知道到底什么时候数据算是读取完毕，所以应用层协议在制定的时候，必须指定数据读取的截至点。一般来说，有如下三种方式设置数据读取的长度：</p><ol><li>使用分隔符，譬如：TextLine 编解码器。你可以使用/r、/n、NUL 这些ASC II 中的特殊的字符来告诉数据接收端，你只要遇见分隔符，就表示数据读完了，不用在那里傻等着不知道还有没有数据没读完啊？我可不可以开始把已经读取到的字节解码为指定的数据类型了啊？</li><li>定长的字节数，这种方式是使用长度固定的数据发送，一般适用于指令发送，譬如：数据发送端规定发送的数据都是双字节，AA 表示启动、BB 表示关闭等等。</li><li>在数据中的某个位置使用一个长度域，表示数据的长度，这种处理方式最为灵活，上面的短信协议中的那个L 就是短信文字的字节数，其实HTTP 协议的消息报头中的Content-Length 也是表示消息正文的长度，这样数据的接收端就知道我到底读到多长的<br>字节数就表示不用再读取数据了。相比较解码（字节转为JAVA 对象，也叫做拆包）来说，编码（JAVA 对象转为字节，也叫做打包）就很简单了，你只需要把JAVA 对象转为指定格式的字节流，write()就可以了。下面我们开始对上面的短信协议进行编解码处理。</li></ol><ul><li>第一步，协议对象：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String sender;<span class="comment">// 短信发送者</span></span><br><span class="line">    <span class="keyword">private</span> String receiver;<span class="comment">// 短信接受者</span></span><br><span class="line">    <span class="keyword">private</span> String message;<span class="comment">// 短信内容</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSender</span><span class="params">(String sender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sender = sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReceiver</span><span class="params">(String receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>第二步，编码器：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.buffer.IoBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolEncoderAdapter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolEncoderOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CmccSipcEncoder</span> <span class="keyword">extends</span> <span class="title">ProtocolEncoderAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Charset charset;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CmccSipcEncoder</span><span class="params">(Charset charset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.charset = charset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(IoSession session, Object message, ProtocolEncoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SmsObject sms = (SmsObject) message;</span><br><span class="line">        CharsetEncoder ce = charset.newEncoder();</span><br><span class="line">        IoBuffer buffer = IoBuffer.allocate(<span class="number">100</span>).setAutoExpand(<span class="keyword">true</span>);</span><br><span class="line">        String statusLine = <span class="string">"M sip:wap.fetion.com.cn SIP-C/2.0"</span>;</span><br><span class="line">        String sender = sms.getSender();</span><br><span class="line">        String receiver = sms.getReceiver();</span><br><span class="line">        String smsContent = sms.getMessage();</span><br><span class="line">        buffer.putString(statusLine + <span class="string">'\n'</span>, ce);</span><br><span class="line">        buffer.putString(<span class="string">"S: "</span> + sender + <span class="string">'\n'</span>, ce);</span><br><span class="line">        buffer.putString(<span class="string">"R: "</span> + receiver + <span class="string">'\n'</span>, ce);</span><br><span class="line">        buffer.putString(<span class="string">"L: "</span> + (smsContent.getBytes(charset).length) + <span class="string">"\n"</span>, ce);</span><br><span class="line">        buffer.putString(smsContent, ce);</span><br><span class="line">        buffer.flip();</span><br><span class="line">        out.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>这里我们依据传入的字符集类型对message 对象进行编码，编码的方式就是按照短信协议拼装字符串到IoBuffer 缓冲区，然后调用ProtocolEncoderOutput 的write()方法输出字节流。这里要注意生成短信内容长度时的红色代码，我们使用String 类与Byte[]类型之间的转换方法获得转为字节流后的字节数。<br>编码器的编写有以下几个步骤：</li></ul><ol><li>将 encode()方法中的message 对象强制转换为指定的对象类型；</li><li>创建IoBuffer 缓冲区对象，并设置为自动扩展；</li><li>将转换后的message 对象中的各个部分按照指定的应用层协议进行组装，并put()到IoBuffer 缓冲区；</li><li>当你组装数据完毕之后，调用flip()方法，为输出做好准备，切记在write()方法之前，要调用IoBuffer 的flip()方法，否则缓冲区的position 的后面是没有数据可以用来输出的，你必须调用flip()方法将position 移至0，limit 移至刚才的position。这个flip()方法的含义请参看java.nio.ByteBuffer。</li><li>最后调用ProtocolEncoderOutput 的write()方法输出IoBuffer 缓冲区实例。</li></ol><ul><li>第三步，解码器：<br>在Mina 中编写解码器，可以实现ProtocolDecoder 接口，其中有decode()、finishDecode()、dispose()三个方法。这里的finishDecode()方法可以用于处理在IoSession 关闭时剩余的未读取数据，一般这个方法并不会被使用到，除非协议中未定义任何标识数据什么时候截止的约定，譬如：Http 响应的Content-Length 未设定，那么在你认为读取完数据后，关闭TCP连接（IoSession 的关闭）后，就可以调用这个方法处理剩余的数据，当然你也可以忽略调剩余的数据。同样的，一般情况下，我们只需要继承适配器ProtocolDecoderAdapter，关注decode()方法即可。但前面说过解码器相对编码器来说，最麻烦的是数据发送过来的规模，以聊天室为例，一个TCP 连接建立之后，那么隔一段时间就会有聊天内容发送过来，也就是decode()方法会被往复调用，这样处理起来就会非常麻烦。<code>那么Mina 中幸好提供了CumulativeProtocolDecoder类，从名字上可以看出累积性的协议解码器</code>，也就是说只要有数据发送过来，这个类就会去读取数据，然后累积到内部的IoBuffer 缓冲区，但是具体的拆包（把累积到缓冲区的数据解码为JAVA 对象）交由子类的doDecode()方法完成，实际上CumulativeProtocolDecoder就是在decode()反复的调用暴漏给子类实现的doDecode()方法。<br>具体执行过程如下所示：</li></ul><ol><li>你的doDecode()方法返回true 时，CumulativeProtocolDecoder 的decode()方法会首先判断你是否在doDecode()方法中从内部的IoBuffer 缓冲区读取了数据，如果没有，则会抛出非法的状态异常，也就是你的doDecode()方法返回true 就表示你已经消费了本次数据（相当于聊天室中一个完整的消息已经读取完毕），进一步说，也就是此时你必须已经消费过内部的IoBuffer 缓冲区的数据（哪怕是消费了一个字节的数据）。如果验证过通过，那么CumulativeProtocolDecoder 会检查缓冲区内是否还有数据未读取，如果有就继续调用doDecode()方法，没有就停止对doDecode()方法的调用，直到有新的数据被缓冲。</li><li>当你的doDecode()方法返回false 时，CumulativeProtocolDecoder 会停止对doDecode()方法的调用，<code>但此时如果本次数据还有未读取完的，就将含有剩余数据的IoBuffer 缓冲区保存到IoSession 中，以便下一次数据到来时可以从IoSession 中提取合并。</code>如果发现本次数据全都读取完毕，则清空IoBuffer 缓冲区。简而言之，当你认为读取到的数据已经够解码了，那么就返回true，否则就返回false。<code>这个CumulativeProtocolDecoder 其实最重要的工作就是帮你完成了数据的累积，因为这个工作是很烦琐的。</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.buffer.IoBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.CumulativeProtocolDecoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolDecoderOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CmccSipcDecoder</span> <span class="keyword">extends</span> <span class="title">CumulativeProtocolDecoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Charset charset;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CmccSipcDecoder</span><span class="params">(Charset charset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.charset = charset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doDecode</span><span class="params">(IoSession session, IoBuffer in, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        IoBuffer buffer = IoBuffer.allocate(<span class="number">100</span>).setAutoExpand(<span class="keyword">true</span>);</span><br><span class="line">        CharsetDecoder cd = charset.newDecoder();</span><br><span class="line">        <span class="keyword">int</span> matchCount = <span class="number">0</span>;</span><br><span class="line">        String statusLine = <span class="string">""</span>, sender = <span class="string">""</span>, receiver = <span class="string">""</span>, length = <span class="string">""</span>, sms = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (in.hasRemaining()) &#123;</span><br><span class="line">            <span class="keyword">byte</span> b = in.get();</span><br><span class="line">            buffer.put(b);</span><br><span class="line">            <span class="keyword">if</span> (b == <span class="number">10</span> &amp;&amp; i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">                matchCount++;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    statusLine = buffer.getString(matchCount, cd);</span><br><span class="line">                    statusLine = statusLine.substring(<span class="number">0</span>, statusLine.length() - <span class="number">1</span>);</span><br><span class="line">                    matchCount = <span class="number">0</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    sender = buffer.getString(matchCount, cd);</span><br><span class="line">                    sender = sender.substring(<span class="number">0</span>, sender.length() - <span class="number">1</span>);</span><br><span class="line">                    matchCount = <span class="number">0</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">3</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    receiver = buffer.getString(matchCount, cd);</span><br><span class="line">                    receiver = receiver.substring(<span class="number">0</span>, receiver.length() - <span class="number">1</span>);</span><br><span class="line">                    matchCount = <span class="number">0</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    length = buffer.getString(matchCount, cd);</span><br><span class="line">                    length = length.substring(<span class="number">0</span>, length.length() - <span class="number">1</span>);</span><br><span class="line">                    matchCount = <span class="number">0</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                &#125;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">                matchCount++;</span><br><span class="line">                <span class="keyword">if</span> (matchCount == Long.parseLong(length.split(<span class="string">": "</span>)[<span class="number">1</span>])) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    sms = buffer.getString(matchCount, cd);</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                matchCount++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        SmsObject smsObject = <span class="keyword">new</span> SmsObject();</span><br><span class="line">        smsObject.setSender(sender.split(<span class="string">": "</span>)[<span class="number">1</span>]);</span><br><span class="line">        smsObject.setReceiver(receiver.split(<span class="string">": "</span>)[<span class="number">1</span>]);</span><br><span class="line">        smsObject.setMessage(sms);</span><br><span class="line">        out.write(smsObject);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>我们的这个短信协议解码器使用/n（ASCII 的10 字符）作为分解点，一个字节一个字节的读取，那么第一次发现/n 的字节位置之前的部分，必然就是短信协议的状态行，依次类推，你就可以解析出来发送者、接受者、短信内容长度。然后我们在解析短信内容时，使用获取到的长度进行读取。全部读取完毕之后， 然后构造SmsObject 短信对象， 使用ProtocolDecoderOutput 的write()方法输出，最后返回false，也就是本次数据全部读取完毕，告知CumulativeProtocolDecoder 在本次数据读取中不需要再调用doDecode()方法了。这里需要注意的是两个状态变量i、matchCount，i 用于记录解析到了短信协议中的哪一行（/n），matchCount 记录在当前行中读取到了哪一个字节。状态变量在解码器中经常被使用，我们这里的情况比较简单，因为我们假定短信发送是在一次数据发送中完成的，所以状态变量的使用也比较简单。假如数据的发送被拆成了多次（譬如：短信协议的短信内容、消息报头被拆成了两次数据发送），那么上面的代码势必就会存在问题，因为当第二次调用doDecode()方法时，状态变量i、matchCount 势必会被重置，也就是原来的状态值并没有被保存。那么我们如何解决状态保存的问题呢？答案就是将状态变量保存在IoSession 中或者是Decoder 实例自身，但推荐使用前者，因为虽然Decoder 是单例的，其中的实例变量保存的状态在Decoder 实例销毁前始终保持，但Mina 并不保证每次调用doDecode()方法时都是同一个线程（这也就是说第一次调用doDecode()是IoProcessor-1 线程，第二次有可能就是IoProcessor-2 线程），这就会产生多线程中的实例变量的可视性（Visibility，具体请参考JAVA 的多线程知识）问题。IoSession中使用一个同步的HashMap 保存对象，所以你不需要担心多线程带来的问题。使用IoSession 保存解码器的状态变量通常的写法如下所示：</li><li>在解码器中定义私有的内部类Context，然后将需要保存的状态变量定义在Context 中存储。</li><li>在解码器中定义方法获取这个Context 的实例，这个方法的实现要优先从IoSession 中获取Context。<br>具体代码示例如下所示：<br>// 上下文作为保存状态的内部类的名字，意思很明显，就是让状态跟随上下文，在整个调用过程中都可以被保持。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.buffer.IoBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.AttributeKey;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.CumulativeProtocolDecoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolDecoderOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXDecoder</span> <span class="keyword">extends</span> <span class="title">CumulativeProtocolDecoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AttributeKey CONTEXT = <span class="keyword">new</span> AttributeKey(getClass(), <span class="string">"context"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">getContext</span><span class="params">(IoSession session)</span> </span>&#123;</span><br><span class="line">        Context ctx = (Context) session.getAttribute(CONTEXT);</span><br><span class="line">        <span class="keyword">if</span> (ctx == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ctx = <span class="keyword">new</span> Context();</span><br><span class="line">            session.setAttribute(CONTEXT, ctx);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 状态变量</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doDecode</span><span class="params">(IoSession session, IoBuffer in, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>注意这里我们使用了Mina 自带的AttributeKey 类来定义保存在IoSession 中的对象的键值，这样可以有效的防止键值重复。另外，要注意在全部处理完毕之后，状态要复位，譬如：聊天室中的一条消息读取完毕之后，状态变量要变为初始值，以便下次处理时重新使用。</li></ol><ul><li>第四步，编解码工厂：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolDecoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CmccSipcCodecFactory</span> <span class="keyword">implements</span> <span class="title">ProtocolCodecFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CmccSipcEncoder encoder;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CmccSipcDecoder decoder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CmccSipcCodecFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Charset.defaultCharset());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CmccSipcCodecFactory</span><span class="params">(Charset charSet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.encoder = <span class="keyword">new</span> CmccSipcEncoder(charSet);</span><br><span class="line">        <span class="keyword">this</span>.decoder = <span class="keyword">new</span> CmccSipcDecoder(charSet);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProtocolDecoder <span class="title">getDecoder</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> decoder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ProtocolEncoder <span class="title">getEncoder</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> encoder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>实际上这个工厂类就是包装了编码器、解码器，通过接口中的getEncoder()、getDecoder()方法向ProtocolCodecFilter 过滤器返回编解码器实例，以便在过滤器中对数据进行编解码处理。<br>第五步，运行示例：<br>下面我们修改最一开始的示例中的MyServer、MyClient 的代码，如下所示：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoAcceptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IdleStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.LineDelimiter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.TextLineCodecFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.util.ReferenceCountingFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.transport.socket.nio.NioSocketAcceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dxz.minademo2.TCPServerHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        IoAcceptor acceptor = <span class="keyword">new</span> NioSocketAcceptor();</span><br><span class="line">        acceptor.getSessionConfig().setReadBufferSize(<span class="number">2048</span>);</span><br><span class="line">        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编写过滤器</span></span><br><span class="line"></span><br><span class="line">        acceptor.getFilterChain().addLast(<span class="string">"codec"</span>,</span><br><span class="line">                <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> CmccSipcCodecFactory(Charset.forName(<span class="string">"UTF-8"</span>))));</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置handler</span></span><br><span class="line">        acceptor.getFilterChain().addLast(<span class="string">"myIoFilter"</span>, <span class="keyword">new</span> ReferenceCountingFilter(<span class="keyword">new</span> MyIoFilter()));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置handler</span></span><br><span class="line">        acceptor.setHandler(<span class="keyword">new</span> TCPServerHandler());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定端口</span></span><br><span class="line">        acceptor.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9124</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(acceptor.getSessionConfig());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>client<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.dxz.minademo3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.future.ConnectFuture;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.future.IoFutureListener;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoConnector;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.LineDelimiter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.textline.TextLineCodecFactory;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.transport.socket.nio.NioSocketConnector;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.dxz.minademo2.TCPClientHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IoConnector connector = <span class="keyword">new</span> NioSocketConnector();</span><br><span class="line">        connector.setConnectTimeoutMillis(<span class="number">30000</span>);</span><br><span class="line"></span><br><span class="line">        connector.getFilterChain().addLast(<span class="string">"codec"</span>,</span><br><span class="line">                <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> CmccSipcCodecFactory(Charset.forName(<span class="string">"UTF-8"</span>))));</span><br><span class="line"></span><br><span class="line">        connector.setHandler(<span class="keyword">new</span> TCPClientHandler(<span class="string">"你好！\r\n 大家好！"</span>));</span><br><span class="line">        ConnectFuture future = connector.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">9124</span>));</span><br><span class="line">        future.addListener(<span class="keyword">new</span> IoFutureListener&lt;ConnectFuture&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ConnectFuture future)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                IoSession session = future.getSession();</span><br><span class="line">                System.out.println(<span class="string">"++++++++++++++++++++++++++++"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>最后我们在ClientHandler中发送这条短信息：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void sessionOpened(IoSession ioSession) throws Exception &#123;</span><br><span class="line">        SmsObject sm &#x3D; new SmsObject();</span><br><span class="line">        sm.setMessage(&quot;hemaceshi&quot;);</span><br><span class="line">        sm.setReceiver(&quot;1799999999&quot;);</span><br><span class="line">        sm.setSender(&quot;17888888888&quot;);</span><br><span class="line">        ioSession.write(sm);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>在ServerHanlder中接收这条信息<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void messageReceived(IoSession ioSession, Object message) throws Exception &#123;</span><br><span class="line">        SmsObject sm &#x3D; (SmsObject) message;</span><br><span class="line">        ioSession.write(sm);</span><br><span class="line">        System.out.println(sm.getMessage());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>你会看到Server 端的控制台输出如下信息：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-%%%%%%%%%%%%%%%%%%%%%%%%%%%messageReceived</span><br><span class="line">The message received is [hemaceshi]</span><br><span class="line">-----------------messageReceived</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%filterWrite</span><br><span class="line">hemaceshi</span><br></pre></td></tr></table></figure></li></ul><h3 id="复杂解码器"><a href="#复杂解码器" class="headerlink" title="复杂解码器"></a>复杂解码器</h3><p>下面我们讲解一下如何在解码器中保存状态变量，也就是真正的实现上面所说的Context。<br>我们假设这样一种情况，有两条短信：<br>M sip:wap.fetion.com.cn SIP-C/2.0<br>S: 1580101xxxx<br>R: 1889020xxxx<br>L: 21<br>Hello World!<br>M sip:wap.fetion.com.cn SIP-C/2.0<br>S: 1580101xxxx<br>R: 1889020xxxx<br>L: 21<br>Hello World!<br>他们按照上面的颜色标识发送，也就是说红色部分、蓝色部分、绿色部分分别发送（调用三次IoSession.write()方法），那么如果你还用上面的CmccSipcDecoder，将无法工作，因为第一次数据流（红色部分）发送过取时，数据是不完整的，无法解析出一条短信息，当二次数据流（蓝色部分）发送过去时，已经可以解析出第一条短信息了，但是第二条短信还是不完整的，需要等待第三次数据流（绿色部分）的发送。注意：由于模拟数据发送的规模性问题很麻烦，所以这里采用了这种极端的例子说明问题，虽不具有典型性，但很能说明问题，这就足够了，所以不要追究这种发送消息是否在真实环境中存在，更不要追究其合理性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> codec;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.buffer.IoBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.AttributeKey;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.CumulativeProtocolDecoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolDecoderOutput;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.CharsetDecoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CmccSipcDecoder</span> <span class="keyword">extends</span> <span class="title">CumulativeProtocolDecoder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Charset charset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AttributeKey CONTEXT = <span class="keyword">new</span> AttributeKey(getClass(),</span><br><span class="line">            <span class="string">"context"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CmccSipcDecoder</span><span class="params">(Charset charset)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.charset = charset;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doDecode</span><span class="params">(IoSession session, IoBuffer in,</span></span></span><br><span class="line"><span class="function"><span class="params">                               ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Context ctx = getContext(session);</span><br><span class="line">        CharsetDecoder cd = charset.newDecoder();</span><br><span class="line">        <span class="keyword">int</span> matchCount = ctx.getMatchCount();</span><br><span class="line">        <span class="keyword">int</span> line = ctx.getLine();</span><br><span class="line">        IoBuffer buffer = ctx.innerBuffer;</span><br><span class="line">        String statusLine = ctx.getStatusLine(),</span><br><span class="line">                sender = ctx.getSender(),</span><br><span class="line">                receiver = ctx.getReceiver(),</span><br><span class="line">                length = ctx.getLength(),</span><br><span class="line">                sms = ctx.getSms();</span><br><span class="line">        <span class="keyword">while</span> (in.hasRemaining()) &#123;</span><br><span class="line">            <span class="keyword">byte</span> b = in.get();</span><br><span class="line">            matchCount++;</span><br><span class="line">            buffer.put(b);</span><br><span class="line">            <span class="keyword">if</span> (line &lt; <span class="number">4</span> &amp;&amp; b == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="number">0</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    statusLine = buffer.getString(matchCount, cd);</span><br><span class="line">                    statusLine = statusLine.substring(<span class="number">0</span>,</span><br><span class="line">                            statusLine.length() - <span class="number">1</span>);</span><br><span class="line">                    matchCount = <span class="number">0</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    ctx.setStatusLine(statusLine);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="number">1</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    sender = buffer.getString(matchCount, cd);</span><br><span class="line">                    sender = sender.substring(<span class="number">0</span>, sender.length() - <span class="number">1</span>);</span><br><span class="line">                    matchCount = <span class="number">0</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    ctx.setSender(sender);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="number">2</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    receiver = buffer.getString(matchCount, cd);</span><br><span class="line">                    receiver = receiver.substring(<span class="number">0</span>, receiver.length() -</span><br><span class="line">                            <span class="number">1</span>);</span><br><span class="line">                    matchCount = <span class="number">0</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    ctx.setReceiver(receiver);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (line == <span class="number">3</span>) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    length = buffer.getString(matchCount, cd);</span><br><span class="line">                    length = length.substring(<span class="number">0</span>, length.length() - <span class="number">1</span>);</span><br><span class="line">                    matchCount = <span class="number">0</span>;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    ctx.setLength(length);</span><br><span class="line">                &#125;</span><br><span class="line">                line++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (line == <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (matchCount == Long.parseLong(length.split(<span class="string">": "</span>)[<span class="number">1</span>])) &#123;</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    sms = buffer.getString(matchCount, cd);</span><br><span class="line">                    ctx.setSms(sms);</span><br><span class="line">                    <span class="comment">// 由于下面的break，这里需要调用else外面的两行代码</span></span><br><span class="line">                    ctx.setMatchCount(matchCount);</span><br><span class="line">                    ctx.setLine(line);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ctx.setMatchCount(matchCount);</span><br><span class="line">            ctx.setLine(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ctx.getLine() == <span class="number">4</span></span><br><span class="line">                &amp;&amp; Long.parseLong(ctx.getLength().split(<span class="string">": "</span>)[<span class="number">1</span>]) == ctx</span><br><span class="line">                .getMatchCount()) &#123;</span><br><span class="line">            SmsObject smsObject = <span class="keyword">new</span> SmsObject();</span><br><span class="line">            smsObject.setSender(sender.split(<span class="string">": "</span>)[<span class="number">1</span>]);</span><br><span class="line">            smsObject.setReceiver(receiver.split(<span class="string">": "</span>)[<span class="number">1</span>]);</span><br><span class="line">            smsObject.setMessage(sms);</span><br><span class="line">            out.write(smsObject);</span><br><span class="line">            ctx.reset();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Context <span class="title">getContext</span><span class="params">(IoSession session)</span> </span>&#123;</span><br><span class="line">        Context context = (Context) session.getAttribute(CONTEXT);</span><br><span class="line">        <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = <span class="keyword">new</span> Context();</span><br><span class="line">            session.setAttribute(CONTEXT, context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> IoBuffer innerBuffer;</span><br><span class="line">        <span class="keyword">private</span> String statusLine = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">private</span> String sender = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">private</span> String receiver = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">private</span> String length = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">private</span> String sms = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            innerBuffer = IoBuffer.allocate(<span class="number">100</span>).setAutoExpand(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> matchCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> line = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMatchCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> matchCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMatchCount</span><span class="params">(<span class="keyword">int</span> matchCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.matchCount = matchCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> line;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLine</span><span class="params">(<span class="keyword">int</span> line)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.line = line;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getStatusLine</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> statusLine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStatusLine</span><span class="params">(String statusLine)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.statusLine = statusLine;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sender;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSender</span><span class="params">(String sender)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sender = sender;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> receiver;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReceiver</span><span class="params">(String receiver)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getLength</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLength</span><span class="params">(String length)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.length = length;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sms;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSms</span><span class="params">(String sms)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sms = sms;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.innerBuffer.clear();</span><br><span class="line">            <span class="keyword">this</span>.matchCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.line = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.statusLine = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">this</span>.sender = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">this</span>.receiver = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">this</span>.length = <span class="string">""</span>;</span><br><span class="line">            <span class="keyword">this</span>.sms = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们做了如下的几步操作：</p><ol><li>所有记录状态的变量移到了Context 内部类中，包括记录读到短信协议的哪一行的line。每一行读取了多少个字节的matchCount，还有记录解析好的状态行、发送者、接受者、短信内容、累积数据的innerBuffer 等。这样就可以在数据不能完全解码，等待下一次doDecode()方法的调用时，还能承接上一次调用的数据。</li><li>在doDecode()方法中主要的变化是各种状态变量首先是从Context 中获取，然后操作之后，将最新的值setXXX()到Context 中保存。</li><li>这里注意doDecode()方法最后的判断，当认为不够解码为一条短信息时，返回false，也就是在本次数据流解码中不要再调用doDecode()方法；当认为已经解码出一条短信息时，输出短消息，然后重置所有的状态变量，返回true，也就是如果本次数据流解码中还有没解码完的数据，继续调用doDecode()方法。下面我们对客户端稍加改造，来模拟上面的红、蓝、绿三次发送聊天短信息的情况：<br>MyClient：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ConnectFuture future &#x3D; connector.connect(new InetSocketAddress(&quot;localhost&quot;, 8888));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等待是否连接成功，相当于是转异步执行为同步执行</span><br><span class="line">future.awaitUninterruptibly();</span><br><span class="line">&#x2F;&#x2F; 连接成功后获取会话对象。如果没有上面的等待，由于connect()方法是异步的，session可能无法被获取</span><br><span class="line">IoSession session &#x3D; future.getSession();</span><br><span class="line">for (int i &#x3D; 0; i &lt; 3; i++) &#123;</span><br><span class="line">    SmsObject smsObject &#x3D; new SmsObject();</span><br><span class="line">    session.write(smsObject);</span><br><span class="line">    System.out.println(&quot;*********&quot; + i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>这里我们为了方便演示，不在IoHandler 中发送消息，而是直接在MyClient 中发送，你要注意的是三次发送都要使用同一个IoSession，否则就不是从同一个通道发送过去的了。<br>CmccSipcEncoder：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void encode(IoSession session, Object message,</span><br><span class="line">                   ProtocolEncoderOutput out) throws Exception &#123;</span><br><span class="line">    SmsObject sms &#x3D; (SmsObject) message;</span><br><span class="line">    CharsetEncoder ce &#x3D; charset.newEncoder();</span><br><span class="line">    String statusLine &#x3D; &quot;M sip:wap.fetion.com.cn SIP-C&#x2F;2.0&quot;;</span><br><span class="line">    String sender &#x3D; &quot;15801012253&quot;;</span><br><span class="line">    String receiver &#x3D; &quot;15866332698&quot;;</span><br><span class="line">    String smsContent &#x3D; &quot;你好！Hello World!&quot;;</span><br><span class="line">    IoBuffer buffer &#x3D; IoBuffer.allocate(100).setAutoExpand(true);</span><br><span class="line">    buffer.putString(statusLine + &quot;&#x2F;n&quot;, ce);</span><br><span class="line">    buffer.putString(&quot;S: &quot; + sender + &quot;&#x2F;n&quot;, ce);</span><br><span class="line">    buffer.putString(&quot;R: &quot; + receiver + &quot;&#x2F;n&quot;, ce);</span><br><span class="line">    buffer.flip();</span><br><span class="line">    out.write(buffer);</span><br><span class="line">    IoBuffer buffer2 &#x3D; IoBuffer.allocate(100).setAutoExpand(true);</span><br><span class="line">    buffer2.putString(&quot;L: &quot; + (smsContent.getBytes(charset).length)</span><br><span class="line">            + &quot;&#x2F;n&quot;,ce);</span><br><span class="line">    buffer2.putString(smsContent, ce);</span><br><span class="line">    buffer2.putString(statusLine + &quot;&#x2F;n&quot;, ce);</span><br><span class="line">    buffer2.flip();</span><br><span class="line">    out.write(buffer2);</span><br><span class="line">    IoBuffer buffer3 &#x3D; IoBuffer.allocate(100).setAutoExpand(true);</span><br><span class="line">    buffer3.putString(&quot;S: &quot; + sender + &quot;&#x2F;n&quot;, ce);</span><br><span class="line">    buffer3.putString(&quot;R: &quot; + receiver + &quot;&#x2F;n&quot;, ce);</span><br><span class="line">    buffer3.putString(&quot;L: &quot; + (smsContent.getBytes(charset).length)</span><br><span class="line">            + &quot;&#x2F;n&quot;,ce);</span><br><span class="line">    buffer3.putString(smsContent, ce);</span><br><span class="line">    buffer3.putString(statusLine + &quot;&#x2F;n&quot;, ce);</span><br><span class="line">    buffer3.flip();</span><br><span class="line">    out.write(buffer3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上面的这段代码要配合MyClient来操作，你需要做的是在MyClient中的红色输出语句处设置断点，然后第一调用时CmccSipcEncoder中注释掉蓝、绿色的代码，也就是发送两条短信息的第一部分（红色的代码），依次类推，也就是MyClient的中的三次断点中，分别执行CmccSipcEncoder中的红、蓝、绿三段代码，也就是模拟两条短信的三段发送。你会看到Server端的运行结果是：当MyClient第一次到达断点时，没有短信息被读取到，当MyClient第二次到达断点时，第一条短信息输出，当MyClient第三次到达断点时，第二条短信息输出。</li></ol><p>Mina中自带的解码器：</p><p>解码器 说明<br><code>CumulativeProtocolDecoder 累积性解码器</code>，上面我们重点说明了这个解码器的用法。<br>SynchronizedProtocolDecoder 这个解码器用于将任何一个解码器包装为一个线程安全的解码器，用于解决上面说的每次执行decode()方法时可能线程不是上一次的线程的问题，但这样会在高并发时，大大降低系统的性能。<br>TextLineDecoder 按照文本的换行符（ Windows:/r/n 、Linux:/n、Mac:/r）解码数据。<br>PrefixedStringDecoder 这个类继承自CumulativeProtocolDecoder类，用于读取数据最前端的1、2、4 个字节表示后面的数据长度的数据。譬如：一个段数据的前两个字节表示后面的真实数据的长度，那么你就可以用这个方法进行解码。</p><h3 id="多路分离的解码器"><a href="#多路分离的解码器" class="headerlink" title="多路分离的解码器"></a>多路分离的解码器</h3><p>假设一段数据发送过来之后，需要根据某种条件决定使用哪个解码器，而不是像上面的例子，固定使用一个解码器，那么该如何做呢？幸好Mina 提供了org.apache.mina.filter.codec.demux 包来完成这种多路分离（Demultiplexes）的解码工作，也就是同时注册多个解码器，然后运行时依据传入的数据决定到底使用哪个解码器来工作。<code>所谓多路分离就是依据条件分发到指定的解码器</code>，譬如：上面的短信协议进行扩展，可以依据状态行来判断使用1.0 版本的短信协议解码器还是2.0版本的短信协议解码器。<br>下面我们使用一个简单的例子，说明这个多路分离的解码器是如何使用的，需求如下所示：</p><ol><li><p>客户端传入两个int 类型的数字，还有一个char 类型的符号。</p></li><li><p>如果符号是+，服务端就是用1 号解码器，对两个数字相加，然后把结果返回给客户端。</p></li><li><p>如果符号是-，服务端就使用2 号解码器，将两个数字变为相反数，然后相加，把结果返回给客户端。<br>Demux 开发编解码器主要有如下几个步骤：</p><p> A. 定义Client 端、Server 端发送、接收的数据对象。</p><p> B. 使用Demux 编写编码器是实现MessageEncoder<T>接口，T 是你要编码的数据对象，这个MessageEncoder 会在DemuxingProtocolEncoder 中调用。</p><p> C. 使用Demux 编写编码器是实现MessageDecoder 接口，这个MessageDecoder 会在DemuxingProtocolDecoder 中调用。</p><p> D. 在 DemuxingProtocolCodecFactory 中调用addMessageEncoder()、addMessageDecoder()方法组装编解码器。</p></li></ol><p>MessageEncoder的接口如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageEncoder</span>&lt;<span class="title">T</span>&gt; </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">encode</span><span class="params">(IoSession session, T message, ProtocolEncoderOutput out)</span> <span class="keyword">throws</span> Exception</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你注意到消息编码器接口与在ProtocolEncoder 中没什么不同，区别就是Object message被泛型具体化了类型，你不需要手动的类型转换了。<br>MessageDecoder的接口如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageDecoder</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">static</span> MessageDecoderResult OK = MessageDecoderResult.OK;    </span><br><span class="line">    <span class="keyword">static</span> MessageDecoderResult NEED_DATA = MessageDecoderResult.NEED_DATA;    </span><br><span class="line">    <span class="keyword">static</span> MessageDecoderResult NOT_OK = MessageDecoderResult.NOT_OK;    </span><br><span class="line">    <span class="function">MessageDecoderResult <span class="title">decodable</span><span class="params">(IoSession session, IoBuffer in)</span></span>;    </span><br><span class="line">    <span class="function">MessageDecoderResult <span class="title">decode</span><span class="params">(IoSession session, IoBuffer in,    </span></span></span><br><span class="line"><span class="function"><span class="params">    ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception</span>;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">finishDecode</span><span class="params">(IoSession session, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>decodable()方法有三个返回值，分别表示如下的含义：</p><p> A. MessageDecoderResult.NOT_OK：表示这个解码器不适合解码数据，然后检查其它解码器，如果都不满足会抛异常；</p><p> B. MessageDecoderResult.NEED_DATA：表示当前的读入的数据不够判断是否能够使用这个解码器解码，然后再次调用decodable()方法检查其它解码器，如果都是NEED_DATA,则等待下次输入；</p><p> C. MessageDecoderResult.OK： 表示这个解码器可以解码读入的数据， 然后则调用MessageDecoder 的decode()方法。<code>这里注意decodable()方法对参数IoBuffer in 的任何操作在方法结束之后，都会复原</code>，也就是你不必担心在调用decode()方法时，position 已经不在缓冲区的起始位置。这个方法相当于是预读取，用于判断是否是可用的解码器。</p></li><li><p>decode()方法有三个返回值，分别表示如下的含义：</p><p> A. MessageDecoderResult.NOT_OK：表示解码失败，会抛异常；<br> B. MessageDecoderResult.NEED_DATA：表示数据不够，需要读到新的数据后，再次调用decode()方法。<br> C. MessageDecoderResult.OK：表示解码成功。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"><span class="comment">//客户端发送的数据对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> symbol = <span class="string">'+'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">getSymbol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSymbol</span><span class="params">(<span class="keyword">char</span> symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.symbol = symbol;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setI</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.i = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getJ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setJ</span><span class="params">(<span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.j = j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"><span class="comment">//服务端发送的返回结果对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(<span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.buffer.IoBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolEncoderOutput;</span><br><span class="line"><span class="comment">//客户端使用的SendMessage的编码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendSmsMessageEncoder</span> <span class="keyword">implements</span> <span class="title">SmsMessageEncoder</span>&lt;<span class="title">SendMessage</span>&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">encode</span><span class="params">(IoSession session, SendMessage message, ProtocolEncoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        IoBuffer buffer = IoBuffer.allocate(<span class="number">10</span>);</span><br><span class="line">        buffer.putChar(message.getSymbol());</span><br><span class="line">        buffer.putInt(message.getI());</span><br><span class="line">        buffer.putInt(message.getJ());</span><br><span class="line">        buffer.flip();</span><br><span class="line">        out.write(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们的SendMessage、ResultMessage 中的字段都是用长度固定的基本数据类型，这样IoBuffer 就不需要自动扩展了，提高性能。按照一个char、两个int 计算，这里的IoBuffer只需要10 个字节的长度就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.buffer.IoBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolDecoderOutput;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.demux.MessageDecoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.demux.MessageDecoderResult;</span><br><span class="line"><span class="comment">//服务端使用的SendMessage的1号解码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessageDecoderPositive</span> <span class="keyword">implements</span> <span class="title">MessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageDecoderResult <span class="title">decodable</span><span class="params">(IoSession session, IoBuffer in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in.remaining() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> MessageDecoderResult.NEED_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> symbol = in.getChar();</span><br><span class="line">            <span class="keyword">if</span> (symbol == <span class="string">'+'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> MessageDecoderResult.OK;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> MessageDecoderResult.NOT_OK;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageDecoderResult <span class="title">decode</span><span class="params">(IoSession session, IoBuffer in, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SendMessage sm = <span class="keyword">new</span> SendMessage();</span><br><span class="line">        sm.setSymbol(in.getChar());</span><br><span class="line">        sm.setI(in.getInt());</span><br><span class="line">        sm.setJ(in.getInt());</span><br><span class="line">        out.write(sm);</span><br><span class="line">        <span class="keyword">return</span> MessageDecoderResult.OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishDecode</span><span class="params">(IoSession session, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// undo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为客户端发送的SendMessage 的前两个字节（char）就是符号位，所以我们在decodable()方法中对此条件进行了判断，之后读到两个字节，并且这两个字节表示的字符是+时，才认为这个解码器可用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.buffer.IoBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolDecoderOutput;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.demux.MessageDecoderResult;</span><br><span class="line"><span class="comment">//服务端使用的SendMessage的2号解码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendSmsMessageDecoderNegative</span> <span class="keyword">implements</span> <span class="title">SmsMessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageDecoderResult <span class="title">decodable</span><span class="params">(IoSession session, IoBuffer in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in.remaining() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> MessageDecoderResult.NEED_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">char</span> symbol = in.getChar();</span><br><span class="line">            <span class="keyword">if</span> (symbol == <span class="string">'-'</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> MessageDecoderResult.OK;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> MessageDecoderResult.NOT_OK;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageDecoderResult <span class="title">decode</span><span class="params">(IoSession session, IoBuffer in, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SendMessage sm = <span class="keyword">new</span> SendMessage();</span><br><span class="line">        sm.setSymbol(in.getChar());</span><br><span class="line">        sm.setI(-in.getInt());</span><br><span class="line">        sm.setJ(-in.getInt());</span><br><span class="line">        out.write(sm);</span><br><span class="line">        <span class="keyword">return</span> MessageDecoderResult.OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishDecode</span><span class="params">(IoSession session, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// undo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"><span class="comment">//服务端使用的ResultMessage的编码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultMessage</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResult</span><span class="params">(<span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.buffer.IoBuffer;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolDecoderOutput;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.demux.MessageDecoder;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.demux.MessageDecoderResult;</span><br><span class="line"><span class="comment">//客户端使用的ResultMessage的解码器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultMessageDecoder</span> <span class="keyword">implements</span> <span class="title">MessageDecoder</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageDecoderResult <span class="title">decodable</span><span class="params">(IoSession session, IoBuffer in)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (in.remaining() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> MessageDecoderResult.NEED_DATA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (in.remaining() == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> MessageDecoderResult.OK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> MessageDecoderResult.NOT_OK;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageDecoderResult <span class="title">decode</span><span class="params">(IoSession session, IoBuffer in, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ResultMessage rm = <span class="keyword">new</span> ResultMessage();</span><br><span class="line">        rm.setResult(in.getInt());</span><br><span class="line">        out.write(rm);</span><br><span class="line">        <span class="keyword">return</span> MessageDecoderResult.OK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">finishDecode</span><span class="params">(IoSession session, ProtocolDecoderOutput out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// undo</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.demux.DemuxingProtocolCodecFactory;</span><br><span class="line"><span class="comment">//组装这些编解码器的工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathProtocolCodecFactory</span> <span class="keyword">extends</span> <span class="title">DemuxingProtocolCodecFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MathProtocolCodecFactory</span><span class="params">(<span class="keyword">boolean</span> server)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (server) &#123;</span><br><span class="line">            <span class="keyword">super</span>.addMessageEncoder(ResultMessage<span class="class">.<span class="keyword">class</span>, <span class="title">ResultMessageEncoder</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            <span class="keyword">super</span>.addMessageDecoder(SendMessageDecoderPositive<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="keyword">super</span>.addMessageDecoder(SendSmsMessageDecoderNegative<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.addMessageEncoder(SendMessage<span class="class">.<span class="keyword">class</span>, <span class="title">SendSmsMessageEncoder</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            <span class="keyword">super</span>.addMessageDecoder(ResultMessageDecoder<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个工厂类我们使用了构造方法的一个布尔类型的参数，以便其可以在Server 端、Client端同时使用。我们以Server 端为例，你可以看到调用两次addMessageDecoder()方法添加了1 号、2 号解码器，其实DemuxingProtocolDecoder 内部在维护了一个MessageDecoder数组，用于保存添加的所有的消息解码器，每次decode()的时候就调用每个MessageDecoder的decodable()方法逐个检查，只要发现一个MessageDecoder 不是对应的解码器，就从数组中移除，直到找到合适的MessageDecoder，如果最后发现数组为空，就表示没找到对应的MessageDecoder，最后抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoAcceptor;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IdleStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.logging.LoggingFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.transport.socket.nio.NioSocketAcceptor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="comment">//Server端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        IoAcceptor acceptor = <span class="keyword">new</span> NioSocketAcceptor();</span><br><span class="line">        LoggingFilter lf = <span class="keyword">new</span> LoggingFilter();</span><br><span class="line">        acceptor.getSessionConfig().setIdleTime(IdleStatus.BOTH_IDLE, <span class="number">5</span>);</span><br><span class="line">        acceptor.getFilterChain().addLast(<span class="string">"logger"</span>, lf);</span><br><span class="line">        acceptor.getFilterChain().addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> MathProtocolCodecFactory(<span class="keyword">true</span>)));</span><br><span class="line">        acceptor.setHandler(<span class="keyword">new</span> ServerHandler());</span><br><span class="line">        acceptor.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9123</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IdleStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="comment">//ServerHandler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> <span class="keyword">extends</span> <span class="title">IoHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger log = LoggerFactory.getLogger(ServerHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionIdle</span><span class="params">(IoSession session, IdleStatus status)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        session.close(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(IoSession session, Object message)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SendMessage sm = (SendMessage) message;</span><br><span class="line">        System.out.println(<span class="string">"The message received is [ "</span> + sm.getI() + <span class="string">" "</span> + sm.getSymbol() + <span class="string">" "</span> + sm.getJ() + <span class="string">" ]"</span>);</span><br><span class="line">        ResultMessage rm = <span class="keyword">new</span> ResultMessage();</span><br><span class="line">        rm.setResult(sm.getI() + sm.getJ());</span><br><span class="line">        session.write(rm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoConnector;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.codec.ProtocolCodecFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.filter.logging.LoggingFilter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.transport.socket.nio.NioSocketConnector;</span><br><span class="line"><span class="comment">//Client端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        IoConnector connector = <span class="keyword">new</span> NioSocketConnector();</span><br><span class="line">        connector.setConnectTimeoutMillis(<span class="number">30000</span>);</span><br><span class="line">        connector.getFilterChain().addLast(<span class="string">"logger"</span>, <span class="keyword">new</span> LoggingFilter());</span><br><span class="line">        connector.getFilterChain().addLast(<span class="string">"codec"</span>, <span class="keyword">new</span> ProtocolCodecFilter(<span class="keyword">new</span> MathProtocolCodecFactory(<span class="keyword">false</span>)));</span><br><span class="line">        connector.setHandler(<span class="keyword">new</span> ClientHandler());</span><br><span class="line">        connector.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">9123</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> multichannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.service.IoHandlerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.apache.mina.core.session.IoSession;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="comment">//client的Hanlder</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> <span class="keyword">extends</span> <span class="title">IoHandlerAdapter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Logger LOGGER = LoggerFactory.getLogger(ClientHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sessionOpened</span><span class="params">(IoSession session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SendMessage sm = <span class="keyword">new</span> SendMessage();</span><br><span class="line">        sm.setI(<span class="number">100</span>);</span><br><span class="line">        sm.setJ(<span class="number">99</span>);</span><br><span class="line">        sm.setSymbol(<span class="string">'+'</span>);</span><br><span class="line">        session.write(sm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">messageReceived</span><span class="params">(IoSession session, Object message)</span> </span>&#123;</span><br><span class="line">        ResultMessage rs = (ResultMessage) message;</span><br><span class="line">        System.out.println(String.valueOf(rs.getResult()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;结果</span><br><span class="line">The message received is [ -100 - -99 ]</span><br><span class="line">The message received is [ 100 + 99 ]</span><br></pre></td></tr></table></figure><h2 id="线程模型配置"><a href="#线程模型配置" class="headerlink" title="线程模型配置"></a>线程模型配置</h2><p>Mina 中的很多执行环节都使用了多线程机制，用于提高性能。<code>Mina 中默认在三个地方使用了线程</code>：</p><ol><li>IoAcceptor：<br>这个地方用于接受客户端的连接建立，每监听一个端口（每调用一次bind()方法），都启用一个线程，这个数字我们不能改变。这个线程监听某个端口是否有请求到来，一旦发现，则创建一个IoSession 对象。因为这个动作很快，所以有一个线程就够了。</li><li>IoConnector：<br>这个地方用于与服务端建立连接，每连接一个服务端（每调用一次connect()方法），就启用一个线程，我们不能改变。同样的，这个线程监听是否有连接被建立，一旦发现，则创建一个IoSession 对象。因为这个动作很快，所以有一个线程就够了。</li><li>IoProcessor：<br>这个地方用于执行真正的IO 操作，默认启用的线程个数是CPU 的核数+1，譬如：单CPU 双核的电脑，默认的IoProcessor 线程会创建3 个。这也就是说一个IoAcceptor 或者IoConnector 默认会关联一个IoProcessor 池，这个池中有3 个IoProcessor。因为IO 操作耗费资源，所以这里使用IoProcessor 池来完成数据的读写操作，有助于提高性能。这也就是前面说的IoAccetor、IoConnector 使用一个Selector，而IoProcessor 使用自己单独的Selector 的原因。那么为什么IoProcessor 池中的IoProcessor 数量只比CPU 的核数大1 呢？因为IO 读写操作是耗费CPU 的操作，而每一核CPU 同时只能运行一个线程，因此IoProcessor 池中的IoProcessor 的数量并不是越多越好。</li></ol><p>这个IoProcessor 的数量可以调整，如下所示：<br>IoAcceptor acceptor=new NioSocketAcceptor(5);<br>IoConnector connector=new NioSocketConnector(5);<br>这样就会将IoProcessor 池中的数量变为5 个，也就是说可以同时处理5 个读写操作。<code>还记得前面说过Mina 的解码器要使用IoSession 保存状态变量，而不是Decoder 本身，这是因为Mina 不保证每次执行doDecode()方法的都是同一个IoProcessor 这句话吗？</code>其实这个问题的根本原因是IoProcessor 是一个池，每次IoSession 进入空闲状态时（无读些数据发生），IoProcessor 都会被回收到池中，以便其他的IoSession 使用，所以当IoSession从空闲状态再次进入繁忙状态时，IoProcessor 会再次分配给其一个IoProcessor 实例，而此时已经不能保证还是上一次繁忙状态时的那个IoProcessor 了。<code>你还会发现IoAcceptor 、IoConnector 还有一个构造方法， 你可以指定一个java.util.concurrent.Executor 类作为线程池对象，那么这个线程池对象是做什么用的呢？</code>其实就是用于创建(1.)、(2.)中的用于监听是否有TCP 连接建立的那个线程，默认情况下，使用Executors.newCachedThreadPool()方法创建Executor 实例，也就是一个无界的线程池（具体内容请参看JAVA 的并发库）。大家不要试图改变这个Executor 的实例，也就是使用内置的即可，否则可能会造成一些莫名其妙的问题，譬如：性能在某个访问量级别时，突然下降。因为无界线程池是有多少个Socket 建立，就分配多少个线程，如果你改为Executors 的其他创建线程池的方法，创建了一个有界线程池，那么一些请求将无法得到及时响应，从而出现一些问题。</p><p><code>下面我们完整的综述一下Mina 的工作流程：</code></p><p><code>1. 当 IoService 实例创建的时候，同时一个关联在IoService上的IoProcessor 池、线程池也被创建；</code></p><p><code>2. 当 IoService 建立套接字（IoAcceptor 的bind()或者是IoConnector 的connect()方法被调用）时，IoService 从线程池中取出一个线程，监听套接字端口；</code></p><p><code>3. 当 IoService 监听到套接字上有连接请求时，建立IoSession 对象，从IoProcessor池中取出一个IoProcessor 实例执行这个会话通道上的过滤器、IoHandler；</code></p><p><code>4. 当这条IoSession 通道进入空闲状态或者关闭时，IoProcessor 被回收。上面说的是Mina 默认的线程工作方式，那么我们这里要讲的是如何配置IoProcessor 的多线程工作方式。因为一个IoProcessor 负责执行一个会话上的所有过滤器、IoHandler，也就是对于IO 读写操作来说，是单线程工作方式（就是按照顺序逐个执行）。假如你想让某个事件方法（譬如：sessionIdle()、sessionOpened()等）在单独的线程中运行（也就是非IoProcessor 所在的线程），那么这里就需要用到一个ExecutorFilter 的过滤器。你可以看到IoProcessor 的构造方法中有一个参数是java.util.concurrent.Executor，也就是可以让IoProcessor 调用的过滤器、IoHandler 中的某些事件方法在线程池中分配的线程上独立运行，而不是运行在IoProcessor 所在的线程。</code></p><p>例：<br>acceptor.getFilterChain().addLast(“exceutor”, new ExecutorFilter());<br>我们看到是用这个功能，简单的一行代码就可以了。那么ExecutorFilter 还有许多重载的构造方法，这些重载的有参构造方法，参数主要用于指定如下信息：</p><ol><li>指定线程池的属性信息，譬如：核心大小、最大大小、等待队列的性质等。你特别要关注的是ExecutorFilter 内部默认使用的是OrderedThreadPoolExecutor 作为线程池的实现，从名字上可以看出是保证各个事件在多线程执行中的顺序（譬如：各个事件方法的执行是排他的，也就是不可能出现两个事件方法被同时执行；messageReceived()总是在sessionClosed() 方法之前执行）， 这是因为多线程的执行是异步的， 如果没有OrderedThreadPoolExecutor 来保证IoHandler 中的方法的调用顺序，可能会出现严重的问题。但是如果你的代码确实没有依赖于IoHandler 中的事件方法的执行顺序，那么你可以使用UnorderedThreadPoolExecutor 作为线程池的实现。因此，你也最好不要改变默认的Executor 实现，否则，事件的执行顺序就会混乱，譬如：messageReceived()、messageSent()方法被同时执行。</li><li>哪些事件方法被关注，也就哪些事件方法用这个线程池执行。线程池可以异步执行的事件类型是位于IoEventType 中的九个枚举值中除了SESSION_CREATED 之外的其余八个，这说明Session 建立的事件只能与IoProcessor 在同一个线程上执行。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> IoEventType &#123;    </span><br><span class="line">SESSION_CREATED,    </span><br><span class="line">SESSION_OPENED,    </span><br><span class="line">SESSION_CLOSED,    </span><br><span class="line">MESSAGE_RECEIVED,    </span><br><span class="line">MESSAGE_SENT,    </span><br><span class="line">SESSION_IDLE,    </span><br><span class="line">EXCEPTION_CAUGHT,    </span><br><span class="line">WRITE,    </span><br><span class="line">CLOSE,    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>默认情况下，没有配置关注的事件类型，有如下六个事件方法会被自动使用线程池异步执行<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IoEventType.EXCEPTION_CAUGHT,</span><br><span class="line">IoEventType.MESSAGE_RECEIVED,</span><br><span class="line">IoEventType.MESSAGE_SENT,</span><br><span class="line">IoEventType.SESSION_CLOSED,</span><br><span class="line">IoEventType.SESSION_IDLE,</span><br><span class="line">IoEventType.SESSION_OPENED</span><br></pre></td></tr></table></figure>其实ExecutorFilter 的工作机制很简单，就是在调用下一个过滤器的事件方法时，把其交给Executor 的execute(Runnable runnable)方法来执行，其实你自己在IoHandler 或者某个过滤器的事件方法中开启一个线程，也可以完成同样的功能，只不过这样做，你就失去了程序的可配置性，线程调用的代码也会完全耦合在代码中。但要注意的是绝对不能开启线程让其执行sessionCreated()方法。如果你真的打算使用这个ExecutorFilter，那么最好想清楚它该放在过滤器链的哪个位置，针对哪些事件做异步处理机制。一般ExecutorFilter 都是要放在ProtocolCodecFilter 过滤器的后面，也就是不要让编解码运行在独立的线程上，而是要运行在IoProcessor 所在的线程，因为编解码处理的数据都是由IoProcessor 读取和发送的，没必要开启新的线程，否则性能反而会下降。一般使用ExecutorFilter 的典型场景是将业务逻辑（譬如：耗时的数据库操作）放在单独的线程中运行，也就是说与IO 处理无关的操作可以考虑使用ExecutorFilter 来异步执行。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 互联网架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> Mina </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络通信框架（1）---Mina</title>
      <link href="/p/55146056.html"/>
      <url>/p/55146056.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>因为公司需要重构一个老项目，老项目的网络通信框架用的是Mina，现在需要迁移到Netty实现，所以趁着空闲的时间学习一下Mina。</p><h2 id="Mina框架概述"><a href="#Mina框架概述" class="headerlink" title="Mina框架概述"></a>Mina框架概述</h2><p>Apache Mina是一个能够帮助用户开发高性能和高伸缩性网络应用程序的框架。它通过Java nio技术基于TCP/IP和UDP/IP协议提供了抽象的、事件驱动的、异步的API。<br>学习Mina，需要你已掌握Java IO,Java NIO,Java Socket,Java线程及并发库(java.util.concurrent包)知识。<br>Mina同时提供了网络通信的Server端、Client端的封装。<br>Mina的底层依赖的主要是Java NIO库，上层提供的是基于事件的异步接口。<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-13/mina.png" alt="Mina架构"></p><h2 id="Mina主要接口"><a href="#Mina主要接口" class="headerlink" title="Mina主要接口"></a>Mina主要接口</h2><table><thead><tr><th>包名</th><th align="center">作用</th></tr></thead><tbody><tr><td>org.apache.mina.core.buffer</td><td align="center">用于缓冲区的IoBuffer</td></tr><tr><td>org.apache.mina.core.service org.apache.mina.transport.*</td><td align="center">用于提供连接的service</td></tr><tr><td>org.apache.mina.core.session</td><td align="center">用于提供两端状态的session</td></tr><tr><td>org.apache.mina.core.filterchain org.apache.mina.filter.*</td><td align="center">用于拦截所有IO事件和请求的filter chain和各类拦截器（在IoService和IoHandler之间）</td></tr><tr><td>org.apache.mina.handler.*</td><td align="center">用于处理IO事件的handler</td></tr><tr><td>org.apache.mina.core.future</td><td align="center">用于实现异步IO操作的 future</td></tr><tr><td>org.apache.mina.core.polling.*</td><td align="center">用于实现IO轮询的的polling</td></tr><tr><td>org.apache.mina.proxy.*</td><td align="center">用于实现代理的proxy</td></tr></tbody></table><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-20/Mina%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84.png" alt="Mina工作流程"></p><p><b>IoService:</b><br>这个接口在一个线程上负责套接字的建立，拥有自己的 Selector，监听是否有连接被建立。<br><b>IoProcessor:</b><br>这个接口在另一个线程丧负责检查是否有数据在通道中读写，也就是说它也拥有自己的Selector，这是与我们使用Java NIO编码时的一个不同之处，通常在Java NIO编码中，我们都是使用一个Selector，也就是不区分IoService和IoProcessor两个功能接口，另外IoProcessor负责调用在IoService上的过滤器，并在过滤器链之后调用IoHandler<br><b>IoAccepter:</b><br>相当于网络应用程序中的服务器端<br><b>IoConnector:</b><br>相当于客户端<br><b>IoSession:</b><br>当前客户端到服务器端的一个连接实例<br><b>IoHandler:</b><br>这个接口负责编写业务逻辑，也就是接收、发送数据的地方。这也是实际开发过程中需要用户自己编写的部分代码。<br><b>IoFilter :</b><br>过滤器用于悬接通讯层接口与业务层接口，这个接口定义一组拦截器，这些拦截器可以包括日志输出、黑名单过滤、数据的编码（write 方向）与解码（read 方向）等功能，其中数据的 encode与 decode是最为重要的、也是你在使用 Mina时最主要关注的地方。<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-20/%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B.png" alt="Mina通信过程"></p><p>服务端流程：</p><ol><li>通过SocketAcceptor 同客户端建立连接；</li><li>连接建立之后 I/O的读写交给了I/O Processor线程，I/O Processor是多线程的；</li><li>通过I/O Processor 读取的数据经过IoFilterChain里所有配置的IoFilter，IoFilter进行消息的过滤，格式的转换，在这个层面可以制定一些自定义的协议；</li><li>最后IoFilter将数据交给 Handler  进行业务处理，完成了整个读取的过程；<br>写入过程也是类似，只是刚好倒过来，通过IoSession.write 写出数据，然后Handler进行写入的业务处理，处理完成后交给IoFilterChain，进行消息过滤和协议的转换，最后通过 I/O Processor 将数据写出到 socket 通道。<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-20/Mina%E6%A0%B8%E5%BF%83%E7%B1%BB%E5%9B%BE.png" alt="Mina核心类图"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 互联网架构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> Mina </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同步非阻塞IO---NIO</title>
      <link href="/p/b7c39a63.html"/>
      <url>/p/b7c39a63.html</url>
      
        <content type="html"><![CDATA[<h2 id="高并发引起的问题"><a href="#高并发引起的问题" class="headerlink" title="高并发引起的问题"></a>高并发引起的问题</h2><p>一个使用传统阻塞I/O的系统,如果还是使用传统的一个请求对应一个线程这种模式,一旦有高并发的大量请求,就会有如下问题： </p><ol><li>线程不够用, 就算使用了线程池复用线程也无济于事; </li><li>阻塞I/O模式下,会有大量的线程被阻塞,一直在等待数据,这个时候的线程被挂起,只能干等,CPU利用率很低,换句话说,系统的吞吐量差; </li><li>如果网络I/O堵塞或者有网络抖动或者网络故障等,线程的阻塞时间可能很长。整个系统也变的不可靠;</li></ol><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>指JDK1.4及以上版本里提供的新的API，为所有原始类型（boolean类型除外）提供缓存支持的数据容器，使用它可以提供非阻塞式的高伸缩性网络。</li><li>NIO的作用：进行数据传输</li><li>NIO的组件：Buffer，Channel，Selector<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; IO的分类</span><br><span class="line">BIO - BlockingIO - 同步阻塞式IO</span><br><span class="line">NIO - NewIO - NonBlockingIO - 同步非阻塞IO - JDK1.4</span><br><span class="line">AIO - AsynchronousIO - 异步非阻塞式IO - JDK1.8</span><br></pre></td></tr></table></figure><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-12/NIO.png" alt="NIO"></li></ol><h2 id="阻塞与同步"><a href="#阻塞与同步" class="headerlink" title="阻塞与同步"></a>阻塞与同步</h2><p><a href="https://www.cnblogs.com/xcywt/p/8146123.html" target="_blank" rel="noopener">点击了解烧水壶例子</a></p><p><b>同步：</b><br>所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。也就是必须一件一件事做,等前一件做完了才能做下一件事。<br>例如普通B/S模式（同步）：提交请求-&gt;等待服务器处理-&gt;处理完毕返回 这个期间客户端浏览器不能干任何事</p><p><b>异步：</b><br>异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。<br>例如 ajax请求（异步）: 请求通过事件触发-&gt;服务器处理（这是浏览器仍然可以作其他事情）-&gt;处理完毕</p><p><b>阻塞：</b><br>阻塞调用是指调用结果返回之前，当前线程会被挂起（线程进入非可执行状态，在这个状态下，cpu不会给线程分配时间片，即线程暂停运行）。函数只有在得到结果之后才会返回。<br>有人也许会把阻塞调用和同步调用等同起来，实际上他是不同的。对于同步调用来说，很多时候当前线程还是激活的，只是从逻辑上当前函数没有返回,它还会抢占cpu去执行其他逻辑，也会主动检测io是否准备好。</p><p><b>非阻塞</b><br>非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。</p><p>再简单点理解就是：</p><ol><li>同步：就是我调用一个功能，该功能没有结束前，我死等结果。</li><li>异步：就是我调用一个功能，不需要知道该功能结果，该功能有结果后通知我（回调通知）</li><li>阻塞：就是调用我（函数），我（函数）没有接收完数据或者没有得到结果之前，我不会返回。</li><li>非阻塞：就是调用我（函数），我（函数）立即返回，通过select通知调用者</li></ol><p>同步IO和异步IO的区别就在于：数据拷贝的时候进程是否阻塞<br>阻塞IO和非阻塞IO的区别就在于：应用程序的调用是否立即返回<br><b>综上可知:</b><br>同步和异步,阻塞和非阻塞,有些混用,其实它们完全不是一回事,而且它们修饰的对象也不相同。</p><h2 id="BIO与NIO对比"><a href="#BIO与NIO对比" class="headerlink" title="BIO与NIO对比"></a>BIO与NIO对比</h2><table><thead><tr><th>IO模型</th><th align="center">BIO</th><th align="center">NIO</th></tr></thead><tbody><tr><td>方式</td><td align="center">从硬盘到内存</td><td align="center">从内存到硬盘</td></tr><tr><td>通信</td><td align="center">面向流</td><td align="center">面向缓存</td></tr><tr><td>处理</td><td align="center">阻塞式IO</td><td align="center">非阻塞IO</td></tr><tr><td>触发</td><td align="center">无</td><td align="center">选择器（轮询机制）</td></tr></tbody></table><ol><li>BIO缺点<br> a.阻塞：导致效率整体降低。<br>b.一对一连接：客户端每过来一个请求，那么在服务端就需要一个线程去处理这个请求。如果客户端产生大量的请求，会导致服务端也产生大量的线程去处理请求，服务器端的线程数量一旦过多，会导致服务器的卡顿甚至崩溃。<br>c.如果客户端连接之后不产生任何操作，依然会占用服务端的线程，导致服务器资源的浪费。</li><li>面向流与面向缓冲<br>Java NIO和IO之间第一个最大的区别是，IO是面向流的.NIO是面向缓冲区的。Java IO面向流意味着毎次从流中读一个成多个字节，直至读取所有字节，它们没有被缓存在任何地方，此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的教据，需要先将它缓存到一个缓冲区。Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，霱要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数裾。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</li></ol><h2 id="Buffer-缓存区"><a href="#Buffer-缓存区" class="headerlink" title="Buffer - 缓存区"></a>Buffer - 缓存区</h2><ol><li>作用存储数据</li><li>容器：数组，针对基本类型提供了其中对应的Buffer（boolean类型除外）</li><li>重要位置： capacity &gt;= limit &gt;= position &gt;= mark<br><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-12/buffer.png" alt="Buffer"><br><b>容量（Capacity）：</b>缓冲区能够容纳的数据元素的最大数量。这一个容量在缓冲区创建时被设定，并且永远不能改变。<br><b>上界(Limit)：</b>限制位。用于限制操作位所能达到的最大位置。缓冲区刚创建时，limit和capacity重合<br><b>位置(Position)：</b>下一个要被读或写的元素的索引。用于执行要读写的位置。默认pisition为0。<br><b>标记(Mark)：</b>下一个要被读或写的元素的索引。类似于数组的下标，用于执行要读写的位置。默认情况下mark为-1</li><li>重要操作<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// flip:翻转缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   limit = position;</span><br><span class="line">   position = <span class="number">0</span>;</span><br><span class="line">   mark = -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// clear:清空缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   position = <span class="number">0</span>;</span><br><span class="line">   limit =  capacity;</span><br><span class="line">   mark = -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// reset:重置缓冲区</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">rewind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   postion = <span class="number">0</span>;</span><br><span class="line">   mark = -<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Channel-通道"><a href="#Channel-通道" class="headerlink" title="Channel - 通道"></a>Channel - 通道</h2><ol><li>作用：传输数据。</li><li>分类：<br> a.文件 - FileChannel<br>b.UDP - DatagramChannel<br>c.TCP - SocketChannel、ServerSocketChannel</li><li>通道默认时阻塞的，可以手动设置为非阻塞。</li><li>通道可以进行双向传输。</li></ol><h2 id="Selector-选择器"><a href="#Selector-选择器" class="headerlink" title="Selector - 选择器"></a>Selector - 选择器</h2><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的线程来“选择”通道：这些通里已经有可以处理的褕入，或者选择已准备写入的通道。这选怿机制，使得一个单独的线程很容易来管理多个通道。</p><ol><li>作用：选择事件。</li><li>选择器是面向通道进行操作，但是选择器要求通道必须是非阻塞的。</li><li>利用选择器，可以实现一对多的效果。</li></ol><p><a href="https://blog.csdn.net/charjay_lin/article/details/81810922" target="_blank" rel="noopener">参考资料</a></p>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 高并发 </tag>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS添加开机自启动命令及脚本</title>
      <link href="/p/7156016b.html"/>
      <url>/p/7156016b.html</url>
      
        <content type="html"><![CDATA[<h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>如果只是添加一条简单的开机启动命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chmod + x &#x2F;etc&#x2F;rc.d&#x2F;rc.local</span><br><span class="line">#将要执行的命令写到 &#x2F;etc&#x2F;rc.d&#x2F;rc.local 这个文件中</span><br><span class="line">#重新启动即可</span><br><span class="line">reboot</span><br></pre></td></tr></table></figure><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>添加开机自启服务，在CentOS中添加开机自启动服务非常方便，只需要两条命令（以Nginx为例）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable nginx.service #设置Nginx服务为自启动服务</span><br><span class="line">systemctl start nginx.service  #设置Nginx服务</span><br></pre></td></tr></table></figure><p>如果没有nginx.service附件需要自己添加，自定义服务文件，添加到系统服务通过Systemctl管理,如下服务文件实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]:服务的说明</span><br><span class="line">Description:描述服务</span><br><span class="line">After:描述服务类别</span><br><span class="line"></span><br><span class="line">[Service]服务运行参数的设置</span><br><span class="line">Type&#x3D;forking是后台运行的形式</span><br><span class="line">ExecStart为服务的具体运行命令</span><br><span class="line">ExecReload为重启命令</span><br><span class="line">ExecStop为停止命令</span><br><span class="line">PrivateTmp&#x3D;True表示给服务分配独立的临时空间</span><br><span class="line">注意：启动、重启、停止命令全部要求使用绝对路径</span><br><span class="line">[Install]服务安装的相关设置，可设置为多用户</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;nginx - high performance web server</span><br><span class="line">After&#x3D;network.target remote-fs.target nss-lookup.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -c &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">ExecReload&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s reload</span><br><span class="line">ExecStop&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx -s stop</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><ol><li>保存目录，以754权限保存在/usr/lib/systemd/system</li><li>设置开机自启动，在任意目录下执行 systemctl enable nginx.service</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#启动nginx服务</span><br><span class="line">systemctl start nginx.service</span><br><span class="line">#设置开机自启动</span><br><span class="line">systemctl enable nginx.service</span><br><span class="line">#停止开机自启动</span><br><span class="line">systemctl disable nginx.service</span><br><span class="line">#查看服务当前状态</span><br><span class="line">systemctl status nginx.service</span><br><span class="line">#重新启动服务</span><br><span class="line">systemctl restart nginx.service</span><br><span class="line">#查看所有已启动的服务</span><br><span class="line">systemctl list-units --type&#x3D;service</span><br></pre></td></tr></table></figure><h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><p>添加开机自启脚本</p><p>在CentOS中添加脚本有两种常用的方法，首先添加nginx启动脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">## processname: nginx</span><br><span class="line"></span><br><span class="line">nginx&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br><span class="line">conf&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br><span class="line">case $1 in</span><br><span class="line">start)</span><br><span class="line">echo -n &quot;Starting Nginx&quot;</span><br><span class="line">$nginx -c $conf</span><br><span class="line">echo &quot; done&quot;</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">echo -n &quot;Stopping Nginx&quot;</span><br><span class="line">killall -9 nginx</span><br><span class="line">echo &quot; done&quot;</span><br><span class="line">;;</span><br><span class="line">test)</span><br><span class="line">$nginx -t -c $conf</span><br><span class="line">;;</span><br><span class="line">reload)</span><br><span class="line">echo -n &quot;Reloading Nginx&quot;</span><br><span class="line">ps auxww | grep nginx | grep master | awk &#39;&#123;print $2&#125;&#39; | xargs kill -HUP</span><br><span class="line">echo &quot; done&quot;</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">$0 stop</span><br><span class="line">$0 start</span><br><span class="line">;;</span><br><span class="line">show)</span><br><span class="line">ps -aux|grep nginx</span><br><span class="line">;;</span><br><span class="line">*)</span><br><span class="line">echo -n &quot;Usage: $0 &#123;start|restart|reload|stop|test|show&#125;&quot;</span><br><span class="line">;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>赋予脚本可执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod +x 脚本位置</span><br><span class="line">chomod +x &#x2F;etc&#x2F;rc.d&#x2F;rc.local</span><br><span class="line">vi &#x2F;etc&#x2F;rc.d&#x2F;rc.local #在该文件下末尾增加执行脚本文件命令即可</span><br></pre></td></tr></table></figure><h2 id="方案四"><a href="#方案四" class="headerlink" title="方案四"></a>方案四</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#将脚本移动到&#x2F;etc&#x2F;rc.d&#x2F;init.d 目录下</span><br><span class="line">mv &#x2F;home&#x2F;nginx.sh &#x2F;etc&#x2F;rc&#x2F;d&#x2F;init.d</span><br><span class="line">#增加脚本可执行权限</span><br><span class="line">chmod +x &#x2F;etc&#x2F;rc&#x2F;d&#x2F;init.d&#x2F;nginx.sh</span><br><span class="line">#添加脚本到开机自动启动项目中</span><br><span class="line">cd &#x2F;etc&#x2F;rc.d&#x2F;init.d</span><br><span class="line">chkconfig --add nginx.sh</span><br><span class="line">chkconfig nginx.sh on</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> Nginx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站历程</title>
      <link href="/p/39507609.html"/>
      <url>/p/39507609.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在建立这个博客的时候，我一直考虑在哪里托管静态页面</span><br><span class="line">如下是我几次托管的经历，站在自身的角度，判断他们的特点。</span><br></pre></td></tr></table></figure><h3 id="GitHub-Page"><a href="#GitHub-Page" class="headerlink" title="GitHub Page"></a>GitHub Page</h3><ol><li><p>优点：建站很快，无需自己搭建服务器，基于GIT方便版本控制，免费300M存储空间，绑定域名容易，直接解析CNAME指向即可，重点他<strong>免费！！</strong></p></li><li><p>缺点：访问速度奇慢无比</p></li></ol><h3 id="Ali-OSS"><a href="#Ali-OSS" class="headerlink" title="Ali OSS"></a>Ali OSS</h3><ol><li><p>优点：托管方便，访问速度快，在阿里云强大的数据系统下，可以监测网站各项数据，对于阿里云OSS各项优点一一不再赘述，了解过对象存储的同学应该都知道，对于没了解的同学可以<a href="https://www.alibabacloud.com/help/zh/doc-detail/31818.htm?spm=a2c63.p38356.b99.5.1a3e4c208lSNMv" target="_blank" rel="noopener">点此了解</a>。</p></li><li><p>缺点：流量不可控，除了贵没啥好说的，另外部署静态页面比较麻烦，hexo生成的静态博客很多都是以文件夹形式的，然后默认省略了index.html。而对于阿里云的OSS来说，并不会默认访问文件夹下的index.html，所以，生成的时候需要对源码进行调整，<a href="https://zengwu.com.cn/p/dd7e8a7b.html" target="_blank" rel="noopener">具体步骤</a>。因此最后放弃了OSS部署，先把OSS作为图床。</p></li></ol><p><img src="https://molzhao-pic.oss-cn-beijing.aliyuncs.com/2020-06-06/ossfee.png" alt="OSS计费"></p><h3 id="Ali-ECS"><a href="#Ali-ECS" class="headerlink" title="Ali ECS"></a>Ali ECS</h3><ol><li>优点：方便管理，容易迁移，访问速度快</li><li>缺点：Nginx有时候会宕机，不过设置了开机自启动和阿里云进程报警，也还能接受。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
